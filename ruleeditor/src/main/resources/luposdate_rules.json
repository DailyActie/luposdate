{
  "associations": {
    "RIF Rules 1": ["Remove Unnecessary Construct"],
    "RIF Rules 0": ["Remove Empty Index"],
    "RIF Rules 7": ["Replace Generate Pat"],
    "RIF Rules 6": ["Split ConstructPredicate"],
    "RIF Rules 9": ["Remove Union"],
    "RIF Rules 8": ["Generate Pat ConstructPredicate"],
    "Logical Optimization For Stream Engine": [
      "Factor out AND in Filter",
      "Push Filter",
      "Binary Join",
      "Constant Propagation of Filter in Triple Pattern",
      "Constant Propagation of Filter in Triple Pattern with Operators Between",
      "Bound in Filter Under Add",
      "Unnecessary Optional Because of Projection"
    ],
    "RIF Rules": [
      "Remove Empty Index",
      "Remove Unnecessary Construct",
      "Remove Unnecessary ConstructPredicate",
      "Construct To Generate",
      "Split Generate",
      "Split PredicatePattern",
      "Split ConstructPredicate",
      "Replace Generate Pat",
      "Generate Pat ConstructPredicate",
      "Remove Union",
      "Remove Distinct",
      "Factor out AND in Filter",
      "Replace Filter With RuleFilter",
      "ReplaceVar Under Index",
      "Merge Memory Indexes",
      "Push RuleFilter"
    ],
    "RIF Rules 3": ["Construct To Generate"],
    "RIF Rules 2": ["Remove Unnecessary ConstructPredicate"],
    "RIF Rules 5": ["Split PredicatePattern"],
    "Logical Optimization": [
      "Factor out AND in Filter",
      "Push Filter",
      "Factor out OR in Filter",
      "ConstantPropagation of Filter in Index",
      "Constant Propagation of Filter in Index With Additional Operators Between",
      "Bound In Filter under Index",
      "Combine Unions",
      "Variable Propagation",
      "Projection Over Sort",
      "SortLimit over Sort",
      "Binary Join",
      "Optimizing Join Order",
      "Bound in Filter Under Add",
      "Unnecessary Optional Because of Projection"
    ],
    "RIF Rules 4": ["Split Generate"],
    "RIF Rules 10": ["Factor out AND in Filter"],
    "Correct Operatorgraph": [
      "Bound Variable in Optional",
      "Bound Variable in Union"
    ],
    "RIF Rules 12": ["ReplaceVar Under Index"],
    "RIF Rules 11": ["Replace Filter With RuleFilter"],
    "RIF Rules 14": ["Push RuleFilter"],
    "RIF Rules 13": ["Merge Memory Indexes"],
    "After Physical Optimization": [
      "CartesianProductAsLateAsPossible",
      "Replace UsingJoinOptional With BasicIndexOptional",
      "Replace HashMapIndexJoin with HashMapIndexJoinOnLeftOperand",
      "Push Filter"
    ],
    "RIF Rules 16": ["Remove Union"],
    "RIF Rules 15": ["HashSetNonBlockingDistinctWithIndexAccess"],
    "Physical Optimization": ["Physical Optimization Rule"]
  },
  "rules": {
    "Physical Optimization Rule": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {},
        "left side": {}
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": ["Physical Optimization"]
        },
        "long description": "This transformation rule considers several aspects.\n\nThis transformation rule chooses the concrete algorithm for a logical operator according to the option, if the memory-based variant of our prototype is used (where all the data remains in the main memory), or the disk-based variant is used (where the indices and the intermediate results on demand are stored on disk).\n\nFurthermore, this transformation rule considers specific preferences of the user for specific algorithms. This means that the user can specify (e.g. per command line option) to use e.g. the DBMergeSortedBagMergeJoin as default Join algorithm, which is considered in this transformation rule.\n\nFor the Sort operator, the transformation rule checks, whether the intermediate result is already sorted in the correct way (or can be retrieved in a sorted way), such that the Sort operator can be left out.\n\nFor the Distinct operator, this transformation rule checks whether or not the intermediate data is sorted in the correct way, such that the effcient SortedDataDistinct operator can be used.",
        "show visual representation": false,
        "right image": "",
        "use generated visual representation": true,
        "short description": "Physical optimization aims to choose the algorithm with the best estimated execution times in the context of the operator for each operator in the operator graph.",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "",
        "replace method": {
          "code": "",
          "additional code": "",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "",
          "use generated code": true
        }
      }
    },
    "Push RuleFilter": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "op2": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              5,
              1160
            ]
          },
          "op": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              5,
              467
            ]
          },
          "f": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "RuleFilter",
            "position": [
              5,
              929
            ]
          },
          "j": {
            "op type": "JumpOverOperator",
            "also subclasses": false,
            "class type": "RuleFilter",
            "position": [
              5,
              698
            ],
            "conditions": "",
            "cardinality": "*"
          },
          "f_new": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "RuleFilter",
            "position": [
              5,
              236
            ]
          },
          "connections": {
            "op": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "j",
              "id": -1
            }],
            "f": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "op2",
              "id": -1
            }],
            "j": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "f",
              "id": -1
            }],
            "f_new": [{
              "mode": "ALL_PRECEDING",
              "active": true,
              "id label": "a",
              "to": "op",
              "id": -1
            }],
            "o": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "f_new",
              "id": -1
            }]
          },
          "o": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              5,
              5
            ]
          }
        },
        "left side": {
          "op2": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              46,
              1071
            ]
          },
          "op": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              46,
              269
            ]
          },
          "f": {
            "start node": true,
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "RuleFilter",
            "position": [
              46,
              807
            ]
          },
          "j": {
            "op type": "JumpOverOperator",
            "also subclasses": false,
            "class type": "RuleFilter",
            "position": [
              5,
              533
            ],
            "conditions": "",
            "cardinality": "*"
          },
          "connections": {
            "op": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "j",
              "id": -1
            }],
            "f": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "op2",
              "id": -1
            }],
            "j": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "f",
              "id": -1
            }],
            "o": [{
              "mode": "ALL_PRECEDING",
              "active": true,
              "id label": "a",
              "to": "op",
              "id": -1
            }]
          },
          "o": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              46,
              5
            ]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": ["Push Filter"],
          "rule packages": []
        },
        "long description": "",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "Analogous to the Push Filter rule for SPARQL Filter operators, this transformation rule moves a RIF Filter operator in the operator graph, such that it is processed as early as possible in order to filter out intermediate solutions as early as possible and thus saving processing costs.",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "",
        "replace method": {
          "code": "",
          "additional code": "boolean deleteFilter = true;\n\nfor(int i = 0; i < this.o.length; i += 1) {\n    BasicOperator o2 = this.o[i];\n\n    if(!(o2 instanceof lupos.rif.operator.RuleFilter && this.f.equalFilterExpression((lupos.rif.operator.RuleFilter) o2))) {\n        if(o2.getUnionVariables().containsAll(this.f.getVariablesInExpression())) {\n            f_new[i].setIntersectionVariables(new HashSet<lupos.datastructures.items.Variable>(o2.getUnionVariables()));\n            f_new[i].setUnionVariables(new HashSet<lupos.datastructures.items.Variable>(o2.getUnionVariables()));\n            f_new[i].setExpression(this.f.getExpression());\n       } else {\n            if(deleteFilter) {\n                for(lupos.datastructures.items.Variable v : o2.getUnionVariables()) {\n                    if(this.f.getVariablesInExpression().contains(v)) {\n                        deleteFilter = false;\n\n                        break;\n                    }\n                }\n            }\n\n            this.deleteOperator(f_new[i], _startNodes);\n        }\n    }\n}\n\nif(deleteFilter || this.op instanceof lupos.engine.operators.multiinput.join.Join) {\n    this.deleteOperator(this.f, _startNodes);\n}",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "if(this.op instanceof lupos.engine.operators.tripleoperator.TriplePattern || this.op instanceof lupos.engine.operators.index.BasicIndexScan || this.op instanceof lupos.engine.operators.index.Root || this.op instanceof lupos.engine.operators.singleinput.path.Closure || this.op instanceof lupos.engine.operators.singleinput.path.PathLengthZero) {\n    return false;\n}\n\nif(this.op instanceof lupos.engine.operators.multiinput.Union) {\n  boolean flag = false;\n    for(BasicOperator o : this.op.getPrecedingOperators()) {\n        if(o.getSucceedingOperators().size() > 1 || (o instanceof lupos.rif.operator.RuleFilter && this.f.equalFilterExpression((lupos.rif.operator.RuleFilter) o))) {\n            return false;\n        }\n    if(o.getUnionVariables().containsAll(this.f.getUsedVariables())){\n      flag = true;\n    }\n    }\n\n    return flag;\n}\n\nif(this.op instanceof lupos.engine.operators.multiinput.optional.Optional || this.op instanceof lupos.engine.operators.multiinput.optional.parallel.ParallelOptional || this.op instanceof lupos.engine.operators.multiinput.optional.parallel.MergeParallelOptional) {\n    if(this.op.getPrecedingOperators().size() == 2) {\n       BasicOperator o = this.op.getPrecedingOperatorWithID(0);\n\n        if(o.getUnionVariables().containsAll(this.f.getVariablesInExpression()) && !(o instanceof lupos.rif.operator.RuleFilter && this.f.equalFilterExpression((lupos.rif.operator.RuleFilter) o))) {\n           return true;\n        }\n    }\n\n    return false;\n}\n\nif(this.op instanceof lupos.engine.operators.multiinput.join.Join) {\n    // check if the join has preceding this.ops in a loop\n    if(this.op.getCycleOperands() != null && this.op.getCycleOperands().size() > 0) {\n        return false;\n    }\n}\n\nfor(BasicOperator o : this.op.getPrecedingOperators()) {\n    if(o.getSucceedingOperators().size() == 1 && o.getUnionVariables().containsAll(this.f.getVariablesInExpression()) && !(o instanceof lupos.rif.operator.RuleFilter && this.f.equalFilterExpression((lupos.rif.operator.RuleFilter) o))) {\n        return true;\n    }\n}\n\nreturn false;",
          "use generated code": true
        }
      }
    },
    "Remove Distinct": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "o1": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              5,
              5
            ]
          },
          "o2": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              5,
              236
            ]
          },
          "connections": {"o1": [{
            "mode": "ALL_SUCCEEDING",
            "active": true,
            "id label": "a",
            "to": "o2",
            "id": -1
          }]}
        },
        "left side": {
          "o1": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              5,
              5
            ]
          },
          "o2": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              15,
              533
            ]
          },
          "d": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Distinct",
            "position": [
              9,
              269
            ]
          },
          "connections": {
            "o1": [{
              "mode": "ONLY_PRECEDING",
              "active": false,
              "id label": "",
              "to": "d",
              "id": -1
            }],
            "d": [{
              "mode": "ALL_SUCCEEDING",
              "active": true,
              "id label": "a",
              "to": "o2",
              "id": -1
            }]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": []
        },
        "long description": "",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "Removes all early duplicate eliminations...",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "",
        "replace method": {
          "code": "",
          "additional code": "this.deleteOperatorWithParentsAndChildren(this.o1, _startNodes);",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "return !(this.d.getSucceedingOperators().get(0).getOperator() instanceof lupos.engine.operators.singleinput.Result);",
          "use generated code": true
        }
      }
    },
    "Bound Variable in Union": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "o2": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              6,
              9
            ]
          },
          "o3": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              904,
              8
            ]
          },
          "u": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Union",
            "position": [
              288,
              995
            ]
          },
          "f": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              288,
              759
            ]
          },
          "j_new": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Join",
            "position": [
              287,
              293
            ]
          },
          "jump_filter": {
            "op type": "JumpOverOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              286,
              527
            ],
            "conditions": "",
            "cardinality": "*"
          },
          "connections": {
            "o2": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "j_new",
              "id": -1
            }],
            "o3": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "j_new",
              "id": -1
            }],
            "u": [{
              "mode": "ALL_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "o",
              "id": -1
            }],
            "f": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "u",
              "id": -1
            }],
            "j_new": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "jump_filter",
              "id": -1
            }],
            "jump_filter": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "f",
              "id": -1
            }]
          },
          "o": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              289,
              1226
            ]
          }
        },
        "left side": {
          "o2": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              34,
              5
            ]
          },
          "o3": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              520,
              417
            ]
          },
          "u": {
            "start node": true,
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Union",
            "position": [
              52,
              811
            ]
          },
          "f": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              51,
              545
            ]
          },
          "j": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Join",
            "position": [
              512,
              1073
            ]
          },
          "jump_filter": {
            "op type": "JumpOverOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              5,
              269
            ],
            "conditions": "",
            "cardinality": "*"
          },
          "connections": {
            "o2": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "jump_filter",
              "id": -1
            }],
            "o3": [{
              "mode": "ONLY_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "j",
              "id": -1
            }],
            "u": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "j",
              "id": -1
            }],
            "f": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "u",
              "id": -1
            }],
            "j": [{
              "mode": "ALL_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "o",
              "id": -1
            }],
            "jump_filter": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "f",
              "id": -1
            }]
          },
          "o": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              512,
              1344
            ]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": ["Bound Variable in Optional"],
          "rule packages": []
        },
        "long description": "This rule avoids failures in SPARQL queries like <span style=\"font-family:monospace;\">{ ?X ?Y ?Z. { ?X2 ?Y2 ?Z2. Filter(?X=?X2).} UNION { ... } }<\/span>\n\nLet P1 = ?X ?Y ?Z. and P2 = ?X2 ?Y2 ?Z2. If we do not correct the operator graph after generating the operator graph from the abstract syntax tree, then the Filter-expression is evaluated on results of P2, which is every time false (as ?X is not bound). Thus, we have to correct the operator graph and first join P1 and P2 before the evaluation of the filter expression.We display the graphical representation of the general transformation rule in the below given figure:",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "This rule corrects the operator graph after its generation from the abstract syntax tree, especially for the case that variables are used in filter expressions, which are bound outside of the UNION-clause.",
        "left image": "",
        "transition text": "?X is not necessarily bound in results of O2, but can be bound in results of O3"
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "",
        "replace method": {
          "code": "",
          "additional code": "j_new.setUnionVariables(new HashSet<lupos.datastructures.items.Variable>());\nj_new.getUnionVariables().addAll(this.o2.getUnionVariables());\nj_new.getUnionVariables().addAll(this.o3.getUnionVariables());\n\nj_new.setIntersectionVariables(new HashSet<lupos.datastructures.items.Variable>());\nj_new.getIntersectionVariables().addAll(this.o2.getUnionVariables());\nj_new.getIntersectionVariables().retainAll(this.o3.getUnionVariables());\n\nthis.o2.getOperatorIDTuple(j_new).setId(0);\nthis.o3.getOperatorIDTuple(j_new).setId(1);\n\nfor(BasicOperator precOp : this.u.getPrecedingOperators()) {\n    if(!precOp.equals(this.f)) {\n        BasicOperator tmpOp = precOp;\n\n        while(tmpOp instanceof lupos.engine.operators.singleinput.Filter) {\n            tmpOp = tmpOp.getPrecedingOperators().get(0);\n        }\n\n\n        lupos.engine.operators.multiinput.join.Join newJoin = new lupos.engine.operators.multiinput.join.Join();\n\n        newJoin.addPrecedingOperator(tmpOp);\n        newJoin.addPrecedingOperator(this.o3);\n\n        for(OperatorIDTuple opIDt : tmpOp.getSucceedingOperators()) {\n            opIDt.getOperator().removePrecedingOperator(tmpOp);\n            opIDt.getOperator().addPrecedingOperator(newJoin);\n        }\n\n        newJoin.setSucceedingOperators(tmpOp.getSucceedingOperators());\n        tmpOp.setSucceedingOperator(new OperatorIDTuple(newJoin, 0));\n        this.o3.addSucceedingOperator(new OperatorIDTuple(newJoin, 1));\n\n\n        HashSet<lupos.datastructures.items.Variable> intersectionVariables = new HashSet<lupos.datastructures.items.Variable>();\n        intersectionVariables.addAll(tmpOp.getUnionVariables());\n        intersectionVariables.retainAll(this.o3.getUnionVariables());\n\n        HashSet<lupos.datastructures.items.Variable> unionVariables = new HashSet<lupos.datastructures.items.Variable>();\n        unionVariables.addAll(tmpOp.getUnionVariables());\n        unionVariables.addAll(this.o3.getUnionVariables());\n\n        newJoin.setIntersectionVariables(intersectionVariables);\n        newJoin.setUnionVariables(unionVariables);\n\n\n        tmpOp = tmpOp.getSucceedingOperators().get(0).getOperator();\n\n        while(!tmpOp.equals(this.u)) {\n            tmpOp.setUnionVariables(unionVariables);\n            tmpOp.setIntersectionVariables(intersectionVariables);\n\n            tmpOp = tmpOp.getSucceedingOperators().get(0).getOperator();\n        }\n    }\n}",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "if(this.u.getOperatorIDTuple(this.j).getId()==this.o3.getOperatorIDTuple(this.j).getId()){\n\treturn false;\n}\n\nlupos.engine.operators.singleinput.Filter filterOutestFilter = this.f;\njava.util.Collection<lupos.datastructures.items.Variable> variablesInnerUnion = this.o2.getIntersectionVariables();\njava.util.Collection<lupos.datastructures.items.Variable> variablesOuterUnion = this.o3.getUnionVariables();\nboolean checkFurther = true;\n\nwhile(checkFurther) {\n    if(!variablesInnerUnion.containsAll(filterOutestFilter.getUsedVariables())) {\n        for(lupos.datastructures.items.Variable v : filterOutestFilter.getUsedVariables()) {\n            if(!variablesInnerUnion.contains(v) && variablesOuterUnion.contains(v)) {\n                return true;\n            }\n        }\n    }\n\n    BasicOperator nextOp = filterOutestFilter.getPrecedingOperators().get(0);\n\n    if(nextOp.equals(this.o2)) {\n        checkFurther = false;\n    }\n    else {\n        filterOutestFilter = (lupos.engine.operators.singleinput.Filter) nextOp;\n    }\n}\nreturn false;",
          "use generated code": true
        }
      }
    },
    "ReplaceVar Under Index": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "i": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Index",
            "position": [
              17,
              7
            ]
          },
          "connections": {"i": [{
            "mode": "ALL_PRECEDING",
            "active": true,
            "id label": "a",
            "to": "o",
            "id": -1
          }]},
          "o": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              9,
              531
            ]
          }
        },
        "left side": {
          "r": {
            "start node": true,
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "ReplaceVar",
            "position": [
              5,
              269
            ]
          },
          "i": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Index",
            "position": [
              6,
              5
            ]
          },
          "connections": {
            "r": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "o",
              "id": -1
            }],
            "i": [{
              "mode": "ALL_PRECEDING",
              "active": true,
              "id label": "a",
              "to": "r",
              "id": -1
            }]
          },
          "o": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              9,
              533
            ]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": []
        },
        "long description": "",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "ReplaceVar under Index Scan operators are eliminated by replacing the variable directly in the Index Scan operator.",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "private int varCounter = 0;",
        "replace method": {
          "code": "",
          "additional code": "for(lupos.engine.operators.index.BasicIndexScan index : this.i) {\n    java.util.Map<String, lupos.datastructures.items.Variable> varMap = new java.util.HashMap<String, lupos.datastructures.items.Variable>();\n    java.util.Map<lupos.datastructures.items.Variable, String> aliasMap = new java.util.HashMap<lupos.datastructures.items.Variable, String>();\n\n    for(lupos.datastructures.items.Variable var : index.getUnionVariables()) {\n        String aliasName = \"RepVar_\" + this.varCounter++ + \"_\" + var.getName();\n        varMap.put(aliasName, var);\n        aliasMap.put(var, aliasName);\n    }\n\n    for(lupos.engine.operators.tripleoperator.TriplePattern tp : index.getTriplePattern()) {\n        for(lupos.datastructures.items.Variable var : tp.getVariables()) {\n            tp.replace(var, new lupos.datastructures.items.Variable(aliasMap.get(var)));\n        }\n    }\n\n    for(lupos.engine.operators.tripleoperator.TriplePattern tp : index.getTriplePattern()) {\n        for(lupos.datastructures.items.Variable v : tp.getVariables()) {\n            lupos.datastructures.items.Variable rv = this.r.getReplacement(varMap.get(v.getName()));\n\n            if(rv != null) {\n                tp.replace(v, rv);\n            }\n        }\n    }\n}",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "java.util.Set<lupos.datastructures.items.Variable> vars = new java.util.HashSet<lupos.datastructures.items.Variable>(this.r.getSubstitutionsVariableRight());\n\nif(vars.size() != this.r.getSubstitutionsVariableRight().size()) {\n    return false;\n}\n\nif(this.o instanceof lupos.engine.operators.singleinput.Result) {\n    return false;\n}\n\nfor(lupos.engine.operators.index.BasicIndexScan tmp_i : this.i) {\n    if(tmp_i.getSucceedingOperators().size() > 1) {\n        return false;\n    }\n}",
          "use generated code": true
        }
      }
    },
    "Generate Pat ConstructPredicate": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {},
        "left side": {
          "p": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "PredicatePattern",
            "position": [
              5,
              269
            ]
          },
          "c": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "ConstructPredicate",
            "position": [
              5,
              5
            ]
          },
          "connections": {"c": [{
            "mode": "ONLY_SUCCEEDING",
            "active": false,
            "id label": "",
            "to": "p",
            "id": -1
          }]}
        }
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": []
        },
        "long description": "",
        "show visual representation": false,
        "right image": "",
        "use generated visual representation": true,
        "short description": "A generated predicate is immediately consumed from a Predicate Pattern. This transformation rule reduces this to the direct assignment of variables.",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "",
        "replace method": {
          "code": "final lupos.datastructures.items.literal.URILiteral patURI = this.p.getPredicateName();\n\t\tfinal lupos.datastructures.items.Item[] patItems = this.p.getPatternItems().toArray(new lupos.datastructures.items.Item[] {});\n\n\t\tfinal lupos.datastructures.items.literal.URILiteral constructURI = this.c.getPredicatePattern().get(0)\n\t\t\t\t.getFirst();\n\t\tfinal lupos.datastructures.items.Item[] constructItems = this.c.getPredicatePattern().get(0)\n\t\t\t\t.getSecond().toArray(new lupos.datastructures.items.Item[] {});\n\n\t\tlupos.rif.operator.RuleFilter filter = null;\n\t\tfinal lupos.engine.operators.singleinput.ReplaceVar replaceVar = new lupos.engine.operators.singleinput.ReplaceVar();\n\t\treplaceVar.setIntersectionVariables(new java.util.HashSet<lupos.datastructures.items.Variable>());\n\t\treplaceVar.setUnionVariables(replaceVar.getIntersectionVariables());\n\n\t\tfinal java.util.LinkedList<lupos.datastructures.items.Variable> addBindingsVar = new java.util.LinkedList<lupos.datastructures.items.Variable>();\n\t\tfinal java.util.LinkedList<lupos.datastructures.items.literal.Literal> addBindingsLit = new java.util.LinkedList<lupos.datastructures.items.literal.Literal>();\n\n\t\tif (!patURI.equals(constructURI)\n\t\t\t\t|| patItems.length != constructItems.length) {\n\t\t\tfor (final BasicOperator parent : this.c.getPrecedingOperators())\n\t\t\t\tparent.removeSucceedingOperator(this.c);\n\t\t\tthis.c.getPrecedingOperators().clear();\n\t\t\tthis.c.removeFromOperatorGraph();\n\t\t\treturn;\n\t\t}\n\n\t\tfinal lupos.rif.model.Conjunction conj = new lupos.rif.model.Conjunction();\n\t\tfor (int i = 0; i < patItems.length; i++) {\n\t\t\tfinal lupos.datastructures.items.Item patItem = patItems[i];\n\t\t\tfinal lupos.datastructures.items.Item constructItem = constructItems[i];\n\t\t\tif ((!patItem.isVariable()) && constructItem.isVariable()) {\n\t\t\t\t{\n\t\t\t\t\tfinal lupos.rif.model.Equality eq = new lupos.rif.model.Equality();\n\t\t\t\t\teq.leftExpr = new lupos.rif.model.RuleVariable(constructItem.getName());\n\t\t\t\t\teq.rightExpr = new lupos.rif.model.Constant((lupos.datastructures.items.literal.Literal) patItem, eq);\n\t\t\t\t\tconj.addExpr(eq);\n\t\t\t\t}\n\t\t\t} else if (patItem.isVariable() && constructItem.isVariable()) {\n\t\t\t\treplaceVar.addSubstitution((lupos.datastructures.items.Variable) patItem,\n\t\t\t\t\t\t(lupos.datastructures.items.Variable) constructItem);\n\t\t\t\treplaceVar.getIntersectionVariables().add((lupos.datastructures.items.Variable) patItem);\n\t\t\t} else if (patItem.isVariable() && (!constructItem.isVariable())) {\n\t\t\t\taddBindingsVar.add((lupos.datastructures.items.Variable) patItem);\n\t\t\t\taddBindingsLit.add((lupos.datastructures.items.literal.Literal) constructItem);\n\t\t\t} else if (!patItem.isVariable() && !constructItem.isVariable()\n\t\t\t\t\t&& !constructItem.equals(patItem)) {\n\t\t\t\t// cannot match, remove generate.\n\t\t\t\tfor (final BasicOperator parent : this.c.getPrecedingOperators())\n\t\t\t\t\tparent.removeSucceedingOperator(this.c);\n\t\t\t\tthis.c.getPrecedingOperators().clear();\n\t\t\t\tthis.p.removePrecedingOperator(this.c);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tfor (int x = i + 1; x < patItems.length; x++) {\n\t\t\t\tif (patItems[i].equals(patItems[x])) {\n\t\t\t\t\tfinal lupos.rif.model.Equality eq = new lupos.rif.model.Equality();\n\t\t\t\t\tif (constructItems[i].isVariable())\n\t\t\t\t\t\teq.leftExpr = new lupos.rif.model.RuleVariable(\n\t\t\t\t\t\t\t\tconstructItems[i].getName());\n\t\t\t\t\telse\n\t\t\t\t\t\teq.leftExpr = new lupos.rif.model.Constant((lupos.datastructures.items.literal.Literal) constructItems[i],\n\t\t\t\t\t\t\t\teq);\n\t\t\t\t\tif (constructItems[x].isVariable())\n\t\t\t\t\t\teq.rightExpr = new lupos.rif.model.RuleVariable(\n\t\t\t\t\t\t\t\tconstructItems[x].getName());\n\t\t\t\t\telse\n\t\t\t\t\t\teq.rightExpr = new lupos.rif.model.Constant(\n\t\t\t\t\t\t\t\t(lupos.datastructures.items.literal.Literal) constructItems[x], eq);\n\t\t\t\t\tconj.addExpr(eq);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!conj.isEmpty())\n\t\t\tfilter = new lupos.rif.operator.RuleFilter(conj, null);\n\n\t\t// Only Operators with a not empty definition are put into the\n\t\t// operatorgraph\n\t\tfinal java.util.LinkedList<BasicOperator> order = new java.util.LinkedList<BasicOperator>();\n\t\tif (filter != null) {\n\t\t\torder.add(filter);\n\t\t}\n\n\t\tfinal int substVar = replaceVar.getSubstitutionsVariableLeft().size();\n\n\t\tif (substVar > 0) {\n\t\t\torder.add(replaceVar);\n\t\t} else {\n\t\t\tfinal lupos.engine.operators.singleinput.Projection p = new lupos.engine.operators.singleinput.Projection();\n\t\t\tp.setIntersectionVariables(new java.util.HashSet<lupos.datastructures.items.Variable>());\n\t\t\tp.setUnionVariables(p.getUnionVariables());\n\t\t\torder.add(p);\n\t\t}\n\t\tif (addBindingsVar.size() > 0) {\n\t\t\tfinal java.util.Iterator<lupos.datastructures.items.literal.Literal> lit_it = addBindingsLit.iterator();\n\t\t\tfinal java.util.HashSet<lupos.datastructures.items.Variable> hsv = new java.util.HashSet<lupos.datastructures.items.Variable>();\n\t\t\thsv.addAll(replaceVar.getUnionVariables());\n\t\t\tfor (final lupos.datastructures.items.Variable v : addBindingsVar) {\n\t\t\t\tfinal lupos.engine.operators.singleinput.AddBinding ab = new lupos.engine.operators.singleinput.AddBinding(v, lit_it.next());\n\t\t\t\thsv.add(v);\n\t\t\t\tab.setIntersectionVariables((java.util.HashSet<lupos.datastructures.items.Variable>) hsv.clone());\n\t\t\t\tab.setUnionVariables(ab.getIntersectionVariables());\n\t\t\t\torder.add(ab);\n\t\t\t}\n\t\t}\n\n\t\t// In case that Generate or TriplePattern has minimum one variable, than\n\t\t// minimum one operator has to be inserted\n\t\tif (order.size() > 0) {\n\t\t\tfinal java.util.LinkedList<BasicOperator> pres = (java.util.LinkedList<BasicOperator>) this.c.getPrecedingOperators();\n\t\t\tBasicOperator pre;\n\t\t\tfor (int i = 0; i < pres.size(); i++) {\n\t\t\t\tpre = pres.get(i);\n\t\t\t\tpre.addSucceedingOperator(new OperatorIDTuple(order.getFirst(),\n\t\t\t\t\t\t0));\n\t\t\t\tif (filter != null) {\n\t\t\t\t\tjava.util.Collection<lupos.datastructures.items.Variable> vars = filter\n\t\t\t\t\t\t\t.getIntersectionVariables();\n\t\t\t\t\tif (vars == null)\n\t\t\t\t\t\tvars = new java.util.HashSet<lupos.datastructures.items.Variable>();\n\t\t\t\t\tvars.addAll(pre.getIntersectionVariables());\n\t\t\t\t\tfilter.setIntersectionVariables(vars);\n\t\t\t\t\tfilter.setUnionVariables(vars);\n\t\t\t\t}\n\t\t\t\tpre.removeSucceedingOperator(this.c);\n\t\t\t\torder.getFirst().addPrecedingOperator(pre);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < order.size() - 1; i++) {\n\t\t\t\torder.get(i + 1).setPrecedingOperator(order.get(i));\n\t\t\t\torder.get(i).setSucceedingOperator(\n\t\t\t\t\t\tnew OperatorIDTuple(order.get(i + 1), 0));\n\t\t\t}\n\n\t\t\tfinal java.util.List<OperatorIDTuple> succs = (java.util.List<OperatorIDTuple>) this.p.getSucceedingOperators();\n\t\t\tfor (int i = 0; i < succs.size(); i++) {\n\t\t\t\tsuccs.get(i).getOperator()\n\t\t\t\t\t\t.addPrecedingOperator(order.getLast());\n\t\t\t}\n\n\t\t\tfinal java.util.LinkedList<OperatorIDTuple> sops = new java.util.LinkedList<OperatorIDTuple>();\n\t\t\tsops.addAll(this.p.getSucceedingOperators());\n\t\t\torder.getLast().setSucceedingOperators(sops);\n\t\t} else {\n\t\t\tfinal java.util.LinkedList<BasicOperator> pres = (java.util.LinkedList<BasicOperator>) this.c.getPrecedingOperators();\n\t\t\tfinal java.util.LinkedList<OperatorIDTuple> succs = (java.util.LinkedList<OperatorIDTuple>) this.p.getSucceedingOperators();\n\t\t\tBasicOperator pre;\n\t\t\tBasicOperator succ;\n\t\t\tfor (int i = 0; i < pres.size(); i++) {\n\t\t\t\tpre = pres.get(i);\n\t\t\t\tpre.removeSucceedingOperator(this.c);\n\t\t\t\tfor (int x = 0; x < succs.size(); x++) {\n\t\t\t\t\tpre.addSucceedingOperator(succs.get(x));\n\t\t\t\t\tsucc = succs.get(x).getOperator();\n\t\t\t\t\tsucc.removePrecedingOperator(this.p);\n\t\t\t\t\tsucc.addPrecedingOperator(pre);\n\t\t\t\t}\n\t\t\t}\n\t\t}",
          "additional code": "",
          "use generated code": false
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "return this.c.getPredicatePattern().size() == 1;",
          "use generated code": true
        }
      }
    },
    "Remove Unnecessary ConstructPredicate": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {"t": {
          "op type": "RuleOperator",
          "also subclasses": false,
          "class type": "TriplePattern",
          "position": [
            18,
            18
          ]
        }},
        "left side": {
          "c": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "ConstructPredicate",
            "position": [
              25,
              5
            ]
          },
          "t": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "TriplePattern",
            "position": [
              31,
              269
            ]
          },
          "connections": {"c": [{
            "mode": "ONLY_SUCCEEDING",
            "active": false,
            "id label": "",
            "to": "t",
            "id": -1
          }]}
        }
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": []
        },
        "long description": "",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "If a ConstructPredicate has only a Triple Pattern as succeeding operator, the Triple Pattern Pattern operator will not have any result for the output of a ConstructPredicate and can be therefore removed.",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "",
        "replace method": {
          "code": "",
          "additional code": "",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "",
          "use generated code": true
        }
      }
    },
    "Replace UsingJoinOptional With BasicIndexOptional": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "suc": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              61,
              879
            ]
          },
          "leftOperand": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              16,
              21
            ]
          },
          "optional_new": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "BasicIndexOptional",
            "position": [
              32,
              535
            ]
          },
          "connections": {
            "leftOperand": [{
              "mode": "ONLY_SUCCEEDING",
              "active": true,
              "id label": "",
              "to": "optional_new",
              "id": 0
            }],
            "optional_new": [{
              "mode": "ONLY_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "suc",
              "id": -1
            }]
          }
        },
        "left side": {
          "suc": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              73,
              853
            ]
          },
          "indexScan": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Index",
            "position": [
              526,
              11
            ]
          },
          "leftOperand": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              11,
              11
            ]
          },
          "optional": {
            "start node": true,
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "UsingJoinOptional",
            "position": [
              67,
              510
            ]
          },
          "connections": {
            "indexScan": [{
              "mode": "ONLY_SUCCEEDING",
              "active": true,
              "id label": "",
              "to": "optional",
              "id": 1
            }],
            "leftOperand": [{
              "mode": "ONLY_SUCCEEDING",
              "active": true,
              "id label": "",
              "to": "optional",
              "id": 0
            }],
            "optional": [{
              "mode": "ONLY_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "suc",
              "id": -1
            }]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": []
        },
        "long description": "",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "private int operandID;",
        "replace method": {
          "code": "",
          "additional code": "optional_new.setBasicIndexScan(this.indexScan);\r\noptional_new.setUnionVariables(this.optional.getUnionVariables());\r\noptional_new.setIntersectionVariables(this.optional.getIntersectionVariables());\r\nif(this.operandID!=0){\r\n  // repairing the operand ID\r\n  optional_new.getOperatorIDTuple(this.suc).setId(this.operandID);\r\n}\r\nif(this.indexScan.getSucceedingOperators().size()==0){\r\n  this.deleteOperator(this.indexScan, _startNodes);\r\n}",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "// for later repairing operandId\r\nthis.operandID = this.optional.getOperatorIDTuple(this.suc).getId();\r\n",
          "use generated code": true
        }
      }
    },
    "Merge Memory Indexes": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "o1": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              5,
              5
            ]
          },
          "o2": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              5,
              467
            ]
          },
          "i_new": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "MemoryIndex",
            "position": [
              5,
              236
            ]
          },
          "connections": {
            "o1": [{
              "mode": "ONLY_PRECEDING",
              "active": false,
              "id label": "",
              "to": "i_new",
              "id": -1
            }],
            "i_new": [{
              "mode": "ONLY_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "o2",
              "id": -1
            }]
          }
        },
        "left side": {
          "o1": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              8,
              5
            ]
          },
          "o2": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              8,
              797
            ]
          },
          "i": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "MemoryIndex",
            "position": [
              5,
              269
            ]
          },
          "j": {
            "start node": true,
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Join",
            "position": [
              6,
              533
            ]
          },
          "connections": {
            "o1": [{
              "mode": "ONLY_PRECEDING",
              "active": false,
              "id label": "",
              "to": "i",
              "id": -1
            }],
            "i": [{
              "mode": "ALL_PRECEDING",
              "active": false,
              "id label": "",
              "to": "j",
              "id": -1
            }],
            "j": [{
              "mode": "ONLY_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "o2",
              "id": -1
            }]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": []
        },
        "long description": "",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "A Join operator joining several Memory Index Scans is replaced by one Memory Index Scan containing all Triple Patterns of the Memory Index Scan operators of the Join operator.",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "",
        "replace method": {
          "code": "        // remove obsolete connections...\n        for(lupos.engine.operators.index.memoryindex.MemoryIndexScan _parent : this.i) {\n            _parent.removeSucceedingOperator(this.j);\n            this.j.removePrecedingOperator(_parent);\n        }\n\n        for(this._dim_0 = 0; this._dim_0 < this.o1.length; this._dim_0 += 1) {\n            this.o1[this._dim_0].removeSucceedingOperator(this.i[this._dim_0]);\n            this.i[this._dim_0].removePrecedingOperator(this.o1[this._dim_0]);\n        }\n        this.j.removeSucceedingOperator(this.o2);\n        this.o2.removePrecedingOperator(this.j);\n\n        // add new operators...\n        lupos.engine.operators.index.memoryindex.MemoryIndexScan i_new = null;\n        i_new = new lupos.engine.operators.index.memoryindex.MemoryIndexScan(this.i[0].getRoot());\n\n\n        // add new connections...\n        i_new.addSucceedingOperator(this.o2);\n        this.o2.addPrecedingOperator(i_new);\n\n        this.o1[0].addSucceedingOperator(i_new);\n        i_new.addPrecedingOperator(this.o1[0]);\n\n\n        // delete unreachable operators...\n        this.deleteOperatorWithoutParentsRecursive(this.j, _startNodes);\n        for(this._dim_0 = 0; this._dim_0 < i.length; this._dim_0 += 1) {\n            this.deleteOperatorWithoutParentsRecursive(this.i[this._dim_0], _startNodes);\n        }\n\n\n\n        // additional replace method code...\n                i_new.setBindingsFactory(this.i[0].getBindingsFactory());\n        i_new.setTriplePatterns(new java.util.LinkedList<lupos.engine.operators.tripleoperator.TriplePattern>());\n        for(lupos.engine.operators.index.memoryindex.MemoryIndexScan index : this.i) {\n            i_new.getTriplePattern().addAll(index.getTriplePattern());\n        \n            i_new.getIntersectionVariables().addAll(index.getIntersectionVariables());\n            i_new.getUnionVariables().addAll(index.getUnionVariables());\n        }",
          "additional code": "",
          "use generated code": false
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "if(this._dim_0<=1)\r\n   return false;",
          "use generated code": true
        }
      }
    },
    "Push Filter": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "op2": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              57,
              1160
            ]
          },
          "op": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              57,
              467
            ]
          },
          "f": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              57,
              929
            ]
          },
          "j": {
            "op type": "JumpOverOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              109,
              698
            ],
            "conditions": "",
            "cardinality": "*"
          },
          "f_new": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              109,
              236
            ]
          },
          "connections": {
            "op": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "j",
              "id": -1
            }],
            "f": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "op2",
              "id": -1
            }],
            "j": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "f",
              "id": -1
            }],
            "f_new": [{
              "mode": "ALL_PRECEDING",
              "active": true,
              "id label": "a",
              "to": "op",
              "id": -1
            }],
            "o": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "f_new",
              "id": -1
            }]
          },
          "o": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              57,
              5
            ]
          }
        },
        "left side": {
          "op2": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              46,
              1071
            ]
          },
          "op": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              68,
              269
            ]
          },
          "f": {
            "start node": true,
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              68,
              807
            ]
          },
          "j": {
            "op type": "JumpOverOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              16,
              533
            ],
            "conditions": "",
            "cardinality": "*"
          },
          "connections": {
            "op": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "j",
              "id": -1
            }],
            "f": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "op2",
              "id": -1
            }],
            "j": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "f",
              "id": -1
            }],
            "o": [{
              "mode": "ALL_PRECEDING",
              "active": true,
              "id label": "a",
              "to": "op",
              "id": -1
            }]
          },
          "o": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              57,
              5
            ]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": ["Factor out AND in Filter"],
          "rule packages": []
        },
        "long description": "The filter is copied over its preceding operator, if the preceding operator is not a triple pattern or an (RDF3X/Hexastore) Index-operator. The filter operator is copied to those operands of the preceding operator, which bind all variables occurring in the filter expression. If the preceding operator is an Union operator, the filter operator is only copied if it can be moved to all of its operands. Currently, the filter is not moved in the case that the preceding operator is an Optional operator. The original filter is deleted if all the operand operators O1 to On of its preceding operator bind all of the used variables of the filter, or if the preceding operator is a Join operator.\n\nThe following figure contains the graphical representation of the transformation rule.",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "Filter operators never increase, but reduce the number of intermediate results in most times. Thus, it is important for the performance to evaluate a filter expression as early as possible. This rule pushes a filter operator upwards in the operator graph whenever possible.",
        "left image": "",
        "transition text": "op is neither a triple pattern nor an (RDF3X/Hexastore) Index operator nor an Optional operator. if op is an Union operator, O1 to On must bind all variables occuring in c."
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "",
        "replace method": {
          "code": "",
          "additional code": "boolean deleteFilter = true;\n\nfor(int i = 0; i < this.o.length; i += 1) {\n    BasicOperator o2 = this.o[i];\n\n    if(!(o2 instanceof lupos.engine.operators.singleinput.Filter && this.f.equalFilterExpression((lupos.engine.operators.singleinput.Filter) o2))) {\n        if(o2.getUnionVariables().containsAll(this.f.getUsedVariables())) {\n            f_new[i].setIntersectionVariables(new HashSet<lupos.datastructures.items.Variable>(o2.getUnionVariables()));\n            f_new[i].setUnionVariables(new HashSet<lupos.datastructures.items.Variable>(o2.getUnionVariables()));\n            f_new[i].setNodePointer(this.f.getNodePointer());\n                     f_new[i].setCollectionForExistNodes(this.f.getCollectionForExistNodes());\n                    f_new[i].getUsedEvaluationVisitor().setEvaluator(this.f.getUsedEvaluationVisitor().getEvaluator());                   \n       } else {\n            if(deleteFilter) {\n                for(lupos.datastructures.items.Variable v : o2.getUnionVariables()) {\n                    if(this.f.getUsedVariables().contains(v)) {\n                        deleteFilter = false;\n\n                        break;\n                    }\n                }\n            }\n\n            this.deleteOperator(f_new[i], _startNodes);\n        }\n    }\n}\n\nif(deleteFilter || this.op instanceof lupos.engine.operators.multiinput.join.Join) {\n    this.deleteOperator(this.f, _startNodes);\n}",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "if(this.op instanceof lupos.engine.operators.tripleoperator.TriplePattern || this.op instanceof lupos.engine.operators.index.BasicIndexScan || this.op instanceof lupos.engine.operators.index.Root) {\n    return false;\n}\n\nif(this.f.materializationOfLazyLiteralsNeeded()){\n  int filtermovements = 0;\n  for(final BasicOperator o : this.op.getPrecedingOperators()) {\n    for(final lupos.datastructures.items.Variable v : o.getUnionVariables()) {\n      if(this.f.getUsedVariables().contains(v)) {\n        filtermovements++;\n        break;\n      }\n    }\n  }\n  if(filtermovements>1){\n    return false;\n  }\n}\n\n\nif(this.op instanceof lupos.engine.operators.multiinput.Union) {\n    for(BasicOperator o : this.op.getPrecedingOperators()) {\n        if(o.getSucceedingOperators().size() > 1 || (o instanceof lupos.engine.operators.singleinput.Filter && this.f.equalFilterExpression((lupos.engine.operators.singleinput.Filter) o))) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nif(this.op instanceof lupos.engine.operators.multiinput.optional.Optional || this.op instanceof lupos.engine.operators.multiinput.optional.parallel.ParallelOptional || this.op instanceof lupos.engine.operators.multiinput.optional.parallel.MergeParallelOptional) {\n    if(this.op.getPrecedingOperators().size() == 2) {\n        BasicOperator o = this.op.getPrecedingOperatorWithID(0);\n\n        if(o.getUnionVariables().containsAll(this.f.getUsedVariables()) && !(o instanceof lupos.engine.operators.singleinput.Filter && this.f.equalFilterExpression((lupos.engine.operators.singleinput.Filter) o))) {\n        return true;\n        }\n    }\n\n    return false;\n}\n\nif(this.op instanceof lupos.engine.operators.multiinput.join.Join) {\n    // check if the join has preceding this.ops in a loop\n    if(this.op.getCycleOperands() != null && this.op.getCycleOperands().size() > 0) {\n        return false;\n    }\n}\n\nfor(BasicOperator o : this.op.getPrecedingOperators()) {\n    if(o.getSucceedingOperators().size() == 1 && o.getUnionVariables().containsAll(this.f.getUsedVariables()) && !(o instanceof lupos.engine.operators.singleinput.Filter && this.f.equalFilterExpression((lupos.engine.operators.singleinput.Filter) o))) {\n        return true;\n    }\n}\n\nreturn false;",
          "use generated code": true
        }
      }
    },
    "SortLimit over Sort": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "offset": {
            "op type": "JumpOverOperator",
            "also subclasses": false,
            "class type": "Offset",
            "position": [
              9,
              681
            ],
            "conditions": "",
            "cardinality": "*"
          },
          "sortLimit": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "SortLimit",
            "position": [
              5,
              235
            ]
          },
          "above": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              5,
              5
            ]
          },
          "limit": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Limit",
            "position": [
              5,
              925
            ]
          },
          "sort": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Sort",
            "position": [
              5,
              465
            ]
          },
          "connections": {
            "offset": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "limit",
              "id": -1
            }],
            "sortLimit": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": true,
              "id label": "",
              "to": "sort",
              "id": 0
            }],
            "above": [{
              "mode": "ALL_PRECEDING",
              "active": true,
              "id label": "a",
              "to": "sortLimit",
              "id": -1
            }],
            "sort": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "offset",
              "id": -1
            }]
          }
        },
        "left side": {
          "offset": {
            "op type": "JumpOverOperator",
            "also subclasses": true,
            "class type": "Offset",
            "position": [
              5,
              547
            ],
            "conditions": "",
            "cardinality": "*"
          },
          "above": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              51,
              5
            ]
          },
          "limit": {
            "start node": true,
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Limit",
            "position": [
              51,
              828
            ]
          },
          "sort": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Sort",
            "position": [
              51,
              276
            ]
          },
          "connections": {
            "offset": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "limit",
              "id": -1
            }],
            "above": [{
              "mode": "ALL_PRECEDING",
              "active": true,
              "id label": "a",
              "to": "sort",
              "id": -1
            }],
            "sort": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "offset",
              "id": -1
            }]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": []
        },
        "long description": "",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "The SortLimit operator computes the k smallest elements. This transformation rule introduces the SortLimit operator for not sorting all the elements in the case of a sort opertion in combination with a limit operation.",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "import java.util.Collection;\r\nimport java.util.LinkedList;\r\n\r\nimport lupos.engine.operators.singleinput.modifiers.Offset;\r\nimport lupos.engine.operators.singleinput.modifiers.SortLimit;\r\nimport lupos.engine.operators.singleinput.sort.Comp;\r\nimport lupos.datastructures.items.Variable;",
        "additional global java code": "private final static int MAXLIMIT = 1000;\r\nprivate int limitSortLimit = 0;",
        "replace method": {
          "code": "",
          "additional code": "sortLimit.setLimit(this.limitSortLimit);\r\nsortLimit.setComparator(this.sort.getComparator());\r\n\r\nfinal Collection<Variable> cv = new LinkedList<Variable>();\r\ncv.addAll(this.sort.getIntersectionVariables());\r\nsortLimit.setIntersectionVariables(cv);\r\nsortLimit.setUnionVariables(cv);",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "for(BasicOperator bo:above){\r\n\tif(bo instanceof SortLimit){\r\n\t\treturn false;\r\n\t}\r\n}\r\nthis.limitSortLimit = this.limit.getLimit();\r\nif(this.offset_begin!=null && this.offset_begin instanceof Offset){\r\n\tthis.limitSortLimit += ((Offset)this.offset_begin).getOffset();\r\n}\r\nif(this.limitSortLimit > MAXLIMIT){\r\n\treturn false;\r\n}",
          "use generated code": true
        }
      }
    },
    "Split ConstructPredicate": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "o1": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              5,
              5
            ]
          },
          "o2": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              5,
              467
            ]
          },
          "c_new": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "ConstructPredicate",
            "position": [
              5,
              236
            ]
          },
          "connections": {
            "o1": [{
              "mode": "ALL_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "c_new",
              "id": -1
            }],
            "c_new": [{
              "mode": "EXISTS",
              "active": true,
              "id label": "a",
              "to": "o2",
              "id": -1
            }]
          }
        },
        "left side": {
          "o1": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              5,
              5
            ]
          },
          "c": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "ConstructPredicate",
            "position": [
              5,
              269
            ]
          },
          "o2": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              5,
              533
            ]
          },
          "connections": {
            "o1": [{
              "mode": "ONLY_PRECEDING",
              "active": true,
              "id label": "a",
              "to": "c",
              "id": -1
            }],
            "c": [{
              "mode": "ALL_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "o2",
              "id": -1
            }]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": []
        },
        "long description": "",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "Creation of one ConstructPredicate for each of its predecessors, which simplifies further optimizations.",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "",
        "replace method": {
          "code": "",
          "additional code": "for(lupos.rif.operator.ConstructPredicate tmp_c : c_new) {\r\n    tmp_c.setPredicatePattern(this.c.getPredicatePattern());\r\n}",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "return this.c.getSucceedingOperators().size() > 1 && this.c.getPredicatePattern().size() == 1;",
          "use generated code": true
        }
      }
    },
    "CartesianProductAsLateAsPossible": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "Op2": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              246,
              8
            ]
          },
          "Join1": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Join",
            "position": [
              814,
              252
            ]
          },
          "Op1": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              932,
              6
            ]
          },
          "Op3": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              20,
              245
            ]
          },
          "Join2": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Join",
            "position": [
              528,
              557
            ]
          },
          "connections": {
            "Op2": [{
              "mode": "ONLY_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "Join1",
              "id": -1
            }],
            "Join1": [{
              "mode": "ONLY_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "Join2",
              "id": -1
            }],
            "Op1": [{
              "mode": "ONLY_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "Join1",
              "id": -1
            }],
            "Op3": [{
              "mode": "ONLY_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "Join2",
              "id": -1
            }]
          }
        },
        "left side": {
          "Op2": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              446,
              3
            ]
          },
          "Join1": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Join",
            "position": [
              844,
              342
            ]
          },
          "Op1": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              2,
              229
            ]
          },
          "Op3": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              1167,
              6
            ]
          },
          "Join2": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Join",
            "position": [
              457,
              702
            ]
          },
          "connections": {
            "Op2": [{
              "mode": "ONLY_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "Join1",
              "id": -1
            }],
            "Join1": [{
              "mode": "ONLY_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "Join2",
              "id": -1
            }],
            "Op1": [{
              "mode": "ONLY_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "Join2",
              "id": -1
            }],
            "Op3": [{
              "mode": "ONLY_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "Join1",
              "id": -1
            }]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": []
        },
        "long description": "",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "int id1;\r\nint id3;",
        "replace method": {
          "code": "",
          "additional code": "this.Op3.getSucceedingOperators().get(0).setId(this.id1);\r\nthis.Op1.getSucceedingOperators().get(0).setId(this.id3);\r\n        \r\nHashSet<lupos.datastructures.items.Variable> union1 = new HashSet<lupos.datastructures.items.Variable>(this.Op1.getUnionVariables());\r\nunion1.addAll(this.Op2.getUnionVariables());\r\nHashSet<lupos.datastructures.items.Variable> intersection1 = new HashSet<lupos.datastructures.items.Variable>(this.Op1.getUnionVariables());\r\nintersection1.retainAll(this.Op2.getUnionVariables());\r\n       \r\nthis.Join1.setUnionVariables(union1);\r\nthis.Join1.setIntersectionVariables(intersection1);\r\n       \r\nHashSet<lupos.datastructures.items.Variable> union2 = new HashSet<lupos.datastructures.items.Variable>(this.Op3.getUnionVariables());\r\nunion1.addAll(union1);\r\nHashSet<lupos.datastructures.items.Variable> intersection2 = new HashSet<lupos.datastructures.items.Variable>(this.Op3.getUnionVariables());\r\nintersection1.retainAll(union1);\r\n   \r\nthis.Join2.setUnionVariables(union2);\r\nthis.Join2.setIntersectionVariables(intersection2);",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "if(this.Join1.getIntersectionVariables().size()>0 ||\r\n\t\tthis.Join1.getPrecedingOperators().size()!=2 ||\r\n   \t\tthis.Join2.getPrecedingOperators().size()!=2 ||\r\n\t\tthis.Op2.equals(this.Op3) ||\r\n\t\t!(this.Join1.getClass()==lupos.engine.operators.multiinput.join.HashJoin.class || this.Join1.getClass()==lupos.engine.operators.multiinput.join.HashMapIndexJoin.class) ||\r\n\t\t!(this.Join2.getClass()==lupos.engine.operators.multiinput.join.HashJoin.class || this.Join2.getClass()==lupos.engine.operators.multiinput.join.HashMapIndexJoin.class) ){\r\n\treturn false;\r\n}\r\nfinal HashSet<lupos.datastructures.items.Variable> vars = new HashSet<lupos.datastructures.items.Variable>(this.Op1.getUnionVariables());\r\nvars.retainAll(this.Op2.getUnionVariables());\r\nif(vars.size()==0){\r\n\treturn false;\r\n}\r\nthis.id1 = this.Op1.getSucceedingOperators().get(0).getId();\r\nthis.id3 = this.Op3.getSucceedingOperators().get(0).getId();\r\n",
          "use generated code": true
        }
      }
    },
    "Optimizing Join Order": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {},
        "left side": {}
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": []
        },
        "long description": "We have two different types of query optimizers.\n\nThe first type is a simple query optimizer, which generates right-order trees for the overall join computation. This type of query optimizer just joins the intermediate result of a previous join with the result of that triple pattern, which have (a) the smallest number of results, (b) the smallest number of new bound variables, or (c) a combination of both, i.e. the query optimizers uses (b) as primary and (c) as secondary criterion. This query optimizer is used for the Index-approach (except with the optimization option set to BINARY). The Stream approach can only use (b) as criterion as the query has to be optimized before the data arrives as stream.\n\nThe previous type of query optimizer does not consider the number of results after one or more join computations, which considers our second type of query optimizer. This second type of query optimizer is used for the RDF3X (- Presorting), Hexastore (- Presorting) and Index (with optimization option set to BINARY) approaches.\n\nFor the second type of query optimizer, we use equi-depth histograms [1] for the join cardinality estimation in order to calculate the cost of each join and thus the overall cost of a concrete plan. We employ the technique of the dynamic programming for generating the execution plan with the optimal join order, i.e. our query optimizer composes a new best solution by considering the best solutions of its subproblems. In more detail, for a set S of triple patterns, our query optimizer builds every possible disjoint subsets S1 and S2, the union of which is S, i.e. S = S1 union S2. For each of these subsets S1 and S2, our query optimizer looks up the best solutions for their join orderings, which has been computed earlier, and calculates a new cost for this solution. Among these solutions, our query optimizer chooses the ones with the minimal costs for the overall solution for S.\n\nA merge join can be computed using different collation orders. For example, a merge join can be applied to compute the triple patterns ?a <type> ?b and <book> ?b ?a, using either ?a as the primary order, or ?b as the primary order. In order to reduce the number of intermediate plans, our query optimizer only checks whether or not a merge join can be applied, but does not store the collation orders used to compute the join at this step. The used collation orders for answering the single triple patterns are fixed (and stored) in the last step, when the whole plan is considered.\n\nSince merge joins without additional sorting phases are very cheap, our query optimizer chooses merge joins without additional sorting phases as much as possible.\n\n[1] Piatetsky-Shapiro G., Connell C.: Accurate Estimation of the Number of Tuples Satisfying a Condition. SIGMOD Conf., 1984.",
        "show visual representation": false,
        "right image": "",
        "use generated visual representation": true,
        "short description": "The join order is optimized by etimating the cardinality of the result of single joins and first joining those, which have the estimated smallest number of intermediate results.",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "",
        "replace method": {
          "code": "",
          "additional code": "",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "",
          "use generated code": true
        }
      }
    },
    "Factor out AND in Filter": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "b2": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              66,
              467
            ]
          },
          "a": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              32,
              5
            ]
          },
          "b": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              72,
              236
            ]
          },
          "c": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              32,
              698
            ]
          },
          "connections": {
            "b2": [{
              "mode": "ONLY_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "c",
              "id": -1
            }],
            "a": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "b",
              "id": -1
            }],
            "b": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "b2",
              "id": -1
            }]
          }
        },
        "left side": {
          "a": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              29,
              5
            ]
          },
          "b": {
            "start node": true,
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              74,
              269
            ]
          },
          "c": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              29,
              533
            ]
          },
          "connections": {
            "a": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "b",
              "id": -1
            }],
            "b": [{
              "mode": "ONLY_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "c",
              "id": -1
            }]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": ["Push Filter"],
          "rule packages": []
        },
        "long description": "Let c1 and c2 be boolean expressions. Then this rule factors each c1 && c2 top-level operations in Filter expressions out. We present the general transformation rule in the below given figure:",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "All AND (&&) -operations in filter expressions are factored out.",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "private int operandIDOfFilter;",
        "replace method": {
          "code": "",
          "additional code": "lupos.sparql1_1.Node n = this.b.getNodePointer();\n\nn = n.jjtGetChild(0);\nlupos.sparql1_1.ASTFilterConstraint node1 = new lupos.sparql1_1.ASTFilterConstraint(\t0);\nlupos.sparql1_1.ASTFilterConstraint node2 = new lupos.sparql1_1.ASTFilterConstraint(\t1);\nnode1.jjtAddChild(n.jjtGetChild(0), 0);\nnode2.jjtAddChild(n.jjtGetChild(1), 0);\nn.jjtGetChild(0).jjtSetParent(node1);\nn.jjtGetChild(1).jjtSetParent(node2);\n\nthis.b.setNodePointer(node1);\nb2.setNodePointer(node2);\n\nb2.setCollectionForExistNodes(this.b.getCollectionForExistNodes());\nb2.getUsedEvaluationVisitor().setEvaluator(this.b.getUsedEvaluationVisitor().getEvaluator());\n\nb2.setIntersectionVariables(this.b.getIntersectionVariables());\nb2.setUnionVariables(this.b.getUnionVariables());\nb2.getOperatorIDTuple(c).setId(this.operandIDOfFilter);\n\n",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "this.operandIDOfFilter = this.b.getOperatorIDTuple(c).getId();\nlupos.sparql1_1.Node n = this.b.getNodePointer();\n\nif(n.jjtGetNumChildren() > 0) {\n    n = n.jjtGetChild(0);\n\n    return (n instanceof lupos.sparql1_1.ASTAndNode);\n}",
          "use generated code": true
        }
      }
    },
    "Split PredicatePattern": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "o1": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              5,
              5
            ]
          },
          "o2": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              5,
              467
            ]
          },
          "p_new": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "PredicatePattern",
            "position": [
              5,
              236
            ]
          },
          "connections": {
            "o1": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "p_new",
              "id": -1
            }],
            "p_new": [{
              "mode": "ALL_PRECEDING",
              "active": true,
              "id label": "a",
              "to": "o2",
              "id": -1
            }]
          }
        },
        "left side": {
          "p": {
            "start node": true,
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "PredicatePattern",
            "position": [
              5,
              269
            ]
          },
          "o1": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              5,
              5
            ]
          },
          "o2": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              5,
              533
            ]
          },
          "connections": {
            "p": [{
              "mode": "ONLY_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "o2",
              "id": -1
            }],
            "o1": [{
              "mode": "ALL_PRECEDING",
              "active": true,
              "id label": "a",
              "to": "p",
              "id": -1
            }]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": []
        },
        "long description": "",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "Creation of one PredicatePattern for each of its predecessors, which simplifies further optimizations.",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "private int id;",
        "replace method": {
          "code": "",
          "additional code": "if(this.p.getUnionVariables()==null){\n  this.p.setVariables();\n}\nfor(lupos.rif.operator.PredicatePattern tmp_p : p_new) {\n    tmp_p.getSucceedingOperators().get(0).setId(id);\n    tmp_p.setUnionVariables(new java.util.HashSet<lupos.datastructures.items.Variable>(this.p.getUnionVariables()));\n    tmp_p.setIntersectionVariables(new java.util.HashSet<lupos.datastructures.items.Variable>(this.p.getIntersectionVariables()));\n    tmp_p.setPredicateName(this.p.getPredicateName());\n    tmp_p.setPatternItems(this.p.getPatternItems());\n}",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "this.id = p.getSucceedingOperators().get(0).getId();\nreturn this.p.getPrecedingOperators().size() > 1;",
          "use generated code": true
        }
      }
    },
    "Constant Propagation of Filter in Triple Pattern": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "b": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "AddBinding",
            "position": [
              5,
              282
            ]
          },
          "tp": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "TriplePattern",
            "position": [
              2,
              0
            ]
          },
          "connections": {
            "b": [{
              "mode": "ALL_SUCCEEDING",
              "active": true,
              "id label": "a",
              "to": "o",
              "id": -1
            }],
            "tp": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "b",
              "id": -1
            }]
          },
          "o": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              5,
              611
            ]
          }
        },
        "left side": {
          "f": {
            "start node": true,
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              0,
              267
            ]
          },
          "tp": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "TriplePattern",
            "position": [
              1,
              0
            ]
          },
          "connections": {
            "f": [{
              "mode": "ALL_SUCCEEDING",
              "active": true,
              "id label": "a",
              "to": "o",
              "id": -1
            }],
            "tp": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "f",
              "id": -1
            }]
          },
          "o": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              0,
              566
            ]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": []
        },
        "long description": "",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "This rule implements constant propagation from Filter to Triple Pattern.",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "private lupos.datastructures.items.Variable var = null;\r\nprivate lupos.datastructures.items.literal.Literal constant = null;",
        "replace method": {
          "code": "",
          "additional code": "this.constant = this.constant.createThisLiteralNew();\r\njava.util.Set<lupos.datastructures.items.Variable> replacedVars = this.tp.replace(this.var, this.constant);\r\nthis.tp.getIntersectionVariables().removeAll(replacedVars);\r\nthis.tp.getUnionVariables().removeAll(replacedVars);\r\n\r\nb.setVar(this.var);\r\nb.setLiteral(this.constant);\r\n\r\njava.util.LinkedList<lupos.datastructures.items.Variable> unionVars=new java.util.LinkedList<lupos.datastructures.items.Variable>(this.tp.getUnionVariables());\r\nunionVars.add(this.var);\r\njava.util.LinkedList<lupos.datastructures.items.Variable> intersectionVars=new java.util.LinkedList<lupos.datastructures.items.Variable>(unionVars);\r\n\r\nb.setUnionVariables(unionVars);\r\nb.setIntersectionVariables(intersectionVars);",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "lupos.sparql1_1.Node n = this.f.getNodePointer();\r\n\r\nif(n.jjtGetNumChildren() > 0) {\r\n    n = n.jjtGetChild(0);\r\n\r\n    if(n instanceof lupos.sparql1_1.ASTEqualsNode) {\r\n        lupos.sparql1_1.Node left = n.jjtGetChild(0);\r\n        lupos.sparql1_1.Node right = n.jjtGetChild(1);\r\n\r\n        if(right instanceof lupos.sparql1_1.ASTVar) {\r\n            lupos.sparql1_1.Node tmp = left;\r\n            left = right;\r\n            right = tmp;\r\n        }\r\n\r\n        if(left instanceof lupos.sparql1_1.ASTVar) {\r\n            String varname = ((lupos.sparql1_1.ASTVar) left).getName();\r\n            this.var = new lupos.datastructures.items.Variable(varname);\r\n\r\n            if(!this.tp.getVariables().contains(this.var)){\r\n              return false;\r\n            }\r\n\r\n            if(!this.tp.getVariables().contains(this.var) && !this.tp.getVariables().contains(new lupos.datastructures.items.VariableInInferenceRule(varname))) {\r\n                // TODO: delete triple pattern as it will never have a result!\r\n                System.err.println(\"Can be optimized by extending RuleReplaceConstantOfFilterInTriplePattern: delete triple pattern with succeeding unsatisfiable filter expression!\");\r\n\r\n                return false;\r\n            }\r\n\r\n            if(right instanceof lupos.sparql1_1.ASTQName\r\n               || right instanceof lupos.sparql1_1.ASTRDFLiteral\r\n               || right instanceof lupos.sparql1_1.ASTQuotedURIRef\r\n               || right instanceof lupos.sparql1_1.ASTFloatingPoint\r\n               || right instanceof lupos.sparql1_1.ASTInteger\r\n               || right instanceof lupos.sparql1_1.ASTStringLiteral\r\n               || right instanceof lupos.sparql1_1.ASTDoubleCircumflex) {\r\n                this.constant = lupos.datastructures.items.literal.LazyLiteral.getLiteral(right);\r\n\r\n                // Is it possible to loose the information of the original string representation?\r\n                if(this.constant instanceof lupos.datastructures.items.literal.TypedLiteralOriginalContent || constant instanceof lupos.datastructures.items.literal.LanguageTaggedLiteralOriginalLanguage) {\r\n                    \treturn false;\r\n                }\r\n                else if(this.constant instanceof lupos.datastructures.items.literal.TypedLiteral) {\r\n                    if(lupos.engine.operators.singleinput.ExpressionEvaluation.Helper.isNumeric(((lupos.datastructures.items.literal.TypedLiteral) constant).getType())) {\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        return true;\r\n                    }\r\n                }\r\n                else {\r\n                    return true;\r\n                }\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\nelse {\r\n    return false;\r\n}",
          "use generated code": true
        }
      }
    },
    "Remove Unnecessary Construct": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {"p": {
          "op type": "RuleOperator",
          "also subclasses": false,
          "class type": "PredicatePattern",
          "position": [
            29,
            15
          ]
        }},
        "left side": {
          "p": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "PredicatePattern",
            "position": [
              28,
              272
            ]
          },
          "c": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Construct",
            "position": [
              32,
              11
            ]
          },
          "connections": {"c": [{
            "mode": "ONLY_SUCCEEDING",
            "active": false,
            "id label": "",
            "to": "p",
            "id": -1
          }]}
        }
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": ["RIF Rules"]
        },
        "long description": "",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "If a Construct has only a PredicatePattern as succeeding operator, the PredicatePattern operator will not have any result for the output of a Construct and can be therefore removed.",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "",
        "replace method": {
          "code": "",
          "additional code": "",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "",
          "use generated code": true
        }
      }
    },
    "Variable Propagation": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "b": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "AddBindingFromOtherVar",
            "position": [
              40,
              467
            ]
          },
          "i": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Index",
            "position": [
              42,
              5
            ]
          },
          "j": {
            "op type": "JumpOverOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              67,
              236
            ],
            "conditions": "",
            "cardinality": "*"
          },
          "connections": {
            "b": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "o",
              "id": -1
            }],
            "i": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "j",
              "id": -1
            }],
            "j": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "b",
              "id": -1
            }]
          },
          "o": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              63,
              698
            ]
          }
        },
        "left side": {
          "f": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              52,
              543
            ]
          },
          "i": {
            "start node": true,
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Index",
            "position": [
              51,
              5
            ]
          },
          "j": {
            "op type": "JumpOverOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              19,
              269
            ],
            "conditions": "",
            "cardinality": "*"
          },
          "connections": {
            "f": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "o",
              "id": -1
            }],
            "i": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "j",
              "id": -1
            }],
            "j": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "f",
              "id": -1
            }]
          },
          "o": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              54,
              807
            ]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": [
            "Factor out OR in Filter",
            "Constant Propagation of Filter in Index With Additional Operators Between"
          ],
          "rule packages": []
        },
        "long description": "If there are Filter expressions with a value-comparision of two variables, e.g. Filter(?X=?Y), then one of the variables can be propagated to preceding (RDF3X/Hexastore) Index operators in certain cases. However there are problems, if the variables can contain values with ambiguous representations. The values are not identical, but value-equal in this case. These situations might occur when both corresponding variables do not occur in the subject or the predicate of a triple pattern, but only in the objects, which can contain numerical values or language tagged literals. The transformation rule is not applied in these cases.\n\nThe following figure contains the graphical representation of the transformation rule.",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "This rule implements variable propagation.",
        "left image": "",
        "transition text": "?X or ?Y occurs in a subject or a predicate of a triple pattern of the index operator"
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "private lupos.datastructures.items.Variable var = null;\nprivate lupos.datastructures.items.Variable otherVar = null;\nprivate int operandIDOfFilter;",
        "replace method": {
          "code": "",
          "additional code": "this.i.replace(this.var, this.otherVar);\n\nb.setVar(this.var);\nb.setOtherVar(this.otherVar);\n\nBasicOperator tmp = this.i;\n\nwhile(!tmp.equals(b)) {\n    tmp.getUnionVariables().remove(this.var);\n    tmp.getIntersectionVariables().remove(this.var);\n\n    tmp = tmp.getSucceedingOperators().get(0).getOperator();\n}\n\nb.setUnionVariables(this.f.getUnionVariables());\nb.setIntersectionVariables(this.f.getIntersectionVariables());\nb.getOperatorIDTuple(o).setId(this.operandIDOfFilter);",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "lupos.sparql1_1.Node n = this.f.getNodePointer();\n\nif(n.jjtGetNumChildren() > 0) {\n    n = n.jjtGetChild(0);\n\n    if(n instanceof lupos.sparql1_1.ASTEqualsNode) {\n        lupos.sparql1_1.Node left = n.jjtGetChild(0);\n        lupos.sparql1_1.Node right = n.jjtGetChild(1);\n\n        if(left instanceof lupos.sparql1_1.ASTVar) {\n            this.var = new lupos.datastructures.items.Variable(((lupos.sparql1_1.ASTVar) left).getName());\n\n            if(right instanceof lupos.sparql1_1.ASTVar) {\n                this.otherVar = new lupos.datastructures.items.Variable(((lupos.sparql1_1.ASTVar) right).getName());\n\n                if(this.i.occurInSubjectOrPredicateOrObjectOriginalStringDoesNotDiffer(this.var) || this.i.occurInSubjectOrPredicateOrObjectOriginalStringDoesNotDiffer(this.otherVar)) {\n                    this.operandIDOfFilter = this.f.getOperatorIDTuple(o).getId();\n                    return true;\n                }\n                else {\n                    // in objects, there might occur typed literals e.g.\n                    // numbers, which are value equal, but do not have the\n                    // same identity, e.g. 01^^xsd:int and 1^^xsd:int.\n                    // => var or otherVar must occur in the subject or\n                    // predicate of a triple pattern, such that they are\n                    // URIs or blank nodes, which have an unique\n                    // representation!\n                    return false;\n                }\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    else {\n        return false;\n   }\n}\nelse {\n    return false;\n}",
          "use generated code": true
        }
      }
    },
    "Remove Union": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "o1": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              14,
              9
            ]
          },
          "o2": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              19,
              556
            ]
          },
          "connections": {"o1": [{
            "mode": "EXISTS",
            "active": false,
            "id label": "",
            "to": "o2",
            "id": -1
          }]}
        },
        "left side": {
          "o1": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              5,
              5
            ]
          },
          "o2": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              5,
              533
            ]
          },
          "u": {
            "start node": true,
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Union",
            "position": [
              5,
              269
            ]
          },
          "connections": {
            "o1": [{
              "mode": "ALL_PRECEDING",
              "active": false,
              "id label": "",
              "to": "u",
              "id": -1
            }],
            "u": [{
              "mode": "ALL_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "o2",
              "id": -1
            }]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": []
        },
        "long description": "",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "All unions are removed by this transformation rule by directly connecting all preceding operators of the union operator with its succeeding operators. This saves a lot of processing costs.",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "",
        "replace method": {
          "code": "for(BasicOperator over : this.u.getPrecedingOperators()) {\n\tfor(OperatorIDTuple opID: this.u.getSucceedingOperators()){\n\t\tover.addSucceedingOperator(new OperatorIDTuple(opID));\n\t\topID.getOperator().addPrecedingOperator(over);\n\t}\n}\n\nthis.u.removeFromOperatorGraphWithoutConnectingPrecedingWithSucceedingOperators();\nthis.deleteNodeFromStartNodeMapNullCheck(this.u, _startNodes);",
          "additional code": "",
          "use generated code": false
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "return !(this.u instanceof lupos.engine.operators.multiinput.MergeUnion);",
          "use generated code": true
        }
      }
    },
    "Binary Join": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {},
        "left side": {
          "o1": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              5,
              5
            ]
          },
          "o2": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              5,
              533
            ]
          },
          "join": {
            "start node": true,
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Join",
            "position": [
              5,
              269
            ]
          },
          "connections": {
            "o1": [{
              "mode": "ALL_PRECEDING",
              "active": false,
              "id label": "",
              "to": "join",
              "id": -1
            }],
            "join": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "o2",
              "id": -1
            }]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": ["Optimizing Join Order"],
          "rule packages": []
        },
        "long description": "The operator graph can contain joins with more than two operands. In this case, this transformation rule generates several join operators, which have only two operands (in a deep right-tree) and which first join those triple patterns, which have the smallest number of not already bound variables. In the case of the Stream approach, we must optimize before any read input data, and thus we cannot use statistics about them for the optimization of the join order. Note that there are more sophisticated join ordering optimization implemented for the other approaches, which use different kinds of estimations.",
        "show visual representation": false,
        "right image": "",
        "use generated visual representation": true,
        "short description": "This transformation rule generates only binary joins.",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "            public BasicOperator getBinaryJoin(lupos.engine.operators.multiinput.join.Join oldJoin, HashMap<Class<?>, HashSet<BasicOperator>> _startNodes) {\n            \tjava.util.LinkedList<BasicOperator> oldJoinPrec = new java.util.LinkedList<BasicOperator>();\n            \toldJoinPrec.addAll(oldJoin.getPrecedingOperators());\n                java.util.Collection<BasicOperator> newOrder = this.optimizeJoinOrderAccordingToMostRestrictionsForMergeJoin(oldJoinPrec);\n                java.util.Collection<BasicOperator> remainingJoins = new java.util.LinkedList<BasicOperator>();\n                java.util.HashSet<BasicOperator> alreadyUsed = new java.util.HashSet<BasicOperator>();\n                \n                java.util.Iterator<BasicOperator> itp = newOrder.iterator();\n            \n                while(itp.hasNext()) {\n         \n                    BasicOperator first = this.getNext(itp, alreadyUsed);\n                    \n                    if(first==null)\n                    \tbreak;\n                    \n                    if(itp.hasNext()) {\n                    \tfeedAlreadyUsed(oldJoin, first.getOperatorIDTuple(oldJoin).getId(), alreadyUsed);\n                    \t\n                        BasicOperator second = this.getNext(itp, alreadyUsed);\n                        if(second==null){\n                            remainingJoins.add(first);\n                            break;\n                        }\n                        \n                        lupos.engine.operators.multiinput.join.Join newJoin = new lupos.engine.operators.multiinput.join.Join();\n                        this.addNodeToStartNodeMapNullCheck(newJoin, _startNodes);\n                            \n                        handleJoinOperand(oldJoin, first.getOperatorIDTuple(oldJoin).getId(), newJoin, 0, alreadyUsed);\n                        handleJoinOperand(oldJoin, second.getOperatorIDTuple(oldJoin).getId(), newJoin, 1, alreadyUsed);\n                            \n                        HashSet<lupos.datastructures.items.Variable> hv = new HashSet<lupos.datastructures.items.Variable>();\n                        for(BasicOperator bo: newJoin.getPrecedingOperators()){\n                        \thv.addAll(bo.getUnionVariables());\n                        }    \n                        newJoin.setUnionVariables(hv);\n            \n                        newJoin.setIntersectionVariables(new HashSet<lupos.datastructures.items.Variable>());\n                        newJoin.getIntersectionVariables().addAll(first.getUnionVariables());\n                        for(BasicOperator bo: newJoin.getPrecedingOperators()){\n                        \tnewJoin.getIntersectionVariables().retainAll(bo.getUnionVariables());\n                        }\n                        \n                        remainingJoins.add(newJoin);\n                    }\n                    else {\n                        remainingJoins.add(first);\n                    }\n                }\n            \n                while(remainingJoins.size() > 1) {\n                    // choose best combination\n                    java.util.Collection<BasicOperator> co = this.getNextJoin(remainingJoins);\n                    java.util.Iterator<BasicOperator> io = co.iterator();\n                    BasicOperator first = io.next();\n                    BasicOperator second = io.next();\n            \n                    lupos.engine.operators.multiinput.join.Join join = new lupos.engine.operators.multiinput.join.Join();\n                    this.addNodeToStartNodeMapNullCheck(join, _startNodes);\n                    \n                    if(first instanceof lupos.engine.operators.multiinput.join.Join && second instanceof lupos.engine.operators.multiinput.join.Join){        \t        \n    \t                first.setSucceedingOperator(new OperatorIDTuple(join, 0));\t    \t        \n    \t                join.addPrecedingOperator(first);\n                    } else {\n                    \tif(first instanceof lupos.engine.operators.multiinput.join.Join){\n                    \t\tBasicOperator tmp = first;\n                    \t\tfirst = second;\n                    \t\tsecond = tmp;\n                    \t}\n                    \t// second is now a join and first something else...\n                        handleJoinOperand(oldJoin, first.getOperatorIDTuple(oldJoin).getId(), join, 0, alreadyUsed);                \t\n                    }\n                    \n                    second.setSucceedingOperator(new OperatorIDTuple(join, 1));    \t        \n                    join.addPrecedingOperator(second);\n                    \n                    HashSet<lupos.datastructures.items.Variable> hv = new HashSet<lupos.datastructures.items.Variable>();\n                    for(BasicOperator bo: join.getPrecedingOperators()){\n                    \thv.addAll(bo.getUnionVariables());\n                    }    \n                    join.setUnionVariables(hv);\n        \n                    join.setIntersectionVariables(new HashSet<lupos.datastructures.items.Variable>());\n                    join.getIntersectionVariables().addAll(first.getUnionVariables());\n                    for(BasicOperator bo: join.getPrecedingOperators()){\n                    \tjoin.getIntersectionVariables().retainAll(bo.getUnionVariables());\n                    }\n            \n                    remainingJoins.remove(first);\n                    remainingJoins.remove(second);\n                    remainingJoins.add(join);\n                }\n            \n                return remainingJoins.iterator().next();\n            }\n            \n            private void feedAlreadyUsed(lupos.engine.operators.multiinput.join.Join oldJoin, int oldOperandID, java.util.HashSet<BasicOperator> alreadyUsed){\n            \tfor(BasicOperator bo: oldJoin.getPrecedingOperators()){\n            \t\tOperatorIDTuple opID=bo.getOperatorIDTuple(oldJoin);\n            \t\tif(opID!=null && opID.getId()==oldOperandID){\n            \t\t\talreadyUsed.add(bo);\n            \t\t}\n            \t}        \t\n            }\n            \n            private void handleJoinOperand(lupos.engine.operators.multiinput.join.Join oldJoin, int oldOperandID, lupos.engine.operators.multiinput.join.Join newJoin, int newOperandID, java.util.HashSet<BasicOperator> alreadyUsed){\n            \tjava.util.LinkedList<lupos.engine.operators.BasicOperator> tmp = new java.util.LinkedList<lupos.engine.operators.BasicOperator>();\n            \ttmp.addAll(oldJoin.getPrecedingOperators());\n            \tfor(BasicOperator bo: tmp){\n            \t\tOperatorIDTuple opID=bo.getOperatorIDTuple(oldJoin);\n            \t\tif(opID!=null && opID.getId()==oldOperandID){\n            \t\t\talreadyUsed.add(bo);\n            \t\t\tbo.replaceOperatorIDTuple(opID, new OperatorIDTuple(newJoin, newOperandID));\n            \t\t\tnewJoin.addPrecedingOperator(bo);\n            \t\t}\n            \t}\n            }\n            \n        private BasicOperator getNext(java.util.Iterator<BasicOperator> itp, java.util.HashSet<BasicOperator> alreadyUsed){\n                    BasicOperator first = itp.next();\n                    while(itp.hasNext() && alreadyUsed.contains(first)){\n                    \tfirst = itp.next();\n                    }\n                    \n                    if(alreadyUsed.contains(first))\n                    \treturn null;\n                    \n                    alreadyUsed.add(first);\n                    \n                    return first;\n        }\n    \n    private java.util.Collection<BasicOperator> optimizeJoinOrderAccordingToMostRestrictionsForMergeJoin(List<BasicOperator> remaining) {\n        java.util.Collection<BasicOperator> newOrder = new java.util.LinkedList<BasicOperator>();\n    \n        while(remaining.size() > 1) {\n            BasicOperator best1 = null;\n            BasicOperator best2 = null;\n            int minOpenPositions = 4;\n    \n            for(BasicOperator bo1 : remaining) {\n                for(BasicOperator bo2 : remaining) {\n                    if(!bo1.equals(bo2)) {\n                        java.util.Collection<lupos.datastructures.items.Variable> v = new java.util.LinkedList<lupos.datastructures.items.Variable>(); \n                        v.addAll(bo1.getUnionVariables());\n                        v.retainAll(bo2.getUnionVariables());\n    \n                        int openPositions = bo1.getUnionVariables().size() - v.size();\n    \n                        if(openPositions < minOpenPositions) {\n                            minOpenPositions = openPositions;\n                            best1 = bo1;\n                            best2 = bo2;\n                        }\n                    }\n                }\n            }\n    \n            newOrder.add(best1);\n            newOrder.add(best2);\n    \n            remaining.remove(best1);\n            remaining.remove(best2);\n        }\n    \n        if(remaining.size() == 1) {\n            for(BasicOperator bo1 : remaining) {\n                newOrder.add(bo1);\n            }\n        }\n    \n        return newOrder;\n    }\n    \n    private java.util.Collection<BasicOperator> getNextJoin(java.util.Collection<BasicOperator> remainingJoins) {\n        java.util.Collection<BasicOperator> co = new java.util.LinkedList<BasicOperator>();\n        BasicOperator best1 = null;\n        BasicOperator best2 = null;\n        int minCommonVariables = -1;\n    \n        for(BasicOperator o1 : remainingJoins) {\n            for(BasicOperator o2 : remainingJoins) {\n                if(!o1.equals(o2)) {\n                    java.util.Collection<lupos.datastructures.items.Variable> v = new java.util.LinkedList<lupos.datastructures.items.Variable>();\n                    v.addAll(o1.getUnionVariables());\n                    v.retainAll(o2.getUnionVariables());\n    \n                    int commonVariables = v.size();\n    \n                    if(commonVariables > minCommonVariables) {\n                        minCommonVariables = commonVariables;\n                        best1 = o1;\n                        best2 = o2;\n                    }\n                }\n            }\n        }\n    \n        co.add(best1);\n        co.add(best2);\n    \n        return co;\n    }\n",
        "replace method": {
          "code": "BasicOperator finalJoin = this.getBinaryJoin(this.join, _startNodes);\nfinalJoin.setSucceedingOperators(this.join.getSucceedingOperators());\n\nfor(OperatorIDTuple opIDt : finalJoin.getSucceedingOperators()) {\n    opIDt.getOperator().removePrecedingOperator(this.join);\n    opIDt.getOperator().addPrecedingOperator(finalJoin);\n}\n\nthis.deleteNodeFromStartNodeMapNullCheck(this.join, _startNodes);",
          "additional code": "",
          "use generated code": false
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "if(this.join instanceof lupos.engine.operators.multiinput.optional.parallel.ParallelOptional || this.join instanceof lupos.engine.operators.multiinput.optional.parallel.MergeParallelOptional) {\n    return false;\n}\n\nreturn (this.join.getNumberOfOperands() > 2);",
          "use generated code": true
        }
      }
    },
    "Construct To Generate": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {},
        "left side": {
          "c": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Construct",
            "position": [
              5,
              5
            ]
          },
          "t": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "TriplePattern",
            "position": [
              5,
              269
            ]
          },
          "connections": {"c": [{
            "mode": "ONLY_SUCCEEDING",
            "active": false,
            "id label": "",
            "to": "t",
            "id": -1
          }]}
        }
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": []
        },
        "long description": "",
        "show visual representation": false,
        "right image": "",
        "use generated visual representation": true,
        "short description": "If a Construct has only a Triple Pattern as succeeding operator, we can transform the Construct into Generate operators (for each triple pattern template in the Construct, one Generate operator).",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "",
        "replace method": {
          "code": "for(lupos.engine.operators.tripleoperator.TriplePattern tp : this.c.getTemplates()) {\n    lupos.engine.operators.singleinput.generate.Generate generate = new lupos.engine.operators.singleinput.generate.Generate(this.t, tp.getItems());\n    generate.setPrecedingOperators(new java.util.ArrayList<lupos.engine.operators.BasicOperator>(this.c.getPrecedingOperators()));\n\n    this.addNodeToStartNodeMapNullCheck(generate, _startNodes);\n\n    for(lupos.engine.operators.BasicOperator prec : generate.getPrecedingOperators()) {\n        prec.addSucceedingOperator(generate);\n    }\n\n    this.t.addPrecedingOperator(generate);\n}\n\nfor (final OperatorIDTuple oidtuple : this.c.getSucceedingOperators()) {\n    oidtuple.getOperator().removePrecedingOperator(this.c);\n}\nfor (final BasicOperator prec : this.c.getPrecedingOperators()) {\n    prec.removeSucceedingOperator(this.c);\n}\nthis.deleteNodeFromStartNodeMapNullCheck(this.c, _startNodes);\n",
          "additional code": "",
          "use generated code": false
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "",
          "use generated code": true
        }
      }
    },
    "Factor out OR in Filter": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "op": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              57,
              5
            ]
          },
          "u": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Union",
            "position": [
              644,
              926
            ]
          },
          "f": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              83,
              698
            ]
          },
          "i": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Index",
            "position": [
              109,
              236
            ]
          },
          "j": {
            "op type": "JumpOverOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              31,
              467
            ],
            "conditions": "",
            "cardinality": "*"
          },
          "f2": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              1238,
              691
            ]
          },
          "connections": {
            "op": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "i",
              "id": -1
            }],
            "u": [{
              "mode": "ONLY_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "o",
              "id": -1
            }],
            "f": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "u",
              "id": -1
            }],
            "i": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "j",
              "id": -1
            }],
            "j": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "f",
              "id": -1
            }],
            "f2": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "u",
              "id": -1
            }]
          },
          "o": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              646,
              1155
            ]
          }
        },
        "left side": {
          "op": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              57,
              5
            ]
          },
          "f": {
            "start node": true,
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              68,
              807
            ]
          },
          "i": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Index",
            "position": [
              68,
              269
            ]
          },
          "j": {
            "op type": "JumpOverOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              16,
              533
            ],
            "conditions": "",
            "cardinality": "*"
          },
          "connections": {
            "op": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "i",
              "id": -1
            }],
            "f": [{
              "mode": "ONLY_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "o",
              "id": -1
            }],
            "i": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "j",
              "id": -1
            }],
            "j": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "f",
              "id": -1
            }]
          },
          "o": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              46,
              1071
            ]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": [
            "Variable Propagation",
            "Constant Propagation of Filter in Index With Additional Operators Between",
            "ConstantPropagation of Filter in Index"
          ],
          "rule packages": []
        },
        "long description": "If there Filter expressions with a equal-comparision of a variable with a set of constant values, e.g. Filter(?X=&lt;http://myURL.de&gt; || ?X=\"hello\" || ?X=\"myContent\"^^myURL:myDatatype), then this constant values can be propagated to preceding (RDF3X/Hexastore) Index operators in certain cases. Afterwards, the corresponding variable (here ?X) must be bound with the constant values (here &lt;http://myURL.de&gt;, \"hello\" and \"myContent\"^^myURL:myDatatype), e.g. ?Y ?Z ?X. Filter(?X=&lt;http://myURL.de&gt; || ?X=\"hello\" || ?X=\"myContent\"^^myURL:myDatatype) is transformed into {?Y ?Z &lt;http://myURL.de&gt;. AddBinding(?X=&lt;http://myURL.de&gt;)} UNION {?Y ?Z \"hello\". AddBinding(?X=\"hello\")} UNION { ?Y ?Z \"myContent\"^^myURL:myDatatype. AddBinding(?X=\"myContent\"^^myURL:myDatatype)}. However, there are problems with this approach if one of the constant values can be value-equal with another constant value using a different representation, e.g. +01^^xsd:int is value-equal, but not identical to 1^^xsd:int. Thus, this transformation rule is not applied whenever one of the constant values is a numerical value or a language tagged literal.\n\nThe following figure contains the graphical representation of the transformation rule.",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "This rule implements constant propagation for a set of constants.",
        "left image": "",
        "transition text": "c1, ..., cn are neither numerical values nor language tagged literals"
      },
      "implementation": {
        "additional import declarations": "import lupos.datastructures.items.Variable;",
        "additional global java code": "int operandID;",
        "replace method": {
          "code": "",
          "additional code": "// --- update index - begin ---\nlupos.engine.operators.index.BasicIndexScan i2 = (lupos.engine.operators.index.BasicIndexScan) this.i.clone();\nthis.addNodeToStartNodeMapNullCheck(i2, _startNodes);\n\njava.util.LinkedList<lupos.engine.operators.tripleoperator.TriplePattern> lltp = new java.util.LinkedList<lupos.engine.operators.tripleoperator.TriplePattern>();\n\nfor(lupos.engine.operators.tripleoperator.TriplePattern tp : this.i.getTriplePattern()) {\n    lltp.add(tp.clone());\n}\n\ni2.setTriplePatterns(lltp);\n\nthis.op.addSucceedingOperator(i2);\ni2.setPrecedingOperator(this.op);\n// --- update index - end ---\n\n\n// --- update filter - begin ---\nlupos.sparql1_1.Node n = this.f.getNodePointer();\n\nn = n.jjtGetChild(0);\nlupos.sparql1_1.ASTFilterConstraint node1 = new lupos.sparql1_1.ASTFilterConstraint(0);\nlupos.sparql1_1.ASTFilterConstraint node2 = new lupos.sparql1_1.ASTFilterConstraint(1);\nnode1.jjtAddChild(n.jjtGetChild(0), 0);\nnode2.jjtAddChild(n.jjtGetChild(1), 0);\nn.jjtGetChild(0).jjtSetParent(node1);\nn.jjtGetChild(1).jjtSetParent(node2);\n\nthis.f.setNodePointer(node1);\nf2.setNodePointer(node2);\n\nf2.setCollectionForExistNodes(this.f.getCollectionForExistNodes());\nf2.setEvaluator(this.f.getUsedEvaluationVisitor().getEvaluator());\nf2.getUsedEvaluationVisitor().setEvaluator(this.f.getUsedEvaluationVisitor().getEvaluator());\n\n\nf2.setIntersectionVariables(this.f.getIntersectionVariables());\nf2.setUnionVariables(this.f.getUnionVariables());\n// --- update filter - end ---\n\n\n// --- clone jump-over operators - begin ---\nBasicOperator tmpOp = this.i.getSucceedingOperators().get(0).getOperator();\nBasicOperator parentOp = i2;\n\nwhile(!tmpOp.equals(this.f)) {\n    BasicOperator newOp = tmpOp.clone();\n    this.addNodeToStartNodeMapNullCheck(newOp, _startNodes);\n\n    parentOp.setSucceedingOperator(new lupos.engine.operators.OperatorIDTuple(newOp, 0));\n    newOp.setPrecedingOperator(parentOp);\n\n    parentOp = newOp;\n    tmpOp = tmpOp.getSucceedingOperators().get(0).getOperator();\n}\n\nparentOp.setSucceedingOperator(new lupos.engine.operators.OperatorIDTuple(f2, 0));\nf2.addPrecedingOperator(parentOp);\n// --- clone jump-over operators - end ---\nu.getOperatorIDTuple(this.o).setId(this.operandID);\nu.setIntersectionVariables(new HashSet<Variable>(this.f.getIntersectionVariables()));\nu.setUnionVariables(new HashSet<Variable>(this.f.getUnionVariables()));",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "lupos.sparql1_1.Node n = this.f.getNodePointer();\n\nthis.operandID = this.f.getOperatorIDTuple(this.o).getId();\n\nif(this.i.getSucceedingOperators().size()>1)\n   return false;\n            \nif(n.jjtGetNumChildren() > 0) {\n    n = n.jjtGetChild(0);\n\n    return (n instanceof lupos.sparql1_1.ASTOrNode);\n}",
          "use generated code": true
        }
      }
    },
    "Bound In Filter under Index": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {},
        "left side": {
          "f": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              11,
              595
            ]
          },
          "i": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Index",
            "position": [
              5,
              5
            ]
          },
          "f2": {
            "op type": "JumpOverOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              0,
              287
            ],
            "conditions": "",
            "cardinality": "*"
          },
          "connections": {
            "f": [{
              "mode": "ALL_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "o",
              "id": -1
            }],
            "i": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "f2",
              "id": -1
            }],
            "f2": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "f",
              "id": -1
            }]
          },
          "o": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              0,
              887
            ]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": []
        },
        "long description": "",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "private boolean deleteAll;",
        "replace method": {
          "code": "this.f.removeFromOperatorGraph();\r\nif(this.deleteAll){\r\n    this.i.removeFromOperatorGraphWithoutConnectingPrecedingWithSucceedingOperators();\r\n    this.deleteNodeFromStartNodeMapNullCheck(this.i, _startNodes);\r\n    for(lupos.engine.operators.BasicOperator child : this.o) {\r\n        this.deleteOperatorWithoutParentsRecursive(child, _startNodes);\r\n    }\r\n}",
          "additional code": "",
          "use generated code": false
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "lupos.sparql1_1.Node n = this.f.getNodePointer();\r\n\r\nboolean negated = false;\r\n\r\nif(n.jjtGetNumChildren() > 0) {\r\n    n = n.jjtGetChild(0);\r\n\r\n    while(n instanceof lupos.sparql1_1.ASTNotNode){\r\n        negated = !negated;\r\n    n = n.jjtGetChild(0);\r\n    }\r\n    if(n instanceof lupos.sparql1_1.ASTBoundFuncNode){\r\n        n = n.jjtGetChild(0);\r\n        if(n instanceof lupos.sparql1_1.ASTVar) {\r\n            lupos.datastructures.items.Variable var = new lupos.datastructures.items.Variable(((lupos.sparql1_1.ASTVar) n).getName());\r\n            this.deleteAll = (this.i.getVarsInTriplePatterns().contains(var)) == negated;\r\n            return true;\r\n        }\r\n    }\r\n}\r\nreturn false;",
          "use generated code": true
        }
      }
    },
    "Bound in Filter Under Add": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "a": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "AddBinding",
            "position": [
              5,
              5
            ]
          },
          "connections": {"a": [{
            "mode": "ALL_SUCCEEDING",
            "active": true,
            "id label": "o_id",
            "to": "o",
            "id": -1
          }]},
          "o": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              5,
              235
            ]
          }
        },
        "left side": {
          "a": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "AddBinding",
            "position": [
              5,
              5
            ]
          },
          "f": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              5,
              276
            ]
          },
          "connections": {
            "a": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "f",
              "id": -1
            }],
            "f": [{
              "mode": "ALL_SUCCEEDING",
              "active": true,
              "id label": "o_id",
              "to": "o",
              "id": -1
            }]
          },
          "o": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              5,
              547
            ]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": []
        },
        "long description": "",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "private boolean deleteAll = false;",
        "replace method": {
          "code": "",
          "additional code": "if(this.deleteAll){\r\n  this.deleteOperatorWithParentsAndChildren(this.a ,_startNodes);\r\n}",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "lupos.sparql1_1.Node n = this.f.getNodePointer();\r\n\r\nboolean negated = false;\r\n\r\nif(n.jjtGetNumChildren() > 0) {\r\n    n = n.jjtGetChild(0);\r\n\r\n    while(n instanceof lupos.sparql1_1.ASTNotNode){\r\n        negated = !negated;\r\n    n = n.jjtGetChild(0);\r\n    }\r\n    if(n instanceof lupos.sparql1_1.ASTBoundFuncNode){\r\n        n = n.jjtGetChild(0);\r\n        if(n instanceof lupos.sparql1_1.ASTVar) {\r\n            lupos.datastructures.items.Variable var = new lupos.datastructures.items.Variable(((lupos.sparql1_1.ASTVar) n).getName());\r\n      this.deleteAll = negated;\r\n            return var.equals(this.a.getVar());\r\n        }\r\n    }\r\n}\r\nreturn false;",
          "use generated code": true
        }
      }
    },
    "Remove Empty Index": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {"o": {
          "op type": "RuleOperator",
          "also subclasses": false,
          "class type": "Operator",
          "position": [
            18,
            20
          ]
        }},
        "left side": {
          "i": {
            "start node": true,
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Index",
            "position": [
              35,
              278
            ]
          },
          "connections": {"o": [{
            "mode": "ONLY_PRECEDING",
            "active": false,
            "id label": "",
            "to": "i",
            "id": -1
          }]},
          "o": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              26,
              18
            ]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": []
        },
        "long description": "",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "This transformation rule checks an index scan operator for empty result. In case of empty result, the index scan operator is removed, which can lead to an enormous simplification of the operator graph.",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "",
        "replace method": {
          "code": "",
          "additional code": "",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "if(this.i instanceof lupos.rif.operator.PredicateIndexScan\n    || this.i instanceof lupos.rif.operator.BooleanIndexScan\n    || this.i instanceof lupos.rif.operator.IteratorIndexScan\n    || (!this.i.getPrecedingOperators().isEmpty()\n        && !this.i.getPrecedingOperators().get(0).getSucceedingOperators().isEmpty()\n        && this.i.getPrecedingOperators().get(0).getSucceedingOperators().get(0).getOperator() instanceof lupos.rif.operator.InsertTripleIndexScan)) {\n\t\t\t\t\treturn false;\n}\n\nlupos.datastructures.queryresult.QueryResult qr = null;\n\t\t\t\tif (this.i instanceof lupos.engine.operators.index.memoryindex.MemoryIndexScan) {\n\t\t\t\t\tfinal lupos.engine.operators.index.memoryindex.MemoryIndexScan temp = new lupos.engine.operators.index.memoryindex.MemoryIndexScan(this.i.getRoot());\n            \t\t\t\t\ttemp.setBindingsFactory(this.i.getBindingsFactory());\n\t\t\t\t\tboolean found = false;\n\t\t\t\t\tfor (lupos.engine.operators.tripleoperator.TriplePattern pat : ((lupos.engine.operators.index.memoryindex.MemoryIndexScan) this.i).getTriplePattern()) {\n\t\t\t\t\t\ttemp.setTriplePatterns(java.util.Arrays.asList(pat));\n\t\t\t\t\t\tlupos.datastructures.queryresult.QueryResult qrtemp = temp.join(this.i.getRoot().dataset);\n\t\t\t\t\t\tif (qrtemp != null && qrtemp.oneTimeIterator().hasNext()) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!found) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n                    return false;\n\t\t\t\t} else {\n\t\t\t\t\tqr = this.i.join(this.i.getRoot().dataset);\n                }\n\t\t\t\tif (qr != null) {\n\t\t\t\t\tfinal java.util.Iterator<lupos.datastructures.bindings.Bindings> pib = qr.oneTimeIterator();\n\t\t\t\t\tif (pib.hasNext()) {\n\t\t\t\t\t\tif (pib instanceof lupos.datastructures.queryresult.ParallelIterator) {\n\t\t\t\t\t\t\t((lupos.datastructures.queryresult.ParallelIterator) pib).close();\n                        }\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (pib instanceof lupos.datastructures.queryresult.ParallelIterator) {\n\t\t\t\t\t\t((lupos.datastructures.queryresult.ParallelIterator) pib).close();\n                    }\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\treturn true;\n\t\t\t\t}",
          "use generated code": true
        }
      }
    },
    "Replace Generate Pat": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {},
        "left side": {
          "t": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "TriplePattern",
            "position": [
              5,
              269
            ]
          },
          "g": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Generate",
            "position": [
              5,
              5
            ]
          },
          "connections": {"g": [{
            "mode": "ONLY_SUCCEEDING",
            "active": false,
            "id label": "",
            "to": "t",
            "id": -1
          }]}
        }
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": []
        },
        "long description": "",
        "show visual representation": false,
        "right image": "",
        "use generated visual representation": true,
        "short description": "A generated triple is immediately consumed from a Triple Pattern. This transformation rule reduces this to the direct assignment of variables.",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "",
        "replace method": {
          "code": "final lupos.datastructures.items.Item[] patItems = this.t.getItems();\n\t\tfinal lupos.datastructures.items.Item[] generateItems = this.g.getValueOrVariable();\n\n\t\tlupos.engine.operators.singleinput.Filter filter = null;\n\t\tfinal lupos.engine.operators.singleinput.ReplaceVar replaceVar = new lupos.engine.operators.singleinput.ReplaceVar();\n\t\treplaceVar.setIntersectionVariables(new java.util.HashSet<lupos.datastructures.items.Variable>());\n\t\treplaceVar.setUnionVariables(replaceVar.getIntersectionVariables());\n\n\t\tfinal java.util.LinkedList<lupos.datastructures.items.Variable> addBindingsVar = new java.util.LinkedList<lupos.datastructures.items.Variable>();\n\t\tfinal java.util.LinkedList<lupos.datastructures.items.literal.Literal> addBindingsLit = new java.util.LinkedList<lupos.datastructures.items.literal.Literal>();\n\n\t\tString filterConstraint = \"Filter( \";\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfinal lupos.datastructures.items.Item patItem = patItems[i];\n\t\t\tfinal lupos.datastructures.items.Item generateItem = generateItems[i];\n\t\t\tif ((!patItem.isVariable()) && generateItem.isVariable()) {\n\t\t\t\tfilterConstraint += generateItems[i].toString() + \" = \"\n\t\t\t\t\t\t+ patItems[i].toString() + \" && \";\n\t\t\t} else if (patItem.isVariable() && generateItem.isVariable()) {\n\t\t\t\treplaceVar.addSubstitution((lupos.datastructures.items.Variable) patItem,\n\t\t\t\t\t\t(lupos.datastructures.items.Variable) generateItem);\n\t\t\t\treplaceVar.getIntersectionVariables().add((lupos.datastructures.items.Variable) patItem);\n\t\t\t} else if (patItem.isVariable() && (!generateItem.isVariable())) {\n\t\t\t\taddBindingsVar.add((lupos.datastructures.items.Variable) patItem);\n\t\t\t\taddBindingsLit.add((lupos.datastructures.items.literal.Literal) generateItem);\n\t\t\t} else if (!patItem.isVariable() && !generateItem.isVariable()\n\t\t\t\t\t&& !generateItem.equals(patItem)) {\n\t\t\t\t// cannot match, remove generate.\n\t\t\t\tfor (final BasicOperator parent : this.g.getPrecedingOperators())\n\t\t\t\t\tparent.removeSucceedingOperator(this.g);\n\t\t\t\tthis.g.getPrecedingOperators().clear();\n\t\t\t\tthis.g.removeFromOperatorGraph();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// If (?x = ?a) and (?x = ?b) then (valueOf(?a) = value(?b)) must be\n\t\t// fulfilled\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tfor (int x = i + 1; x < 3; x++) {\n\t\t\t\tif (patItems[i].equals(patItems[x])) {\n\t\t\t\t\tfilterConstraint += generateItems[i].toString() + \" = \"\n\t\t\t\t\t\t\t+ generateItems[x].toString() + \" && \";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!filterConstraint.equals(\"Filter( \")) {\n\t\t\tfilterConstraint = filterConstraint.substring(0,\n\t\t\t\t\tfilterConstraint.length() - 3)\n\t\t\t\t\t+ \") \";\n\n\t\t\ttry {\n\t\t\t\tfinal lupos.sparql1_1.ASTFilterConstraint ASTfilter = (lupos.sparql1_1.ASTFilterConstraint) lupos.sparql1_1.SPARQL1_1Parser\n\t\t\t\t\t\t.parseFilter(filterConstraint);\n\t\t\t\tfilter = new lupos.engine.operators.singleinput.Filter(ASTfilter);\n\t\t\t} catch (final Exception e) {\n\t\t\t\tSystem.err\n\t\t\t\t\t\t.println(\"This should never happen in RuleReplaceGenPat!\");\n\t\t\t\tSystem.err.println(e);\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\t// Only Operators with a not empty definition are put into the\n\t\t// operatorgraph\n\t\tfinal java.util.LinkedList<BasicOperator> order = new java.util.LinkedList<BasicOperator>();\n\t\tif (filter != null) {\n\t\t\torder.add(filter);\n\t\t}\n\n\t\tfinal int substVar = replaceVar.getSubstitutionsVariableLeft().size();\n\n\t\tif (substVar > 0) {\n\t\t\torder.add(replaceVar);\n\t\t} else {\n\t\t\tfinal lupos.engine.operators.singleinput.Projection p = new lupos.engine.operators.singleinput.Projection();\n\t\t\tp.setIntersectionVariables(new java.util.HashSet<lupos.datastructures.items.Variable>());\n\t\t\tp.setUnionVariables(p.getUnionVariables());\n\t\t\torder.add(p);\n\t\t}\n\t\tif (addBindingsVar.size() > 0) {\n\t\t\tfinal java.util.Iterator<lupos.datastructures.items.literal.Literal> lit_it = addBindingsLit.iterator();\n\t\t\tfinal java.util.HashSet<lupos.datastructures.items.Variable> hsv = new java.util.HashSet<lupos.datastructures.items.Variable>();\n\t\t\thsv.addAll(replaceVar.getUnionVariables());\n\t\t\tfor (final lupos.datastructures.items.Variable v : addBindingsVar) {\n\t\t\t\tfinal lupos.engine.operators.singleinput.AddBinding ab = new lupos.engine.operators.singleinput.AddBinding(v, lit_it.next());\n\t\t\t\thsv.add(v);\n\t\t\t\tab.setIntersectionVariables((java.util.HashSet<lupos.datastructures.items.Variable>) hsv.clone());\n\t\t\t\tab.setUnionVariables(ab.getIntersectionVariables());\n\t\t\t\torder.add(ab);\n\t\t\t}\n\t\t}\n\n\t\t// In case that Generate or TriplePattern has minimum one variable, than\n\t\t// minimum one operator has to be inserted\n\t\tif (order.size() > 0) {\n\t\t\tfinal java.util.List<BasicOperator> pres = (java.util.List<BasicOperator>) this.g.getPrecedingOperators();\n\t\t\tBasicOperator pre;\n\t\t\tfor (int i = 0; i < pres.size(); i++) {\n\t\t\t\tpre = pres.get(i);\n\t\t\t\tpre.addSucceedingOperator(new OperatorIDTuple(order.getFirst(),\n\t\t\t\t\t\t0));\n\t\t\t\tif (filter != null) {\n\t\t\t\t\tjava.util.Collection<lupos.datastructures.items.Variable> vars = filter\n\t\t\t\t\t\t\t.getIntersectionVariables();\n\t\t\t\t\tif (vars == null)\n\t\t\t\t\t\tvars = new java.util.HashSet<lupos.datastructures.items.Variable>();\n\t\t\t\t\tvars.addAll(pre.getIntersectionVariables());\n\t\t\t\t\tfilter.setIntersectionVariables(vars);\n\t\t\t\t\tfilter.setUnionVariables(vars);\n\t\t\t\t}\n\t\t\t\tpre.removeSucceedingOperator(this.g);\n\t\t\t\torder.getFirst().addPrecedingOperator(pre);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < order.size() - 1; i++) {\n\t\t\t\torder.get(i + 1).setPrecedingOperator(order.get(i));\n\t\t\t\torder.get(i).setSucceedingOperator(\n\t\t\t\t\t\tnew OperatorIDTuple(order.get(i + 1), 0));\n\t\t\t}\n\n\t\t\tfinal java.util.LinkedList<OperatorIDTuple> succs = (java.util.LinkedList<OperatorIDTuple>) this.t.getSucceedingOperators();\n\t\t\tfor (int i = 0; i < succs.size(); i++) {\n\t\t\t\tsuccs.get(i).getOperator()\n\t\t\t\t\t\t.addPrecedingOperator(order.getLast());\n\t\t\t}\n\n\t\t\tfinal java.util.LinkedList<OperatorIDTuple> sops = new java.util.LinkedList<OperatorIDTuple>();\n\t\t\tsops.addAll(this.t.getSucceedingOperators());\n\t\t\torder.getLast().setSucceedingOperators(sops);\n\t\t} else {\n\t\t\tfinal java.util.LinkedList<BasicOperator> pres = (java.util.LinkedList<BasicOperator>) this.g.getPrecedingOperators();\n\t\t\tfinal java.util.LinkedList<OperatorIDTuple> succs = (java.util.LinkedList<OperatorIDTuple>) this.t.getSucceedingOperators();\n\t\t\tBasicOperator pre;\n\t\t\tBasicOperator succ;\n\t\t\tfor (int i = 0; i < pres.size(); i++) {\n\t\t\t\tpre = pres.get(i);\n\t\t\t\tpre.removeSucceedingOperator(this.g);\n\t\t\t\tfor (int x = 0; x < succs.size(); x++) {\n\t\t\t\t\tpre.addSucceedingOperator(succs.get(x));\n\t\t\t\t\tsucc = succs.get(x).getOperator();\n\t\t\t\t\tsucc.removePrecedingOperator(this.t);\n\t\t\t\t\tsucc.addPrecedingOperator(pre);\n\t\t\t\t}\n\t\t\t}\n\t\t}",
          "additional code": "",
          "use generated code": false
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "",
          "use generated code": true
        }
      }
    },
    "Bound Variable in Optional": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "o1": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              2,
              21
            ]
          },
          "opt": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Optional",
            "position": [
              769,
              992
            ]
          },
          "o2": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              891,
              21
            ]
          },
          "f": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              292,
              762
            ]
          },
          "j": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Join",
            "position": [
              290,
              292
            ]
          },
          "jump_filter": {
            "op type": "JumpOverOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              291,
              524
            ],
            "conditions": "",
            "cardinality": "*"
          },
          "connections": {
            "o1": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "j",
              "id": -1
            }],
            "o2": [
              {
                "mode": "EXISTS",
                "active": true,
                "id label": "",
                "to": "opt",
                "id": 0
              },
              {
                "mode": "EXISTS",
                "active": false,
                "id label": "",
                "to": "j",
                "id": -1
              }
            ],
            "f": [{
              "mode": "EXISTS",
              "active": true,
              "id label": "",
              "to": "opt",
              "id": 1
            }],
            "j": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "jump_filter",
              "id": -1
            }],
            "jump_filter": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "f",
              "id": -1
            }]
          }
        },
        "left side": {
          "o1": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              43,
              19
            ]
          },
          "opt": {
            "start node": true,
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Optional",
            "position": [
              498,
              820
            ]
          },
          "o2": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              526,
              17
            ]
          },
          "f": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              43,
              555
            ]
          },
          "jump_filter": {
            "op type": "JumpOverOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              2,
              282
            ],
            "conditions": "",
            "cardinality": "*"
          },
          "connections": {
            "o1": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "jump_filter",
              "id": -1
            }],
            "o2": [{
              "mode": "ONLY_SUCCEEDING",
              "active": true,
              "id label": "",
              "to": "opt",
              "id": 0
            }],
            "f": [{
              "mode": "EXISTS",
              "active": true,
              "id label": "",
              "to": "opt",
              "id": 1
            }],
            "jump_filter": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "f",
              "id": -1
            }]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": ["Bound Variable in Union"],
          "rule packages": []
        },
        "long description": "This rule avoids failures in SPARQL queries like <span style=\"font-family:monospace;\">{ ?X ?Y ?Z. Optional { ?X2 ?Y2 ?Z2. Filter(?X=?X2).} }<\/span>\n\nLet P1 = ?X ?Y ?Z. and P2 = ?X2 ?Y2 ?Z2. If we do not correct the operator graph after generating the operator graph from the abstract syntax tree, then the Filter-expression is evaluated on results of P2, which is every time false (as ?X is not bound). Thus, we have to correct the operator graph and first join P1 and P2 before the evaluation of the filter expression.We display the graphical representation of the general transformation rule in the below given figure:",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "This rule corrects the operator graph after its generation from the abstract syntax tree, especially for the case that variables are used in filter expressions, which are bound outside of the OPTIONAL-clause.",
        "left image": "",
        "transition text": "?X is not necessarily bound in results of O1, but can be bound in results of O2"
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "",
        "replace method": {
          "code": "",
          "additional code": "this.o1.getOperatorIDTuple(j).setId(0);\nthis.o2.getOperatorIDTuple(j).setId(1);\n\nHashSet<lupos.datastructures.items.Variable> intersectionVariables = new HashSet<lupos.datastructures.items.Variable>();\nintersectionVariables.addAll(this.o1.getUnionVariables());\nintersectionVariables.retainAll(this.o2.getUnionVariables());\n\nHashSet<lupos.datastructures.items.Variable> unionVariables = new HashSet<lupos.datastructures.items.Variable>();\nunionVariables.addAll(this.o1.getUnionVariables());\nunionVariables.addAll(this.o2.getUnionVariables());\n\nBasicOperator tmpOp = j;\n\nwhile(!tmpOp.equals(this.opt)) {\n    tmpOp.setUnionVariables(unionVariables);\n    tmpOp.setIntersectionVariables(intersectionVariables);\n\n    tmpOp = tmpOp.getSucceedingOperators().get(0).getOperator();\n}\n\nthis.opt.setUnionVariables(unionVariables);\nthis.opt.setIntersectionVariables(intersectionVariables);",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "if(this.o1 instanceof lupos.engine.operators.multiinput.join.Join && this.o1.getPrecedingOperators().contains(this.o2)) {\n    return false;\n}\n\nlupos.engine.operators.singleinput.Filter filterOutestFilter = this.f;\njava.util.Collection<lupos.datastructures.items.Variable> variablesInnerUnion = this.o1.getIntersectionVariables();\njava.util.Collection<lupos.datastructures.items.Variable> variablesOuterUnion = this.o2.getUnionVariables();\nboolean checkFurther = true;\n\nwhile(checkFurther) {\n    if(!variablesInnerUnion.containsAll(filterOutestFilter.getUsedVariables())) {\n        for(lupos.datastructures.items.Variable v : filterOutestFilter.getUsedVariables()) {\n            if(!variablesInnerUnion.contains(v) && variablesOuterUnion.contains(v)) {\n                return true;\n            }\n        }\n    }\n\n    BasicOperator nextOp = filterOutestFilter.getPrecedingOperators().get(0);\n\n    if(nextOp.equals(this.o1)) {\n        checkFurther = false;\n    }\n    else {\n        filterOutestFilter = (lupos.engine.operators.singleinput.Filter) nextOp;\n    }\n}\nreturn false;",
          "use generated code": true
        }
      }
    },
    "Split Generate": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "g_new": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Generate",
            "position": [
              5,
              236
            ]
          },
          "o1": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              5,
              5
            ]
          },
          "t": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "TriplePattern",
            "position": [
              5,
              467
            ]
          },
          "connections": {
            "g_new": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "t",
              "id": -1
            }],
            "o1": [{
              "mode": "ALL_SUCCEEDING",
              "active": true,
              "id label": "a",
              "to": "g_new",
              "id": -1
            }]
          }
        },
        "left side": {
          "o1": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              5,
              5
            ]
          },
          "t": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "TriplePattern",
            "position": [
              5,
              533
            ]
          },
          "g": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Generate",
            "position": [
              5,
              269
            ]
          },
          "connections": {
            "o1": [{
              "mode": "ONLY_PRECEDING",
              "active": false,
              "id label": "",
              "to": "g",
              "id": -1
            }],
            "g": [{
              "mode": "ALL_SUCCEEDING",
              "active": true,
              "id label": "a",
              "to": "t",
              "id": -1
            }]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": []
        },
        "long description": "",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "Creation of one Generate for each of its predecessors, which simplifies further optimizations.",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "",
        "replace method": {
          "code": "",
          "additional code": "for(lupos.engine.operators.singleinput.generate.Generate tmp_g : g_new) {\n    tmp_g.setValueOrVariable(this.g.getValueOrVariable());\n}",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "return this.g.getSucceedingOperators().size() > 1;",
          "use generated code": true
        }
      }
    },
    "Unnecessary Optional Because of Projection": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "p": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Projection",
            "position": [
              62,
              327
            ]
          },
          "o0": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              63,
              45
            ]
          },
          "connections": {"o0": [{
            "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
            "active": false,
            "id label": "",
            "to": "p",
            "id": -1
          }]}
        },
        "left side": {
          "p": {
            "start node": true,
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Projection",
            "position": [
              263,
              792
            ]
          },
          "o0": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              0,
              35
            ]
          },
          "o1": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              571,
              32
            ]
          },
          "opt": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Optional",
            "position": [
              253,
              456
            ]
          },
          "connections": {
            "o0": [{
              "mode": "ONLY_SUCCEEDING",
              "active": true,
              "id label": "",
              "to": "opt",
              "id": 0
            }],
            "o1": [{
              "mode": "ONLY_SUCCEEDING",
              "active": true,
              "id label": "",
              "to": "opt",
              "id": 1
            }],
            "opt": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "p",
              "id": -1
            }]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": []
        },
        "long description": "",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "",
        "replace method": {
          "code": "",
          "additional code": "this.deleteOperatorWithParentsAndChildren(this.o1, _startNodes);",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "if(this.opt.getPrecedingOperators().size()>2){\r\n\treturn false;\r\n}\r\nif(this.o0.getUnionVariables().containsAll(this.p.getProjectedVariables())){\r\n\treturn true;\r\n} else {\r\n\treturn false;\r\n}",
          "use generated code": true
        }
      }
    },
    "Constant Propagation of Filter in Triple Pattern with Operators Between": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "b": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "AddBinding",
            "position": [
              5,
              235
            ]
          },
          "j": {
            "op type": "JumpOverOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              5,
              465
            ],
            "conditions": "",
            "cardinality": "*"
          },
          "tp": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "TriplePattern",
            "position": [
              5,
              5
            ]
          },
          "connections": {
            "b": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "j",
              "id": -1
            }],
            "j": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "o",
              "id": -1
            }],
            "tp": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "b",
              "id": -1
            }]
          },
          "o": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              5,
              695
            ]
          }
        },
        "left side": {
          "f": {
            "start node": true,
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              34,
              557
            ]
          },
          "j": {
            "op type": "JumpOverOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              5,
              276
            ],
            "conditions": "if(j instanceof lupos.engine.operators.singleinput.path.Closure) {\r\n  _continueFlag_1_0 = true;\r\n  break;\r\n}",
            "cardinality": "*"
          },
          "tp": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "TriplePattern",
            "position": [
              34,
              5
            ]
          },
          "connections": {
            "f": [{
              "mode": "ONLY_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "o",
              "id": -1
            }],
            "j": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "f",
              "id": -1
            }],
            "tp": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "j",
              "id": -1
            }]
          },
          "o": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              34,
              828
            ]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": []
        },
        "long description": "",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "This rule implements constant propagation from Filter to Triple Pattern.",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "private lupos.datastructures.items.Variable var = null;\r\nprivate lupos.datastructures.items.literal.Literal constant = null;\r\nprivate int operandIDOfFilter;",
        "replace method": {
          "code": "",
          "additional code": "this.constant = this.constant.createThisLiteralNew();\r\njava.util.Set<lupos.datastructures.items.Variable> replacedVars = this.tp.replace(this.var, this.constant);\r\nthis.tp.getIntersectionVariables().removeAll(replacedVars);\r\nthis.tp.getUnionVariables().removeAll(replacedVars);\r\n\r\nb.setVar(this.var);\r\nb.setLiteral(this.constant);\r\n\r\njava.util.LinkedList<lupos.datastructures.items.Variable> unionVars=new java.util.LinkedList<lupos.datastructures.items.Variable>(this.tp.getUnionVariables());\r\nunionVars.add(this.var);\r\njava.util.LinkedList<lupos.datastructures.items.Variable> intersectionVars=new java.util.LinkedList<lupos.datastructures.items.Variable>(unionVars);\r\n\r\nb.setUnionVariables(unionVars);\r\nb.setIntersectionVariables(intersectionVars);\r\nthis.j_end.getOperatorIDTuple(o).setId(this.operandIDOfFilter);",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "this.operandIDOfFilter = this.f.getOperatorIDTuple(o).getId();\r\n\r\nlupos.sparql1_1.Node n = this.f.getNodePointer();\r\n\r\nif(n.jjtGetNumChildren() > 0) {\r\n    n = n.jjtGetChild(0);\r\n\r\n    if(n instanceof lupos.sparql1_1.ASTEqualsNode) {\r\n        lupos.sparql1_1.Node left = n.jjtGetChild(0);\r\n        lupos.sparql1_1.Node right = n.jjtGetChild(1);\r\n\r\n        if(right instanceof lupos.sparql1_1.ASTVar) {\r\n            lupos.sparql1_1.Node tmp = left;\r\n            left = right;\r\n            right = tmp;\r\n        }\r\n\r\n        if(left instanceof lupos.sparql1_1.ASTVar) {\r\n            String varname = ((lupos.sparql1_1.ASTVar) left).getName();\r\n            this.var = new lupos.datastructures.items.Variable(varname);\r\n\r\n            if(!this.tp.getVariables().contains(this.var)){\r\n              return false;\r\n            }\r\n\r\n            if(!this.tp.getVariables().contains(this.var) && !this.tp.getVariables().contains(new lupos.datastructures.items.VariableInInferenceRule(varname))) {\r\n                // TODO: delete triple pattern as it will never have a result!\r\n                System.err.println(\"Can be optimized by extending RuleReplaceConstantOfFilterInTriplePattern: delete triple pattern with succeeding unsatisfiable filter expression!\");\r\n\r\n                return false;\r\n            }\r\n\r\n            if(right instanceof lupos.sparql1_1.ASTQName\r\n               || right instanceof lupos.sparql1_1.ASTRDFLiteral\r\n               || right instanceof lupos.sparql1_1.ASTQuotedURIRef\r\n               || right instanceof lupos.sparql1_1.ASTFloatingPoint\r\n               || right instanceof lupos.sparql1_1.ASTInteger\r\n               || right instanceof lupos.sparql1_1.ASTStringLiteral\r\n               || right instanceof lupos.sparql1_1.ASTDoubleCircumflex) {\r\n                this.constant = lupos.datastructures.items.literal.LazyLiteral.getLiteral(right);\r\n\r\n                // Is it possible to loose the information of the original string representation?\r\n                if(this.constant instanceof lupos.datastructures.items.literal.TypedLiteralOriginalContent || constant instanceof lupos.datastructures.items.literal.LanguageTaggedLiteralOriginalLanguage) {\r\n                    \treturn false;\r\n                }\r\n                else if(this.constant instanceof lupos.datastructures.items.literal.TypedLiteral) {\r\n                    if(lupos.engine.operators.singleinput.filter.expressionevaluation.Helper.isNumeric(((lupos.datastructures.items.literal.TypedLiteral) constant).getType())) {\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        return true;\r\n                    }\r\n                }\r\n                else {\r\n                    return true;\r\n                }\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\nelse {\r\n    return false;\r\n}",
          "use generated code": true
        }
      }
    },
    "ConstantPropagation of Filter in Index": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "b": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "AddBinding",
            "position": [
              5,
              235
            ]
          },
          "i": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Index",
            "position": [
              5,
              5
            ]
          },
          "connections": {
            "b": [{
              "mode": "ALL_SUCCEEDING",
              "active": true,
              "id label": "a",
              "to": "o",
              "id": -1
            }],
            "i": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "b",
              "id": -1
            }]
          },
          "o": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              5,
              465
            ]
          }
        },
        "left side": {
          "f": {
            "start node": true,
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              5,
              276
            ]
          },
          "i": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Index",
            "position": [
              5,
              5
            ]
          },
          "connections": {
            "f": [{
              "mode": "ALL_SUCCEEDING",
              "active": true,
              "id label": "a",
              "to": "o",
              "id": -1
            }],
            "i": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "f",
              "id": -1
            }]
          },
          "o": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              5,
              547
            ]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": ["Constant Propagation of Filter in Index With Additional Operators Between"],
          "rule packages": []
        },
        "long description": "If there Filter expressions with a equal-comparision of a variable with a constant value, e.g. Filter(?X=&lt;http://myURL.de&gt;), then this constant value can be propagated to preceding (RDF3X/Hexastore) Index operators. Afterwards, the corresponding variable (here ?X) must be bound with the constant value (here &lt;http://myURL.de&gt;), e.g. ?X ?Y ?Z. Filter(?X=&lt;http://myURL.de&gt;) is transformed into &lt;http://myURL.de&gt; ?Y ?Z. AddBinding(?X=&lt;http://myURL.de&gt;). However, there are problems with this approach if the constant value can be value-equal with another constant value using a different representation, e.g. +01^^xsd:int is value-equal, but not identical to 1^^xsd:int. Thus, this transformation rule is not applied whenever the constant value is a numerical value or a language tagged literal.\r\n\r\nThe following figure contains the graphical representation of the transformation rule.",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "This rule implements constant propagation from Filter to Index.",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "private lupos.datastructures.items.Variable var = null;\r\nprivate lupos.datastructures.items.literal.Literal constant = null;",
        "replace method": {
          "code": "",
          "additional code": "this.constant = this.constant.createThisLiteralNew();\r\nthis.i.replace(this.var, this.constant);\r\nthis.i.getUnionVariables().remove(this.var);\r\nthis.i.getIntersectionVariables().remove(this.var);\r\n\r\nb.setVar(this.var);\r\nb.setLiteral(this.constant);\r\n\r\njava.util.LinkedList<lupos.datastructures.items.Variable> unionVars=new java.util.LinkedList<lupos.datastructures.items.Variable>(this.i.getUnionVariables());\r\nunionVars.add(this.var);\r\njava.util.LinkedList<lupos.datastructures.items.Variable> intersectionVars=new java.util.LinkedList<lupos.datastructures.items.Variable>(unionVars);\r\n\r\nb.setUnionVariables(unionVars);\r\nb.setIntersectionVariables(intersectionVars);",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "lupos.sparql1_1.Node n = this.f.getNodePointer();\r\n\r\nif(n.jjtGetNumChildren() > 0) {\r\n    n = n.jjtGetChild(0);\r\n\r\n    if(n instanceof lupos.sparql1_1.ASTEqualsNode) {\r\n        lupos.sparql1_1.Node left = n.jjtGetChild(0);\r\n        lupos.sparql1_1.Node right = n.jjtGetChild(1);\r\n\r\n        if(right instanceof lupos.sparql1_1.ASTVar) {\r\n            lupos.sparql1_1.Node tmp = left;\r\n            left = right;\r\n            right = tmp;\r\n        }\r\n\r\n        if(left instanceof lupos.sparql1_1.ASTVar) {\r\n            this.var = new lupos.datastructures.items.Variable(((lupos.sparql1_1.ASTVar) left).getName());\r\n\r\n            if(!this.i.getVarsInTriplePatterns().contains(this.var)){\r\n              return false;\r\n            }\r\n\r\n            if(right instanceof lupos.sparql1_1.ASTQName\r\n               || right instanceof lupos.sparql1_1.ASTQuotedURIRef\r\n               || right instanceof lupos.sparql1_1.ASTFloatingPoint\r\n               || right instanceof lupos.sparql1_1.ASTInteger\r\n               || right instanceof lupos.sparql1_1.ASTStringLiteral\r\n               || right instanceof lupos.sparql1_1.ASTDoubleCircumflex\r\n       || right instanceof lupos.sparql1_1.ASTRDFLiteral) {\r\n                this.constant = lupos.datastructures.items.literal.LazyLiteral.getLiteral(right);\r\n\r\n                // Is it possible to loose the information of the original string representation?\r\n                if(this.constant instanceof lupos.datastructures.items.literal.TypedLiteralOriginalContent || this.constant instanceof lupos.datastructures.items.literal.LanguageTaggedLiteralOriginalLanguage) {\r\n                    return false;\r\n                }\r\n                else if(this.constant instanceof lupos.datastructures.items.literal.TypedLiteral) {\r\n                    if(lupos.engine.operators.singleinput.ExpressionEvaluation.Helper.isNumeric(((lupos.datastructures.items.literal.TypedLiteral) this.constant).getType())) {\r\n                        return false;\r\n                    } else {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    return true;\r\n                }\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\nelse {\r\n    return false;\r\n}",
          "use generated code": true
        }
      }
    },
    "Projection Over Sort": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "below": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              14,
              787
            ]
          },
          "above": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              17,
              5
            ]
          },
          "projection": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Projection",
            "position": [
              3,
              279
            ]
          },
          "sort": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Sort",
            "position": [
              21,
              534
            ]
          },
          "connections": {
            "above": [{
              "mode": "ALL_PRECEDING",
              "active": true,
              "id label": "a",
              "to": "projection",
              "id": -1
            }],
            "projection": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "sort",
              "id": -1
            }],
            "sort": [{
              "mode": "ALL_SUCCEEDING",
              "active": true,
              "id label": "b",
              "to": "below",
              "id": -1
            }]
          }
        },
        "left side": {
          "below": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              15,
              915
            ]
          },
          "above": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              17,
              5
            ]
          },
          "projection": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Projection",
            "position": [
              14,
              611
            ]
          },
          "sort": {
            "start node": true,
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Sort",
            "position": [
              15,
              318
            ]
          },
          "connections": {
            "above": [{
              "mode": "ALL_PRECEDING",
              "active": true,
              "id label": "a",
              "to": "sort",
              "id": -1
            }],
            "projection": [{
              "mode": "ALL_SUCCEEDING",
              "active": true,
              "id label": "b",
              "to": "below",
              "id": -1
            }],
            "sort": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "projection",
              "id": -1
            }]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": []
        },
        "long description": "",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "If the list of variables of the projection operator contains all variables of the sort criterium, then we can move the projection operator above the Sort criterium.",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "",
        "replace method": {
          "code": "",
          "additional code": "final java.util.Collection<lupos.datastructures.items.Variable> cv = new java.util.LinkedList<lupos.datastructures.items.Variable>();\r\ncv.addAll(this.projection.getProjectedVariables());\r\nthis.sort.setIntersectionVariables(cv);\r\nthis.sort.setUnionVariables(cv);",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "final java.util.Collection<lupos.datastructures.items.Variable> sortCrit = this.sort.getSortCriterium();\r\nif (sortCrit != null && this.projection.getProjectedVariables().containsAll(sortCrit))\r\n\treturn true;\r\nelse return false;",
          "use generated code": true
        }
      }
    },
    "HashSetNonBlockingDistinctWithIndexAccess": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {},
        "left side": {
          "d": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Distinct",
            "position": [
              5,
              276
            ]
          },
          "i": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Index",
            "position": [
              5,
              5
            ]
          },
          "connections": {"i": [{
            "mode": "EXISTS",
            "active": false,
            "id label": "",
            "to": "d",
            "id": -1
          }]}
        }
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": []
        },
        "long description": "",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "import lupos.engine.operators.singleinput.modifiers.distinct.HashSetNonBlockingDistinctWithIndexAccess;",
        "additional global java code": "",
        "replace method": {
          "code": "HashSetNonBlockingDistinctWithIndexAccess distinct_new = new HashSetNonBlockingDistinctWithIndexAccess(this.i);\r\nthis.d.replaceWith(distinct_new);\r\nthis.deleteNodeFromStartNodeMapNullCheck(this.d, _startNodes);\r\nthis.addNodeToStartNodeMapNullCheck(distinct_new, _startNodes);\r\ndistinct_new.setPrecedingOperators(this.d.getPrecedingOperators());\r\ndistinct_new.setSucceedingOperators(this.d.getSucceedingOperators());\r\n// now correct operandID of BasicIndexScan operand to 0 and the other to 1 (requirement of the HashSetNonBlockingDistinctWithIndexAccess-operator!)\r\nfor(BasicOperator bo: distinct_new.getPrecedingOperators()){\r\n\tint operandID = (bo instanceof lupos.engine.operators.index.BasicIndexScan)? 0: 1;\r\n\tbo.getOperatorIDTuple(distinct_new).setId(operandID);\r\n}",
          "additional code": "",
          "use generated code": false
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "// check if there is only one index scan operator\r\nif(this.d instanceof HashSetNonBlockingDistinctWithIndexAccess){\r\n\treturn false;\r\n}\r\nfor(BasicOperator prec: this.d.getPrecedingOperators()){\r\n\tif(prec instanceof lupos.engine.operators.index.BasicIndexScan){\r\n\t\tif(!prec.equals(this.i)){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n}\r\n",
          "use generated code": true
        }
      }
    },
    "Replace Filter With RuleFilter": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "o1": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              5,
              5
            ]
          },
          "o2": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              5,
              467
            ]
          },
          "rf": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "RuleFilter",
            "position": [
              5,
              236
            ]
          },
          "connections": {
            "o1": [{
              "mode": "ALL_PRECEDING",
              "active": false,
              "id label": "",
              "to": "rf",
              "id": -1
            }],
            "rf": [{
              "mode": "ALL_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "o2",
              "id": -1
            }]
          }
        },
        "left side": {
          "o1": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              5,
              5
            ]
          },
          "o2": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              5,
              533
            ]
          },
          "f": {
            "start node": true,
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              5,
              269
            ]
          },
          "connections": {
            "o1": [{
              "mode": "ALL_PRECEDING",
              "active": false,
              "id label": "",
              "to": "f",
              "id": -1
            }],
            "f": [{
              "mode": "ALL_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "o2",
              "id": -1
            }]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": []
        },
        "long description": "",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "SPARQL Filter operators are replaced by RIF Filter operators for dealing with equalities.",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "",
        "replace method": {
          "code": "",
          "additional code": "lupos.optimizations.sparql2core_sparql.SPARQLParserVisitorImplementationDumper filterDumper = new lupos.optimizations.sparql2core_sparql.SPARQLParserVisitorImplementationDumper();\n\nString equalsString = (String) filterDumper.visit((lupos.sparql1_1.ASTEqualsNode) this.f.getNodePointer().jjtGetChild(0));\n\nlupos.rif.model.Equality equality = null;\n\ntry {\n    lupos.rif.generated.syntaxtree.RIFAtomic atomic = new lupos.rif.generated.parser.RIFParser(new java.io.StringReader(equalsString.substring(1, equalsString.length() - 1))).RIFAtomic();\n    lupos.rif.visitor.ParseSyntaxTreeVisitor rifParser = new lupos.rif.visitor.ParseSyntaxTreeVisitor();\n\tequality = (lupos.rif.model.Equality) atomic.accept(rifParser, null);\n} catch(lupos.rif.generated.parser.ParseException e) {\n    e.printStackTrace();\n    return;\n}\n\nrf.setExpression(equality);\nrf.setUnionVariables(this.f.getUnionVariables());\nrf.setIntersectionVariables(this.f.getIntersectionVariables());",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "return this.f.getNodePointer().jjtGetChild(0) instanceof lupos.sparql1_1.ASTEqualsNode;",
          "use generated code": true
        }
      }
    },
    "Replace HashMapIndexJoin with HashMapIndexJoinOnLeftOperand": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "new_j": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "HashMapIndexOnLeftOperandJoin",
            "position": [
              180,
              404
            ]
          },
          "o_under": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              187,
              699
            ]
          },
          "connections": {
            "new_j": [{
              "mode": "ALL_SUCCEEDING",
              "active": true,
              "id label": "b",
              "to": "o_under",
              "id": -1
            }],
            "o": [{
              "mode": "ALL_PRECEDING",
              "active": true,
              "id label": "a",
              "to": "new_j",
              "id": -1
            }]
          },
          "o": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              174,
              110
            ]
          }
        },
        "left side": {
          "j": {
            "start node": true,
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "HashMapIndexJoin",
            "position": [
              44,
              357
            ]
          },
          "o_under": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              49,
              662
            ]
          },
          "connections": {
            "j": [{
              "mode": "ALL_SUCCEEDING",
              "active": true,
              "id label": "b",
              "to": "o_under",
              "id": -1
            }],
            "o": [{
              "mode": "ALL_PRECEDING",
              "active": true,
              "id label": "a",
              "to": "j",
              "id": -1
            }]
          },
          "o": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              42,
              88
            ]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": []
        },
        "long description": "",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "public static boolean isInCycleOrSeveralOperandsWitSameID(BasicOperator bo){\r\n  if(bo.getCycleOperands()!=null && bo.getCycleOperands().size()>0){\r\n    return true;\r\n  }\r\n HashSet<Integer> operandsIDOccurs = new HashSet<Integer>();\r\n  for(BasicOperator prec: bo.getPrecedingOperators()){\r\n  int operandsID = prec.getOperatorIDTuple(bo).getId();\r\n  if(operandsIDOccurs.contains(operandsID)){\r\n   return true;\r\n  }\r\n  operandsIDOccurs.add(operandsID);\r\n    if(ReplaceHashMapIndexJoinwithHashMapIndexJoinOnLeftOperandRule.isInCycleOrSeveralOperandsWitSameID(prec)){\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}",
        "replace method": {
          "code": "",
          "additional code": "new_j.setIntersectionVariables(this.j.getIntersectionVariables());\r\nnew_j.setUnionVariables(this.j.getUnionVariables());",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "return !(ReplaceHashMapIndexJoinwithHashMapIndexJoinOnLeftOperandRule.isInCycleOrSeveralOperandsWitSameID(this.j));",
          "use generated code": true
        }
      }
    },
    "Combine Unions": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "o1": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              10,
              18
            ]
          },
          "u2": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Union",
            "position": [
              22,
              246
            ]
          },
          "connections": {"o1": [{
            "mode": "ALL_PRECEDING",
            "active": false,
            "id label": "",
            "to": "u2",
            "id": -1
          }]}
        },
        "left side": {
          "o1": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              5,
              5
            ]
          },
          "u1": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Union",
            "position": [
              5,
              269
            ]
          },
          "u2": {
            "start node": true,
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Union",
            "position": [
              5,
              533
            ]
          },
          "connections": {
            "o1": [{
              "mode": "ALL_PRECEDING",
              "active": false,
              "id label": "",
              "to": "u1",
              "id": -1
            }],
            "u1": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "u2",
              "id": -1
            }]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": [],
          "rule packages": []
        },
        "long description": "",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "This transformtion rule combines two succeeding union operators into one in order to save the processing costs of a superfluous union operation.",
        "left image": "",
        "transition text": ""
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "",
        "replace method": {
          "code": "",
          "additional code": "int id = 0;\n        \nfor(BasicOperator precOp : this.u2.getPrecedingOperators()) {\n    precOp.getOperatorIDTuple(this.u2).setId(id++);\n}",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "",
          "use generated code": true
        }
      }
    },
    "Constant Propagation of Filter in Index With Additional Operators Between": {
      "visual representation": {
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "b": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "AddBinding",
            "position": [
              5,
              235
            ]
          },
          "i": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Index",
            "position": [
              8,
              5
            ]
          },
          "j": {
            "op type": "JumpOverOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              7,
              465
            ],
            "conditions": "",
            "cardinality": "*"
          },
          "connections": {
            "b": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "j",
              "id": -1
            }],
            "i": [{
              "mode": "EXISTS",
              "active": false,
              "id label": "",
              "to": "b",
              "id": -1
            }],
            "j": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "o",
              "id": -1
            }]
          },
          "o": {
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Operator",
            "position": [
              5,
              695
            ]
          }
        },
        "left side": {
          "f": {
            "start node": true,
            "op type": "RuleOperator",
            "also subclasses": false,
            "class type": "Filter",
            "position": [
              32,
              557
            ]
          },
          "i": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Index",
            "position": [
              33,
              5
            ]
          },
          "j": {
            "op type": "JumpOverOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              5,
              276
            ],
            "conditions": "if(j instanceof lupos.engine.operators.singleinput.path.Closure) {\r\n  _continueFlag_1_0 = true;\r\n  break;\r\n}",
            "cardinality": "*"
          },
          "connections": {
            "f": [{
              "mode": "ONLY_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "o",
              "id": -1
            }],
            "i": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "j",
              "id": -1
            }],
            "j": [{
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "active": false,
              "id label": "",
              "to": "f",
              "id": -1
            }]
          },
          "o": {
            "op type": "RuleOperator",
            "also subclasses": true,
            "class type": "Operator",
            "position": [
              30,
              828
            ]
          }
        }
      },
      "documentation": {
        "see also": {
          "rules": [
            "Variable Propagation",
            "Factor out OR in Filter",
            "ConstantPropagation of Filter in Index"
          ],
          "rule packages": []
        },
        "long description": "If there Filter expressions with a equal-comparision of a variable with a constant value, e.g. Filter(?X=&lt;http://myURL.de&gt;), then this constant value can be propagated to preceding (RDF3X/Hexastore) Index operators. Afterwards, the corresponding variable (here ?X) must be bound with the constant value (here &lt;http://myURL.de&gt;), e.g. ?X ?Y ?Z. Filter(?X=&lt;http://myURL.de&gt;) is transformed into &lt;http://myURL.de&gt; ?Y ?Z. AddBinding(?X=&lt;http://myURL.de&gt;). However, there are problems with this approach if the constant value can be value-equal with another constant value using a different representation, e.g. +01^^xsd:int is value-equal, but not identical to 1^^xsd:int. Thus, this transformation rule is not applied whenever the constant value is a numerical value or a language tagged literal.\n\nThe following figure contains the graphical representation of the transformation rule.",
        "show visual representation": true,
        "right image": "",
        "use generated visual representation": true,
        "short description": "This rule implements constant propagation from Filter to Index.",
        "left image": "",
        "transition text": "c is neither a numerical value nor a language tagged literal"
      },
      "implementation": {
        "additional import declarations": "",
        "additional global java code": "private lupos.datastructures.items.Variable var = null;\nprivate lupos.datastructures.items.literal.Literal constant = null;\nprivate int operandIDOfFilter;",
        "replace method": {
          "code": "",
          "additional code": "this.constant = this.constant.createThisLiteralNew();\nthis.i.replace(this.var, this.constant);\nthis.i.getUnionVariables().remove(this.var);\nthis.i.getIntersectionVariables().remove(this.var);\n\nb.setVar(this.var);\nb.setLiteral(this.constant);\n\njava.util.LinkedList<lupos.datastructures.items.Variable> unionVars=new java.util.LinkedList<lupos.datastructures.items.Variable>(this.i.getUnionVariables());\nunionVars.add(this.var);\njava.util.LinkedList<lupos.datastructures.items.Variable> intersectionVars=new java.util.LinkedList<lupos.datastructures.items.Variable>(unionVars);\n\nb.setUnionVariables(unionVars);\nb.setIntersectionVariables(intersectionVars);\nthis.j_end.getOperatorIDTuple(o).setId(this.operandIDOfFilter);",
          "use generated code": true
        },
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "this.operandIDOfFilter = this.f.getOperatorIDTuple(o).getId();\n\nlupos.sparql1_1.Node n = this.f.getNodePointer();\n\nif(n.jjtGetNumChildren() > 0) {\n    n = n.jjtGetChild(0);\n\n    if(n instanceof lupos.sparql1_1.ASTEqualsNode) {\n        lupos.sparql1_1.Node left = n.jjtGetChild(0);\n        lupos.sparql1_1.Node right = n.jjtGetChild(1);\n\n        if(right instanceof lupos.sparql1_1.ASTVar) {\n            lupos.sparql1_1.Node tmp = left;\n            left = right;\n            right = tmp;\n        }\n\n        if(left instanceof lupos.sparql1_1.ASTVar) {\n            this.var = new lupos.datastructures.items.Variable(((lupos.sparql1_1.ASTVar) left).getName());\n\n            if(!this.i.getVarsInTriplePatterns().contains(this.var)){\n              return false;\n            }\n\n            if(right instanceof lupos.sparql1_1.ASTQName\n               || right instanceof lupos.sparql1_1.ASTQuotedURIRef\n               || right instanceof lupos.sparql1_1.ASTFloatingPoint\n               || right instanceof lupos.sparql1_1.ASTInteger\n               || right instanceof lupos.sparql1_1.ASTStringLiteral\n               || right instanceof lupos.sparql1_1.ASTDoubleCircumflex\n       || right instanceof lupos.sparql1_1.ASTRDFLiteral) {\n                this.constant = lupos.datastructures.items.literal.LazyLiteral.getLiteral(right);\n\n                // Is it possible to loose the information of the original string representation?\n                if(this.constant instanceof lupos.datastructures.items.literal.TypedLiteralOriginalContent || this.constant instanceof lupos.datastructures.items.literal.LanguageTaggedLiteralOriginalLanguage) {\n                    return false;\n                }\n                else if(this.constant instanceof lupos.datastructures.items.literal.TypedLiteral) {\n                    if(lupos.engine.operators.singleinput.filter.expressionevaluation.Helper.isNumeric(((lupos.datastructures.items.literal.TypedLiteral) this.constant).getType())) {\n                        return false;\n                    } else {\n                        return true;\n                    }\n                } else {\n                    return true;\n                }\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    else {\n        return false;\n    }\n}\nelse {\n    return false;\n}",
          "use generated code": true
        }
      }
    }
  },
  "rule packages": {
    "RIF Rules 1": {"documentation": {
      "see also": {
        "rules": [],
        "rule packages": []
      },
      "long description": "",
      "short description": ""
    }},
    "RIF Rules 0": {"documentation": {
      "see also": {
        "rules": [],
        "rule packages": []
      },
      "long description": "",
      "short description": ""
    }},
    "RIF Rules 7": {"documentation": {
      "see also": {
        "rules": [],
        "rule packages": []
      },
      "long description": "",
      "short description": ""
    }},
    "RIF Rules 6": {"documentation": {
      "see also": {
        "rules": [],
        "rule packages": []
      },
      "long description": "",
      "short description": ""
    }},
    "RIF Rules 9": {"documentation": {
      "see also": {
        "rules": [],
        "rule packages": []
      },
      "long description": "",
      "short description": ""
    }},
    "RIF Rules 8": {"documentation": {
      "see also": {
        "rules": [],
        "rule packages": []
      },
      "long description": "",
      "short description": ""
    }},
    "Logical Optimization For Stream Engine": {"documentation": {
      "see also": {
        "rules": [
          "Binary Join",
          "Push Filter",
          "Factor out AND in Filter"
        ],
        "rule packages": ["Logical Optimization"]
      },
      "long description": "",
      "short description": "Logical optimization aims to reorganize the operator graph into an equivalent operator graph, which generates the same output for any input as the original operator graph, in order to optimize the execution time of query evaluation. This Rule Package is especially designed for the Stream Engine."
    }},
    "RIF Rules": {"documentation": {
      "see also": {
        "rules": [
          "Push RuleFilter",
          "Construct To Generate",
          "Remove Unnecessary Construct",
          "Split ConstructPredicate",
          "Remove Union",
          "Generate Pat ConstructPredicate",
          "ReplaceVar Under Index",
          "Split PredicatePattern",
          "Split Generate",
          "Merge Memory Indexes",
          "Remove Empty Index",
          "Remove Distinct",
          "Remove Unnecessary ConstructPredicate",
          "Replace Generate Pat"
        ],
        "rule packages": [
          "Logical Optimization",
          "Logical Optimization For Stream Engine"
        ]
      },
      "long description": "",
      "short description": "The rules of this rule package are applied to operatorgraphs generated from a RIF document. Among other optimizations, the rules deal with optimizations of recursive rules."
    }},
    "RIF Rules 3": {"documentation": {
      "see also": {
        "rules": [],
        "rule packages": []
      },
      "long description": "",
      "short description": ""
    }},
    "RIF Rules 2": {"documentation": {
      "see also": {
        "rules": [],
        "rule packages": []
      },
      "long description": "",
      "short description": ""
    }},
    "RIF Rules 5": {"documentation": {
      "see also": {
        "rules": [],
        "rule packages": []
      },
      "long description": "",
      "short description": ""
    }},
    "Logical Optimization": {"documentation": {
      "see also": {
        "rules": [
          "Binary Join",
          "Optimizing Join Order",
          "Push Filter",
          "Combine Unions",
          "Variable Propagation",
          "Factor out OR in Filter",
          "Factor out AND in Filter",
          "SortLimit over Sort",
          "Projection Over Sort",
          "Bound Variable in Union",
          "Constant Propagation of Filter in Index With Additional Operators Between"
        ],
        "rule packages": [
          "Physical Optimization",
          "Logical Optimization For Stream Engine"
        ]
      },
      "long description": "",
      "short description": "Logical optimization aims to reorganize the operator graph into an equivalent operator graph, which generates the same output for any input as the original operator graph, in order to optimize the execution time of query evaluation."
    }},
    "RIF Rules 4": {"documentation": {
      "see also": {
        "rules": [],
        "rule packages": []
      },
      "long description": "",
      "short description": ""
    }},
    "RIF Rules 10": {"documentation": {
      "see also": {
        "rules": [],
        "rule packages": []
      },
      "long description": "",
      "short description": ""
    }},
    "Correct Operatorgraph": {"documentation": {
      "see also": {
        "rules": [
          "Bound Variable in Optional",
          "Bound Variable in Union"
        ],
        "rule packages": []
      },
      "long description": "Directly after its generation from the abstract syntax tree, the operator graph does not consider constructs, where variables are already bound outside the scope of UNION and OPTIONAL-clauses and have to be used in filter expressions inside the scope of UNION and OPTIONAL-clauses. For these cases, the results inside and outside of the UNION and OPTIONAL-clauses must be first joined before the filter is evaluated.",
      "short description": "The rules of this package correct the operator graph after its generation from the abstract syntax tree."
    }},
    "RIF Rules 12": {"documentation": {
      "see also": {
        "rules": [],
        "rule packages": []
      },
      "long description": "",
      "short description": ""
    }},
    "RIF Rules 11": {"documentation": {
      "see also": {
        "rules": [],
        "rule packages": []
      },
      "long description": "",
      "short description": ""
    }},
    "RIF Rules 14": {"documentation": {
      "see also": {
        "rules": [],
        "rule packages": []
      },
      "long description": "",
      "short description": ""
    }},
    "RIF Rules 13": {"documentation": {
      "see also": {
        "rules": [],
        "rule packages": []
      },
      "long description": "",
      "short description": ""
    }},
    "After Physical Optimization": {"documentation": {
      "see also": {
        "rules": [
          "Push Filter",
          "Physical Optimization Rule"
        ],
        "rule packages": ["Physical Optimization"]
      },
      "long description": "",
      "short description": "This rule package is used after the physical optimization as the physical optimization may produce an operatorgraph where pushing filters is again possible."
    }},
    "RIF Rules 16": {"documentation": {
      "see also": {
        "rules": [],
        "rule packages": []
      },
      "long description": "",
      "short description": ""
    }},
    "RIF Rules 15": {"documentation": {
      "see also": {
        "rules": [],
        "rule packages": []
      },
      "long description": "",
      "short description": ""
    }},
    "Physical Optimization": {"documentation": {
      "see also": {
        "rules": ["Physical Optimization Rule"],
        "rule packages": ["Logical Optimization"]
      },
      "long description": "",
      "short description": "Physical optimization aims to choose the algorithm with the best estimated execution times in the context of the operator for each operator in the operator graph."
    }}
  }
}