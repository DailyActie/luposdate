{
  "rule packages": {
    "Logical Optimization For Stream Engine": {"documentation": {
      "see also": {
        "rule packages": ["Logical Optimization"],
        "rules": [
          "Binary Join",
          "Push Filter",
          "Constant Propagation of Filter in Triple Pattern",
          "Factor out AND in Filter"
        ]
      },
      "short description": "Logical optimization aims to reorganize the operator graph into an equivalent operator graph, which generates the same output for any input as the original operator graph, in order to optimize the execution time of query evaluation. This Rule Package is especially designed for the Stream Engine.",
      "long description": ""
    }},
    "Logical Optimization": {"documentation": {
      "see also": {
        "rule packages": [
          "Physical Optimization",
          "Logical Optimization For Stream Engine"
        ],
        "rules": [
          "Binary Join",
          "Optimizing Join Order",
          "Push Filter",
          "Combine Unions",
          "Variable Propagation",
          "Factor out OR in Filter",
          "Factor out AND in Filter",
          "SortLimit over Sort",
          "Projection Over Sort",
          "Bound Variable in Union",
          "Constant Propagation of Filter in Index"
        ]
      },
      "short description": "Logical optimization aims to reorganize the operator graph into an equivalent operator graph, which generates the same output for any input as the original operator graph, in order to optimize the execution time of query evaluation.",
      "long description": ""
    }},
    "RIF Rules 1": {"documentation": {
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": "",
      "long description": ""
    }},
    "RIF Rules 0": {"documentation": {
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": "",
      "long description": ""
    }},
    "RIF Rules 5": {"documentation": {
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": "",
      "long description": ""
    }},
    "After Physical Optimization": {"documentation": {
      "see also": {
        "rule packages": ["Physical Optimization"],
        "rules": [
          "Push Filter",
          "Physical Optimization Rule"
        ]
      },
      "short description": "This rule package is used after the physical optimization as the physical optimization may produce an operatorgraph where pushing filters is again possible.",
      "long description": ""
    }},
    "RIF Rules 4": {"documentation": {
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": "",
      "long description": ""
    }},
    "RIF Rules 3": {"documentation": {
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": "",
      "long description": ""
    }},
    "RIF Rules 2": {"documentation": {
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": "",
      "long description": ""
    }},
    "RIF Rules 9": {"documentation": {
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": "",
      "long description": ""
    }},
    "RIF Rules 8": {"documentation": {
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": "",
      "long description": ""
    }},
    "RIF Rules 7": {"documentation": {
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": "",
      "long description": ""
    }},
    "RIF Rules 6": {"documentation": {
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": "",
      "long description": ""
    }},
    "RIF Rules 14": {"documentation": {
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": "",
      "long description": ""
    }},
    "RIF Rules 13": {"documentation": {
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": "",
      "long description": ""
    }},
    "RIF Rules 15": {"documentation": {
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": "",
      "long description": ""
    }},
    "RIF Rules 10": {"documentation": {
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": "",
      "long description": ""
    }},
    "RIF Rules 12": {"documentation": {
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": "",
      "long description": ""
    }},
    "RIF Rules 11": {"documentation": {
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": "",
      "long description": ""
    }},
    "Physical Optimization": {"documentation": {
      "see also": {
        "rule packages": ["Logical Optimization"],
        "rules": ["Physical Optimization Rule"]
      },
      "short description": "Physical optimization aims to choose the algorithm with the best estimated execution times in the context of the operator for each operator in the operator graph.",
      "long description": ""
    }},
    "Correct Operatorgraph": {"documentation": {
      "see also": {
        "rule packages": [],
        "rules": [
          "Bound Variable in Optional",
          "Bound Variable in Union"
        ]
      },
      "short description": "The rules of this package correct the operator graph after its generation from the abstract syntax tree.",
      "long description": "Directly after its generation from the abstract syntax tree, the operator graph does not consider constructs, where variables are already bound outside the scope of UNION and OPTIONAL-clauses and have to be used in filter expressions inside the scope of UNION and OPTIONAL-clauses. For these cases, the results inside and outside of the UNION and OPTIONAL-clauses must be first joined before the filter is evaluated."
    }},
    "RIF Rules": {"documentation": {
      "see also": {
        "rule packages": [
          "Logical Optimization",
          "Logical Optimization For Stream Engine"
        ],
        "rules": [
          "Push RuleFilter",
          "Construct To Generate",
          "Remove Unnecessary Construct",
          "Split ConstructPredicate",
          "Remove Union",
          "Generate Pat ConstructPredicate",
          "ReplaceVar Under Index",
          "Split PredicatePattern",
          "Split Generate",
          "Merge Memory Indexes",
          "Remove Empty Index",
          "Remove Distinct",
          "Remove Unnecessary ConstructPredicate",
          "Replace Generate Pat"
        ]
      },
      "short description": "The rules of this rule package are applied to operatorgraphs generated from a RIF document. Among other optimizations, the rules deal with optimizations of recursive rules.",
      "long description": ""
    }}
  },
  "associations": {
    "Logical Optimization For Stream Engine": [
      "Factor out AND in Filter",
      "Push Filter",
      "Binary Join",
      "Constant Propagation of Filter in Triple Pattern"
    ],
    "Logical Optimization": [
      "Factor out AND in Filter",
      "Factor out OR in Filter",
      "Push Filter",
      "Constant Propagation of Filter in Index",
      "Combine Unions",
      "Variable Propagation",
      "Projection Over Sort",
      "SortLimit over Sort",
      "Binary Join",
      "Optimizing Join Order"
    ],
    "RIF Rules 1": ["Remove Unnecessary Construct"],
    "RIF Rules 0": ["Remove Empty Index"],
    "RIF Rules 5": ["Split PredicatePattern"],
    "After Physical Optimization": ["Push Filter"],
    "RIF Rules 4": ["Split Generate"],
    "RIF Rules 3": ["Construct To Generate"],
    "RIF Rules 2": ["Remove Unnecessary ConstructPredicate"],
    "RIF Rules 9": ["Remove Union"],
    "RIF Rules 8": ["Generate Pat ConstructPredicate"],
    "RIF Rules 7": ["Replace Generate Pat"],
    "RIF Rules 6": ["Split ConstructPredicate"],
    "RIF Rules 14": ["Push RuleFilter"],
    "RIF Rules 13": ["Merge Memory Indexes"],
    "RIF Rules 15": ["HashSetNonBlockingDistinctWithIndexAccess"],
    "RIF Rules 10": ["Factor out AND in Filter"],
    "RIF Rules 12": ["ReplaceVar Under Index"],
    "RIF Rules 11": ["Replace Filter With RuleFilter"],
    "Physical Optimization": ["Physical Optimization Rule"],
    "Correct Operatorgraph": [
      "Bound Variable in Optional",
      "Bound Variable in Union"
    ],
    "RIF Rules": [
      "Remove Empty Index",
      "Remove Unnecessary Construct",
      "Remove Unnecessary ConstructPredicate",
      "Construct To Generate",
      "Split Generate",
      "Split PredicatePattern",
      "Split ConstructPredicate",
      "Replace Generate Pat",
      "Generate Pat ConstructPredicate",
      "Remove Union",
      "Remove Distinct",
      "Factor out AND in Filter",
      "Replace Filter With RuleFilter",
      "ReplaceVar Under Index",
      "Merge Memory Indexes",
      "Push RuleFilter"
    ]
  },
  "rules": {
    "Bound Variable in Optional": {
      "visual representation": {
        "left side": {
          "f": {
            "position": [
              43,
              555
            ],
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator"
          },
          "o2": {
            "position": [
              526,
              17
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "o1": {
            "position": [
              43,
              19
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "jump_filter": {
            "conditions": "",
            "position": [
              2,
              282
            ],
            "also subclasses": false,
            "class type": "Filter",
            "op type": "JumpOverOperator",
            "cardinality": "*"
          },
          "connections": {
            "f": [{
              "id": 1,
              "to": "opt",
              "active": true,
              "id label": "",
              "mode": "EXISTS"
            }],
            "o2": [{
              "id": 0,
              "to": "opt",
              "active": true,
              "id label": "",
              "mode": "ONLY_SUCCEEDING"
            }],
            "o1": [{
              "id": -1,
              "to": "jump_filter",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }],
            "jump_filter": [{
              "id": -1,
              "to": "f",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }]
          },
          "opt": {
            "position": [
              498,
              820
            ],
            "also subclasses": false,
            "start node": true,
            "class type": "Optional",
            "op type": "RuleOperator"
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "f": {
            "position": [
              292,
              762
            ],
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator"
          },
          "o2": {
            "position": [
              891,
              21
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "o1": {
            "position": [
              2,
              21
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "jump_filter": {
            "conditions": "",
            "position": [
              291,
              524
            ],
            "also subclasses": false,
            "class type": "Filter",
            "op type": "JumpOverOperator",
            "cardinality": "*"
          },
          "connections": {
            "f": [{
              "id": 1,
              "to": "opt",
              "active": true,
              "id label": "",
              "mode": "EXISTS"
            }],
            "o2": [
              {
                "id": -1,
                "to": "j",
                "active": false,
                "id label": "",
                "mode": "EXISTS"
              },
              {
                "id": 0,
                "to": "opt",
                "active": true,
                "id label": "",
                "mode": "EXISTS"
              }
            ],
            "o1": [{
              "id": -1,
              "to": "j",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "jump_filter": [{
              "id": -1,
              "to": "f",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }],
            "j": [{
              "id": -1,
              "to": "jump_filter",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }]
          },
          "j": {
            "position": [
              290,
              292
            ],
            "also subclasses": false,
            "class type": "Join",
            "op type": "RuleOperator"
          },
          "opt": {
            "position": [
              769,
              992
            ],
            "also subclasses": false,
            "class type": "Optional",
            "op type": "RuleOperator"
          }
        }
      },
      "implementation": {
        "additional global java code": "",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "if(this.o1 instanceof lupos.engine.operators.multiinput.join.Join && this.o1.getPrecedingOperators().contains(this.o2)) {\n    return false;\n}\n\nlupos.engine.operators.singleinput.Filter filterOutestFilter = this.f;\njava.util.Collection<lupos.datastructures.items.Variable> variablesInnerUnion = this.o1.getIntersectionVariables();\njava.util.Collection<lupos.datastructures.items.Variable> variablesOuterUnion = this.o2.getUnionVariables();\nboolean checkFurther = true;\n\nwhile(checkFurther) {\n    if(!variablesInnerUnion.containsAll(filterOutestFilter.getUsedVariables())) {\n        for(lupos.datastructures.items.Variable v : filterOutestFilter.getUsedVariables()) {\n            if(!variablesInnerUnion.contains(v) && variablesOuterUnion.contains(v)) {\n                return true;\n            }\n        }\n    }\n\n    BasicOperator nextOp = filterOutestFilter.getPrecedingOperators().get(0);\n\n    if(nextOp.equals(this.o1)) {\n        checkFurther = false;\n    }\n    else {\n        filterOutestFilter = (lupos.engine.operators.singleinput.Filter) nextOp;\n    }\n}",
          "use generated code": true
        },
        "replace method": {
          "code": "",
          "additional code": "this.o1.getOperatorIDTuple(j).setId(0);\nthis.o2.getOperatorIDTuple(j).setId(1);\n\nHashSet<lupos.datastructures.items.Variable> intersectionVariables = new HashSet<lupos.datastructures.items.Variable>();\nintersectionVariables.addAll(this.o1.getUnionVariables());\nintersectionVariables.retainAll(this.o2.getUnionVariables());\n\nHashSet<lupos.datastructures.items.Variable> unionVariables = new HashSet<lupos.datastructures.items.Variable>();\nunionVariables.addAll(this.o1.getUnionVariables());\nunionVariables.addAll(this.o2.getUnionVariables());\n\nBasicOperator tmpOp = j;\n\nwhile(!tmpOp.equals(this.opt)) {\n    tmpOp.setUnionVariables(unionVariables);\n    tmpOp.setIntersectionVariables(intersectionVariables);\n\n    tmpOp = tmpOp.getSucceedingOperators().get(0).getOperator();\n}\n\nthis.opt.setUnionVariables(unionVariables);\nthis.opt.setIntersectionVariables(intersectionVariables);",
          "use generated code": true
        },
        "additional import declarations": ""
      },
      "documentation": {
        "show visual representation": true,
        "see also": {
          "rule packages": [],
          "rules": ["Bound Variable in Union"]
        },
        "short description": "This rule corrects the operator graph after its generation from the abstract syntax tree, especially for the case that variables are used in filter expressions, which are bound outside of the OPTIONAL-clause.",
        "left image": "",
        "long description": "This rule avoids failures in SPARQL queries like <span style=\"font-family:monospace;\">{ ?X ?Y ?Z. Optional { ?X2 ?Y2 ?Z2. Filter(?X=?X2).} }<\/span>\n\nLet P1 = ?X ?Y ?Z. and P2 = ?X2 ?Y2 ?Z2. If we do not correct the operator graph after generating the operator graph from the abstract syntax tree, then the Filter-expression is evaluated on results of P2, which is every time false (as ?X is not bound). Thus, we have to correct the operator graph and first join P1 and P2 before the evaluation of the filter expression.We display the graphical representation of the general transformation rule in the below given figure:",
        "use generated visual representation": true,
        "right image": "",
        "transition text": "?X is not necessarily bound in results of O1, but can be bound in results of O2"
      }
    },
    "Push Filter": {
      "visual representation": {
        "left side": {
          "f": {
            "position": [
              68,
              807
            ],
            "also subclasses": false,
            "start node": true,
            "class type": "Filter",
            "op type": "RuleOperator"
          },
          "op2": {
            "position": [
              46,
              1071
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "op": {
            "position": [
              68,
              269
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "o": {
            "position": [
              57,
              5
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {
            "f": [{
              "id": -1,
              "to": "op2",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "op": [{
              "id": -1,
              "to": "j",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }],
            "o": [{
              "id": -1,
              "to": "op",
              "active": true,
              "id label": "a",
              "mode": "ALL_PRECEDING"
            }],
            "j": [{
              "id": -1,
              "to": "f",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }]
          },
          "j": {
            "conditions": "",
            "position": [
              16,
              533
            ],
            "also subclasses": false,
            "class type": "Filter",
            "op type": "JumpOverOperator",
            "cardinality": "*"
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "f": {
            "position": [
              57,
              929
            ],
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator"
          },
          "op2": {
            "position": [
              57,
              1160
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "op": {
            "position": [
              57,
              467
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "f_new": {
            "position": [
              109,
              236
            ],
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator"
          },
          "o": {
            "position": [
              57,
              5
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {
            "f": [{
              "id": -1,
              "to": "op2",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "op": [{
              "id": -1,
              "to": "j",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }],
            "f_new": [{
              "id": -1,
              "to": "op",
              "active": true,
              "id label": "a",
              "mode": "ALL_PRECEDING"
            }],
            "o": [{
              "id": -1,
              "to": "f_new",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "j": [{
              "id": -1,
              "to": "f",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }]
          },
          "j": {
            "conditions": "",
            "position": [
              109,
              698
            ],
            "also subclasses": false,
            "class type": "Filter",
            "op type": "JumpOverOperator",
            "cardinality": "*"
          }
        }
      },
      "implementation": {
        "additional global java code": "",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "if(this.op instanceof lupos.engine.operators.tripleoperator.TriplePattern || this.op instanceof lupos.engine.operators.index.BasicIndex || this.op instanceof lupos.engine.operators.index.IndexCollection) {\n    return false;\n}\n\nif(this.op instanceof lupos.engine.operators.multiinput.Union) {\n    for(BasicOperator o : this.op.getPrecedingOperators()) {\n        if(o.getSucceedingOperators().size() > 1 || (o instanceof lupos.engine.operators.singleinput.Filter && this.f.equalFilterExpression((lupos.engine.operators.singleinput.Filter) o))) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nif(this.op instanceof lupos.engine.operators.multiinput.optional.Optional || this.op instanceof lupos.engine.operators.multiinput.optional.parallel.ParallelOptional || this.op instanceof lupos.engine.operators.multiinput.optional.parallel.MergeParallelOptional) {\n    if(this.op.getPrecedingOperators().size() == 2) {\n        BasicOperator o = this.op.getPrecedingOperators().get(0);\n\n        if(o.getUnionVariables().containsAll(this.f.getUsedVariables()) && !(o instanceof lupos.engine.operators.singleinput.Filter && this.f.equalFilterExpression((lupos.engine.operators.singleinput.Filter) o))) {\n            o = this.op.getPrecedingOperators().get(1);\n\n            if(o.getUnionVariables().containsAll(this.f.getUsedVariables()) && !(o instanceof lupos.engine.operators.singleinput.Filter && this.f.equalFilterExpression((lupos.engine.operators.singleinput.Filter) o))) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nif(this.op instanceof lupos.engine.operators.multiinput.join.Join) {\n    // check if the join has preceding this.ops in a loop\n    if(this.op.getCycleOperands() != null && this.op.getCycleOperands().size() > 0) {\n        return false;\n    }\n}\n\nfor(BasicOperator o : this.op.getPrecedingOperators()) {\n    if(o.getSucceedingOperators().size() == 1 && o.getUnionVariables().containsAll(this.f.getUsedVariables()) && !(o instanceof lupos.engine.operators.singleinput.Filter && this.f.equalFilterExpression((lupos.engine.operators.singleinput.Filter) o))) {\n        return true;\n    }\n}\n\nreturn false;",
          "use generated code": true
        },
        "replace method": {
          "code": "",
          "additional code": "boolean deleteFilter = true;\n\nfor(int i = 0; i < this.o.length; i += 1) {\n    BasicOperator o2 = this.o[i];\n\n    if(!(o2 instanceof lupos.engine.operators.singleinput.Filter && this.f.equalFilterExpression((lupos.engine.operators.singleinput.Filter) o2))) {\n        if(o2.getUnionVariables().containsAll(this.f.getUsedVariables())) {\n            HashSet<lupos.datastructures.items.Variable> hsv = new HashSet<lupos.datastructures.items.Variable>();\n            hsv.addAll(o2.getIntersectionVariables());\n\n            f_new[i].setIntersectionVariables(hsv);\n            f_new[i].setUnionVariables(hsv);\n            f_new[i].setNodePointer(this.f.getNodePointer());\n        }\n        else {\n            if(deleteFilter) {\n                for(lupos.datastructures.items.Variable v : o2.getUnionVariables()) {\n                    if(this.f.getUsedVariables().contains(v)) {\n                        deleteFilter = false;\n\n                        break;\n                    }\n                }\n            }\n\n            this.deleteOperator(f_new[i], _startNodes);\n        }\n    }\n}\n\nif(deleteFilter || this.op instanceof lupos.engine.operators.multiinput.join.Join) {\n    this.deleteOperator(this.f, _startNodes);\n}",
          "use generated code": true
        },
        "additional import declarations": ""
      },
      "documentation": {
        "show visual representation": true,
        "see also": {
          "rule packages": [],
          "rules": ["Factor out AND in Filter"]
        },
        "short description": "Filter operators never increase, but reduce the number of intermediate results in most times. Thus, it is important for the performance to evaluate a filter expression as early as possible. This rule pushes a filter operator upwards in the operator graph whenever possible.",
        "left image": "",
        "long description": "The filter is copied over its preceding operator, if the preceding operator is not a triple pattern or an (RDF3X/Hexastore) Index-operator. The filter operator is copied to those operands of the preceding operator, which bind all variables occurring in the filter expression. If the preceding operator is an Union operator, the filter operator is only copied if it can be moved to all of its operands. Currently, the filter is not moved in the case that the preceding operator is an Optional operator. The original filter is deleted if all the operand operators O1 to On of its preceding operator bind all of the used variables of the filter, or if the preceding operator is a Join operator.\n\nThe following figure contains the graphical representation of the transformation rule.",
        "use generated visual representation": true,
        "right image": "",
        "transition text": "op is neither a triple pattern nor an (RDF3X/Hexastore) Index operator nor an Optional operator. if op is an Union operator, O1 to On must bind all variables occuring in c."
      }
    },
    "Combine Unions": {
      "visual representation": {
        "left side": {
          "o1": {
            "position": [
              5,
              5
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "u2": {
            "position": [
              5,
              533
            ],
            "also subclasses": false,
            "start node": true,
            "class type": "Union",
            "op type": "RuleOperator"
          },
          "u1": {
            "position": [
              5,
              269
            ],
            "also subclasses": false,
            "class type": "Union",
            "op type": "RuleOperator"
          },
          "connections": {
            "o1": [{
              "id": -1,
              "to": "u1",
              "active": false,
              "id label": "",
              "mode": "ALL_PRECEDING"
            }],
            "u1": [{
              "id": -1,
              "to": "u2",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "o1": {
            "position": [
              10,
              18
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "u2": {
            "position": [
              22,
              246
            ],
            "also subclasses": false,
            "class type": "Union",
            "op type": "RuleOperator"
          },
          "connections": {"o1": [{
            "id": -1,
            "to": "u2",
            "active": false,
            "id label": "",
            "mode": "ALL_PRECEDING"
          }]}
        }
      },
      "implementation": {
        "additional global java code": "",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "",
          "use generated code": true
        },
        "replace method": {
          "code": "",
          "additional code": "int id = 0;\n        \nfor(BasicOperator precOp : this.u2.getPrecedingOperators()) {\n    precOp.getOperatorIDTuple(this.u2).setId(id++);\n}",
          "use generated code": true
        },
        "additional import declarations": ""
      },
      "documentation": {
        "show visual representation": true,
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "This transformtion rule combines two succeeding union operators into one in order to save the processing costs of a superfluous union operation.",
        "left image": "",
        "long description": "",
        "use generated visual representation": true,
        "right image": "",
        "transition text": ""
      }
    },
    "Variable Propagation": {
      "visual representation": {
        "left side": {
          "f": {
            "position": [
              52,
              543
            ],
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator"
          },
          "o": {
            "position": [
              54,
              807
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {
            "f": [{
              "id": -1,
              "to": "o",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "j": [{
              "id": -1,
              "to": "f",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }],
            "i": [{
              "id": -1,
              "to": "j",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }]
          },
          "j": {
            "conditions": "",
            "position": [
              19,
              269
            ],
            "also subclasses": false,
            "class type": "Filter",
            "op type": "JumpOverOperator",
            "cardinality": "*"
          },
          "i": {
            "position": [
              51,
              5
            ],
            "also subclasses": true,
            "start node": true,
            "class type": "Index",
            "op type": "RuleOperator"
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "b": {
            "position": [
              40,
              467
            ],
            "also subclasses": false,
            "class type": "AddBindingFromOtherVar",
            "op type": "RuleOperator"
          },
          "o": {
            "position": [
              63,
              698
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {
            "b": [{
              "id": -1,
              "to": "o",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "j": [{
              "id": -1,
              "to": "b",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }],
            "i": [{
              "id": -1,
              "to": "j",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }]
          },
          "j": {
            "conditions": "",
            "position": [
              67,
              236
            ],
            "also subclasses": false,
            "class type": "Filter",
            "op type": "JumpOverOperator",
            "cardinality": "*"
          },
          "i": {
            "position": [
              42,
              5
            ],
            "also subclasses": false,
            "class type": "Index",
            "op type": "RuleOperator"
          }
        }
      },
      "implementation": {
        "additional global java code": "private lupos.datastructures.items.Variable var = null;\nprivate lupos.datastructures.items.Variable otherVar = null;\nprivate int operandIDOfFilter;",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "lupos.sparql1_1.Node n = this.f.getNodePointer();\n\nif(n.jjtGetNumChildren() > 0) {\n    n = n.jjtGetChild(0);\n\n    if(n instanceof lupos.sparql1_1.ASTEqualsNode) {\n        lupos.sparql1_1.Node left = n.jjtGetChild(0);\n        lupos.sparql1_1.Node right = n.jjtGetChild(1);\n\n        if(left instanceof lupos.sparql1_1.ASTVar) {\n            this.var = new lupos.datastructures.items.Variable(((lupos.sparql1_1.ASTVar) left).getName());\n\n            if(right instanceof lupos.sparql1_1.ASTVar) {\n                this.otherVar = new lupos.datastructures.items.Variable(((lupos.sparql1_1.ASTVar) right).getName());\n\n                if(this.i.occurInSubjectOrPredicateOrObjectOriginalStringDoesNotDiffer(this.var) || this.i.occurInSubjectOrPredicateOrObjectOriginalStringDoesNotDiffer(this.otherVar)) {\n                    this.operandIDOfFilter = this.f.getOperatorIDTuple(o).getId();\n                    return true;\n                }\n                else {\n                    // in objects, there might occur typed literals e.g.\n                    // numbers, which are value equal, but do not have the\n                    // same identity, e.g. 01^^xsd:int and 1^^xsd:int.\n                    // => var or otherVar must occur in the subject or\n                    // predicate of a triple pattern, such that they are\n                    // URIs or blank nodes, which have an unique\n                    // representation!\n                    return false;\n                }\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    else {\n        return false;\n   }\n}\nelse {\n    return false;\n}",
          "use generated code": true
        },
        "replace method": {
          "code": "",
          "additional code": "this.i.replace(this.var, this.otherVar);\n\nb.setVar(this.var);\nb.setOtherVar(this.otherVar);\n\nBasicOperator tmp = this.i;\n\nwhile(!tmp.equals(b)) {\n    tmp.getUnionVariables().remove(this.var);\n    tmp.getIntersectionVariables().remove(this.var);\n\n    tmp = tmp.getSucceedingOperators().get(0).getOperator();\n}\n\nb.setUnionVariables(this.f.getUnionVariables());\nb.setIntersectionVariables(this.f.getIntersectionVariables());\nb.getOperatorIDTuple(o).setId(this.operandIDOfFilter);",
          "use generated code": true
        },
        "additional import declarations": ""
      },
      "documentation": {
        "show visual representation": true,
        "see also": {
          "rule packages": [],
          "rules": [
            "Constant Propagation of Filter in Index",
            "Factor out OR in Filter"
          ]
        },
        "short description": "This rule implements variable propagation.",
        "left image": "",
        "long description": "If there are Filter expressions with a value-comparision of two variables, e.g. Filter(?X=?Y), then one of the variables can be propagated to preceding (RDF3X/Hexastore) Index operators in certain cases. However there are problems, if the variables can contain values with ambiguous representations. The values are not identical, but value-equal in this case. These situations might occur when both corresponding variables do not occur in the subject or the predicate of a triple pattern, but only in the objects, which can contain numerical values or language tagged literals. The transformation rule is not applied in these cases.\n\nThe following figure contains the graphical representation of the transformation rule.",
        "use generated visual representation": true,
        "right image": "",
        "transition text": "?X or ?Y occurs in a subject or a predicate of a triple pattern of the index operator"
      }
    },
    "Push RuleFilter": {
      "visual representation": {
        "left side": {
          "f": {
            "position": [
              46,
              807
            ],
            "also subclasses": false,
            "start node": true,
            "class type": "RuleFilter",
            "op type": "RuleOperator"
          },
          "op2": {
            "position": [
              46,
              1071
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "op": {
            "position": [
              46,
              269
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "o": {
            "position": [
              46,
              5
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {
            "f": [{
              "id": -1,
              "to": "op2",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "op": [{
              "id": -1,
              "to": "j",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }],
            "o": [{
              "id": -1,
              "to": "op",
              "active": true,
              "id label": "a",
              "mode": "ALL_PRECEDING"
            }],
            "j": [{
              "id": -1,
              "to": "f",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }]
          },
          "j": {
            "conditions": "",
            "position": [
              5,
              533
            ],
            "also subclasses": false,
            "class type": "RuleFilter",
            "op type": "JumpOverOperator",
            "cardinality": "*"
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "f": {
            "position": [
              5,
              929
            ],
            "also subclasses": false,
            "class type": "RuleFilter",
            "op type": "RuleOperator"
          },
          "op2": {
            "position": [
              5,
              1160
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "op": {
            "position": [
              5,
              467
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "f_new": {
            "position": [
              5,
              236
            ],
            "also subclasses": false,
            "class type": "RuleFilter",
            "op type": "RuleOperator"
          },
          "o": {
            "position": [
              5,
              5
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {
            "f": [{
              "id": -1,
              "to": "op2",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "op": [{
              "id": -1,
              "to": "j",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }],
            "f_new": [{
              "id": -1,
              "to": "op",
              "active": true,
              "id label": "a",
              "mode": "ALL_PRECEDING"
            }],
            "o": [{
              "id": -1,
              "to": "f_new",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "j": [{
              "id": -1,
              "to": "f",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }]
          },
          "j": {
            "conditions": "",
            "position": [
              5,
              698
            ],
            "also subclasses": false,
            "class type": "RuleFilter",
            "op type": "JumpOverOperator",
            "cardinality": "*"
          }
        }
      },
      "implementation": {
        "additional global java code": "",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "if(this.op instanceof lupos.engine.operators.tripleoperator.TriplePattern || this.op instanceof lupos.engine.operators.index.BasicIndex || this.op instanceof lupos.engine.operators.index.IndexCollection) {\n    return false;\n}\n\nif(this.op instanceof lupos.engine.operators.multiinput.Union) {\n    for(BasicOperator o : this.op.getPrecedingOperators()) {\n        if(o.getSucceedingOperators().size() > 1 || (o instanceof lupos.rif.operator.RuleFilter && this.f.equalFilterExpression((lupos.rif.operator.RuleFilter) o))) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nif(this.op instanceof lupos.engine.operators.multiinput.optional.Optional || this.op instanceof lupos.engine.operators.multiinput.optional.parallel.ParallelOptional || this.op instanceof lupos.engine.operators.multiinput.optional.parallel.MergeParallelOptional) {\n    if(this.op.getPrecedingOperators().size() == 2) {\n        BasicOperator o = this.op.getPrecedingOperators().get(0);\n\n        if(o.getUnionVariables().containsAll(this.f.getVariablesInExpression()) && !(o instanceof lupos.rif.operator.RuleFilter && this.f.equalFilterExpression((lupos.rif.operator.RuleFilter) o))) {\n            o = this.op.getPrecedingOperators().get(1);\n\n            if(o.getUnionVariables().containsAll(this.f.getVariablesInExpression()) && !(o instanceof lupos.rif.operator.RuleFilter && this.f.equalFilterExpression((lupos.rif.operator.RuleFilter) o))) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nif(this.op instanceof lupos.engine.operators.multiinput.join.Join) {\n    // check if the join has preceding this.ops in a loop\n    if(this.op.getCycleOperands() != null && this.op.getCycleOperands().size() > 0) {\n        return false;\n    }\n}\n\nfor(BasicOperator o : this.op.getPrecedingOperators()) {\n    if(o.getSucceedingOperators().size() == 1 && o.getUnionVariables().containsAll(this.f.getVariablesInExpression()) && !(o instanceof lupos.rif.operator.RuleFilter && this.f.equalFilterExpression((lupos.rif.operator.RuleFilter) o))) {\n        return true;\n    }\n}\n\nreturn false;",
          "use generated code": true
        },
        "replace method": {
          "code": "",
          "additional code": "boolean deleteFilter = true;\n\nfor(int i = 0; i < this.o.length; i += 1) {\n    BasicOperator o2 = this.o[i];\n\n    if(!(o2 instanceof lupos.rif.operator.RuleFilter && this.f.equalFilterExpression((lupos.rif.operator.RuleFilter) o2))) {\n        if(o2.getUnionVariables().containsAll(this.f.getVariablesInExpression())) {\n            HashSet<lupos.datastructures.items.Variable> hsv = new HashSet<lupos.datastructures.items.Variable>();\n            hsv.addAll(o2.getIntersectionVariables());\n\n            f_new[i].setIntersectionVariables(hsv);\n            f_new[i].setUnionVariables(hsv);\n            f_new[i].setExpression(this.f.getExpression());\n        }\n        else {\n            if(deleteFilter) {\n                for(lupos.datastructures.items.Variable v : o2.getUnionVariables()) {\n                    if(this.f.getVariablesInExpression().contains(v)) {\n                        deleteFilter = false;\n\n                        break;\n                    }\n                }\n            }\n\n            this.deleteOperator(f_new[i], _startNodes);\n        }\n    }\n}\n\nif(deleteFilter || this.op instanceof lupos.engine.operators.multiinput.join.Join) {\n    this.deleteOperator(this.f, _startNodes);\n}",
          "use generated code": true
        },
        "additional import declarations": ""
      },
      "documentation": {
        "show visual representation": true,
        "see also": {
          "rule packages": [],
          "rules": ["Push Filter"]
        },
        "short description": "Analogous to the Push Filter rule for SPARQL Filter operators, this transformation rule moves a RIF Filter operator in the operator graph, such that it is processed as early as possible in order to filter out intermediate solutions as early as possible and thus saving processing costs.",
        "left image": "",
        "long description": "",
        "use generated visual representation": true,
        "right image": "",
        "transition text": ""
      }
    },
    "Construct To Generate": {
      "visual representation": {
        "left side": {
          "t": {
            "position": [
              5,
              269
            ],
            "also subclasses": false,
            "class type": "TriplePattern",
            "op type": "RuleOperator"
          },
          "c": {
            "position": [
              5,
              5
            ],
            "also subclasses": false,
            "class type": "Construct",
            "op type": "RuleOperator"
          },
          "connections": {"c": [{
            "id": -1,
            "to": "t",
            "active": false,
            "id label": "",
            "mode": "ONLY_SUCCEEDING"
          }]}
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {}
      },
      "implementation": {
        "additional global java code": "",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "",
          "use generated code": true
        },
        "replace method": {
          "code": "for(lupos.engine.operators.tripleoperator.TriplePattern tp : this.c.getTemplates()) {\n    lupos.engine.operators.singleinput.generate.Generate generate = new lupos.engine.operators.singleinput.generate.Generate(this.t, tp.getItems());\n    generate.setPrecedingOperators(new java.util.ArrayList<lupos.engine.operators.BasicOperator>(this.c.getPrecedingOperators()));\n\n    this.addNodeToStartNodeMapNullCheck(generate, _startNodes);\n\n    for(lupos.engine.operators.BasicOperator prec : generate.getPrecedingOperators()) {\n        prec.addSucceedingOperator(generate);\n    }\n\n    this.t.addPrecedingOperator(generate);\n}\n\nfor (final OperatorIDTuple oidtuple : this.c.getSucceedingOperators()) {\n    oidtuple.getOperator().removePrecedingOperator(this.c);\n}\nfor (final BasicOperator prec : this.c.getPrecedingOperators()) {\n    prec.removeSucceedingOperator(this.c);\n}\nthis.deleteNodeFromStartNodeMapNullCheck(this.c, _startNodes);\n",
          "additional code": "",
          "use generated code": false
        },
        "additional import declarations": ""
      },
      "documentation": {
        "show visual representation": false,
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "If a Construct has only a Triple Pattern as succeeding operator, we can transform the Construct into Generate operators (for each triple pattern template in the Construct, one Generate operator).",
        "left image": "",
        "long description": "",
        "use generated visual representation": true,
        "right image": "",
        "transition text": ""
      }
    },
    "Remove Unnecessary Construct": {
      "visual representation": {
        "left side": {
          "c": {
            "position": [
              32,
              11
            ],
            "also subclasses": false,
            "class type": "Construct",
            "op type": "RuleOperator"
          },
          "p": {
            "position": [
              28,
              272
            ],
            "also subclasses": false,
            "class type": "PredicatePattern",
            "op type": "RuleOperator"
          },
          "connections": {"c": [{
            "id": -1,
            "to": "p",
            "active": false,
            "id label": "",
            "mode": "ONLY_SUCCEEDING"
          }]}
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {"p": {
          "position": [
            29,
            15
          ],
          "also subclasses": false,
          "class type": "PredicatePattern",
          "op type": "RuleOperator"
        }}
      },
      "implementation": {
        "additional global java code": "",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "",
          "use generated code": true
        },
        "replace method": {
          "code": "",
          "additional code": "",
          "use generated code": true
        },
        "additional import declarations": ""
      },
      "documentation": {
        "show visual representation": true,
        "see also": {
          "rule packages": ["RIF Rules"],
          "rules": []
        },
        "short description": "If a Construct has only a PredicatePattern as succeeding operator, the PredicatePattern operator will not have any result for the output of a Construct and can be therefore removed.",
        "left image": "",
        "long description": "",
        "use generated visual representation": true,
        "right image": "",
        "transition text": ""
      }
    },
    "Split ConstructPredicate": {
      "visual representation": {
        "left side": {
          "o2": {
            "position": [
              5,
              533
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "o1": {
            "position": [
              5,
              5
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "c": {
            "position": [
              5,
              269
            ],
            "also subclasses": false,
            "class type": "ConstructPredicate",
            "op type": "RuleOperator"
          },
          "connections": {
            "o1": [{
              "id": -1,
              "to": "c",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING"
            }],
            "c": [{
              "id": -1,
              "to": "o2",
              "active": true,
              "id label": "a",
              "mode": "ALL_SUCCEEDING"
            }]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "o2": {
            "position": [
              5,
              467
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "o1": {
            "position": [
              5,
              5
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "c_new": {
            "position": [
              5,
              236
            ],
            "also subclasses": false,
            "class type": "ConstructPredicate",
            "op type": "RuleOperator"
          },
          "connections": {
            "o1": [{
              "id": -1,
              "to": "c_new",
              "active": true,
              "id label": "a",
              "mode": "ALL_SUCCEEDING"
            }],
            "c_new": [{
              "id": -1,
              "to": "o2",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }]
          }
        }
      },
      "implementation": {
        "additional global java code": "",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "return this.c.getSucceedingOperators().size() > 1 && this.c.getPredicatePattern().size() == 1;",
          "use generated code": true
        },
        "replace method": {
          "code": "",
          "additional code": "for(lupos.rif.operator.ConstructPredicate tmp_c : c_new) {\r\n    tmp_c.setPredicatePattern(this.c.getPredicatePattern());\r\n}",
          "use generated code": true
        },
        "additional import declarations": ""
      },
      "documentation": {
        "show visual representation": true,
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "Creation of one ConstructPredicate for each of its predecessors, which simplifies further optimizations.",
        "left image": "",
        "long description": "",
        "use generated visual representation": true,
        "right image": "",
        "transition text": ""
      }
    },
    "Constant Propagation of Filter in Triple Pattern": {
      "visual representation": {
        "left side": {
          "f": {
            "position": [
              57,
              543
            ],
            "also subclasses": false,
            "start node": true,
            "class type": "Filter",
            "op type": "RuleOperator"
          },
          "tp": {
            "position": [
              57,
              5
            ],
            "also subclasses": true,
            "class type": "TriplePattern",
            "op type": "RuleOperator"
          },
          "o": {
            "position": [
              57,
              807
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {
            "f": [{
              "id": -1,
              "to": "o",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "tp": [{
              "id": -1,
              "to": "j",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }],
            "j": [{
              "id": -1,
              "to": "f",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }]
          },
          "j": {
            "conditions": "",
            "position": [
              27,
              269
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "JumpOverOperator",
            "cardinality": "*"
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "b": {
            "position": [
              57,
              467
            ],
            "also subclasses": false,
            "class type": "AddBinding",
            "op type": "RuleOperator"
          },
          "tp": {
            "position": [
              57,
              5
            ],
            "also subclasses": false,
            "class type": "TriplePattern",
            "op type": "RuleOperator"
          },
          "o": {
            "position": [
              57,
              698
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {
            "b": [{
              "id": -1,
              "to": "o",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "tp": [{
              "id": -1,
              "to": "j",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }],
            "j": [{
              "id": -1,
              "to": "b",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }]
          },
          "j": {
            "conditions": "",
            "position": [
              109,
              236
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "JumpOverOperator",
            "cardinality": "*"
          }
        }
      },
      "implementation": {
        "additional global java code": "private lupos.datastructures.items.Variable var = null;\nprivate lupos.datastructures.items.literal.Literal constant = null;",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "if(this.tp.getSucceedingOperators().size() != 1 || this.f.getPrecedingOperators().size() != 1) {\n    return false;\n}\n\nlupos.sparql1_1.Node n = this.f.getNodePointer();\n\nif(n.jjtGetNumChildren() > 0) {\n    n = n.jjtGetChild(0);\n\n    if(n instanceof lupos.sparql1_1.ASTEqualsNode) {\n        lupos.sparql1_1.Node left = n.jjtGetChild(0);\n        lupos.sparql1_1.Node right = n.jjtGetChild(1);\n\n        if(right instanceof lupos.sparql1_1.ASTVar) {\n            lupos.sparql1_1.Node tmp = left;\n            left = right;\n            right = tmp;\n        }\n\n        if(left instanceof lupos.sparql1_1.ASTVar) {\n            String varname = ((lupos.sparql1_1.ASTVar) left).getName();\n            this.var = new lupos.datastructures.items.Variable(varname);\n\n            if(!this.tp.getVariables().contains(this.var) && !this.tp.getVariables().contains(new lupos.datastructures.items.VariableInInferenceRule(varname))) {\n                // TODO: delete triple pattern as it will never have a result!\n                System.err.println(\"Can be optimized by extending RuleReplaceConstantOfFilterInTriplePattern: delete triple pattern with succeeding unsatisfiable filter expression!\");\n\n                return false;\n            }\n\n            if(right instanceof lupos.sparql1_1.ASTQName\n               || right instanceof lupos.sparql1_1.ASTRDFLiteral\n               || right instanceof lupos.sparql1_1.ASTQuotedURIRef\n               || right instanceof lupos.sparql1_1.ASTFloatingPoint\n               || right instanceof lupos.sparql1_1.ASTInteger\n               || right instanceof lupos.sparql1_1.ASTStringLiteral\n               || right instanceof lupos.sparql1_1.ASTDoubleCircumflex) {\n                this.constant = lupos.datastructures.items.literal.LazyLiteral.getLiteral(right);\n\n                // Is it possible to loose the information of the original string representation?\n                if(this.constant instanceof lupos.datastructures.items.literal.TypedLiteralOriginalContent || constant instanceof lupos.datastructures.items.literal.LanguageTaggedLiteralOriginalLanguage) {\n                    \treturn false;\n                }\n                else if(this.constant instanceof lupos.datastructures.items.literal.TypedLiteral) {\n                    if(lupos.engine.operators.singleinput.ExpressionEvaluation.Helper.isNumeric(((lupos.datastructures.items.literal.TypedLiteral) constant).getType())) {\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                }\n                else {\n                    return true;\n                }\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    else {\n        return false;\n    }\n}\nelse {\n    return false;\n}",
          "use generated code": true
        },
        "replace method": {
          "code": "",
          "additional code": "java.util.Set<lupos.datastructures.items.Variable> replacedVars = this.tp.replace(this.var, this.constant);\n\nb.setVar(this.var);\nb.setLiteral(this.constant);\n\nBasicOperator tmp = this.tp;\n\nwhile(!tmp.equals(b)) {\n    tmp.getUnionVariables().removeAll(replacedVars);\n    tmp.getIntersectionVariables().removeAll(replacedVars);\n\n    tmp = tmp.getSucceedingOperators().get(0).getOperator();\n}\n\nb.setUnionVariables(this.f.getUnionVariables());\nb.setIntersectionVariables(this.f.getIntersectionVariables());",
          "use generated code": true
        },
        "additional import declarations": ""
      },
      "documentation": {
        "show visual representation": true,
        "see also": {
          "rule packages": [],
          "rules": [
            "Variable Propagation",
            "Factor out OR in Filter",
            "Constant Propagation of Filter in Index"
          ]
        },
        "short description": "This rule implements constant propagation from Filter to Triple Pattern.",
        "left image": "",
        "long description": "If there Filter expressions with a equal-comparision of a variable with a constant value, e.g. Filter(?X=&lt;http://myURL.de&gt;), then this constant value can be propagated to preceding Triple Pattern operators. Afterwards, the corresponding variable (here ?X) must be bound with the constant value (here &lt;http://myURL.de&gt;), e.g. ?X ?Y ?Z. Filter(?X=&lt;http://myURL.de&gt;) is transformed into &lt;http://myURL.de&gt; ?Y ?Z. AddBinding(?X=&lt;http://myURL.de&gt;). However, there are problems with this approach if the constant value can be value-equal with another constant value using a different representation, e.g. +01^^xsd:int is value-equal, but not identical to 1^^xsd:int. Thus, this transformation rule is not applied whenever the constant value is a numerical value or a language tagged literal.\r\n\r\nThe following figure contains the graphical representation of the transformation rule.",
        "use generated visual representation": true,
        "right image": "",
        "transition text": ""
      }
    },
    "Replace Filter With RuleFilter": {
      "visual representation": {
        "left side": {
          "f": {
            "position": [
              5,
              269
            ],
            "also subclasses": false,
            "start node": true,
            "class type": "Filter",
            "op type": "RuleOperator"
          },
          "o2": {
            "position": [
              5,
              533
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "o1": {
            "position": [
              5,
              5
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {
            "f": [{
              "id": -1,
              "to": "o2",
              "active": false,
              "id label": "",
              "mode": "ALL_SUCCEEDING"
            }],
            "o1": [{
              "id": -1,
              "to": "f",
              "active": false,
              "id label": "",
              "mode": "ALL_PRECEDING"
            }]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "o2": {
            "position": [
              5,
              467
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "o1": {
            "position": [
              5,
              5
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {
            "o1": [{
              "id": -1,
              "to": "rf",
              "active": false,
              "id label": "",
              "mode": "ALL_PRECEDING"
            }],
            "rf": [{
              "id": -1,
              "to": "o2",
              "active": false,
              "id label": "",
              "mode": "ALL_SUCCEEDING"
            }]
          },
          "rf": {
            "position": [
              5,
              236
            ],
            "also subclasses": false,
            "class type": "RuleFilter",
            "op type": "RuleOperator"
          }
        }
      },
      "implementation": {
        "additional global java code": "",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "return this.f.getNodePointer().jjtGetChild(0) instanceof lupos.sparql1_1.ASTEqualsNode;",
          "use generated code": true
        },
        "replace method": {
          "code": "",
          "additional code": "lupos.optimizations.sparql2core_sparql.SPARQLParserVisitorImplementationDumper filterDumper = new lupos.optimizations.sparql2core_sparql.SPARQLParserVisitorImplementationDumper();\n\nString equalsString = (String) filterDumper.visit((lupos.sparql1_1.ASTEqualsNode) this.f.getNodePointer().jjtGetChild(0));\n\nlupos.rif.model.Equality equality = null;\n\ntry {\n    lupos.rif.generated.syntaxtree.RIFAtomic atomic = new lupos.rif.generated.parser.RIFParser(new java.io.StringReader(equalsString.substring(1, equalsString.length() - 1))).RIFAtomic();\n    lupos.rif.visitor.ParseSyntaxTreeVisitor rifParser = new lupos.rif.visitor.ParseSyntaxTreeVisitor();\n\tequality = (lupos.rif.model.Equality) atomic.accept(rifParser, null);\n} catch(lupos.rif.generated.parser.ParseException e) {\n    e.printStackTrace();\n    return;\n}\n\nrf.setExpression(equality);\nrf.setUnionVariables(this.f.getUnionVariables());\nrf.setIntersectionVariables(this.f.getIntersectionVariables());",
          "use generated code": true
        },
        "additional import declarations": ""
      },
      "documentation": {
        "show visual representation": true,
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "SPARQL Filter operators are replaced by RIF Filter operators for dealing with equalities.",
        "left image": "",
        "long description": "",
        "use generated visual representation": true,
        "right image": "",
        "transition text": ""
      }
    },
    "Remove Union": {
      "visual representation": {
        "left side": {
          "o2": {
            "position": [
              5,
              533
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "u": {
            "position": [
              5,
              269
            ],
            "also subclasses": false,
            "start node": true,
            "class type": "Union",
            "op type": "RuleOperator"
          },
          "o1": {
            "position": [
              5,
              5
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {
            "u": [{
              "id": -1,
              "to": "o2",
              "active": false,
              "id label": "",
              "mode": "ALL_SUCCEEDING"
            }],
            "o1": [{
              "id": -1,
              "to": "u",
              "active": false,
              "id label": "",
              "mode": "ALL_PRECEDING"
            }]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "o2": {
            "position": [
              19,
              556
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "o1": {
            "position": [
              14,
              9
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {"o1": [{
            "id": -1,
            "to": "o2",
            "active": false,
            "id label": "",
            "mode": "EXISTS"
          }]}
        }
      },
      "implementation": {
        "additional global java code": "",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "return !(this.u instanceof lupos.engine.operators.multiinput.MergeUnion);",
          "use generated code": true
        },
        "replace method": {
          "code": "for(BasicOperator over : this.u.getPrecedingOperators()) {\n\tfor(OperatorIDTuple opID: this.u.getSucceedingOperators()){\n\t\tover.addSucceedingOperator(new OperatorIDTuple(opID));\n\t\topID.getOperator().addPrecedingOperator(over);\n\t}\n}\n\nthis.u.removeFromOperatorGraphWithoutConnectingPrecedingWithSucceedingOperators();\nthis.deleteNodeFromStartNodeMapNullCheck(this.u, _startNodes);",
          "additional code": "",
          "use generated code": false
        },
        "additional import declarations": ""
      },
      "documentation": {
        "show visual representation": true,
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "All unions are removed by this transformation rule by directly connecting all preceding operators of the union operator with its succeeding operators. This saves a lot of processing costs.",
        "left image": "",
        "long description": "",
        "use generated visual representation": true,
        "right image": "",
        "transition text": ""
      }
    },
    "Factor out AND in Filter": {
      "visual representation": {
        "left side": {
          "b": {
            "position": [
              74,
              269
            ],
            "also subclasses": false,
            "start node": true,
            "class type": "Filter",
            "op type": "RuleOperator"
          },
          "c": {
            "position": [
              29,
              533
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "a": {
            "position": [
              29,
              5
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {
            "b": [{
              "id": -1,
              "to": "c",
              "active": false,
              "id label": "",
              "mode": "ONLY_SUCCEEDING"
            }],
            "a": [{
              "id": -1,
              "to": "b",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "b": {
            "position": [
              72,
              236
            ],
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator"
          },
          "c": {
            "position": [
              32,
              698
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "a": {
            "position": [
              32,
              5
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "b2": {
            "position": [
              66,
              467
            ],
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator"
          },
          "connections": {
            "b": [{
              "id": -1,
              "to": "b2",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "a": [{
              "id": -1,
              "to": "b",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "b2": [{
              "id": -1,
              "to": "c",
              "active": false,
              "id label": "",
              "mode": "ONLY_SUCCEEDING"
            }]
          }
        }
      },
      "implementation": {
        "additional global java code": "private int operandIDOfFilter;",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "this.operandIDOfFilter = this.b.getOperatorIDTuple(c).getId();\nlupos.sparql1_1.Node n = this.b.getNodePointer();\n\nif(n.jjtGetNumChildren() > 0) {\n    n = n.jjtGetChild(0);\n\n    return (n instanceof lupos.sparql1_1.ASTAndNode);\n}",
          "use generated code": true
        },
        "replace method": {
          "code": "",
          "additional code": "lupos.sparql1_1.Node n = this.b.getNodePointer();\n\nn = n.jjtGetChild(0);\nlupos.sparql1_1.ASTFilterConstraint node1 = new lupos.sparql1_1.ASTFilterConstraint(\t0);\nlupos.sparql1_1.ASTFilterConstraint node2 = new lupos.sparql1_1.ASTFilterConstraint(\t1);\nnode1.jjtAddChild(n.jjtGetChild(0), 0);\nnode2.jjtAddChild(n.jjtGetChild(1), 0);\nn.jjtGetChild(0).jjtSetParent(node1);\nn.jjtGetChild(1).jjtSetParent(node2);\n\nthis.b.setNodePointer(node1);\nb2.setNodePointer(node2);\n\nb2.setCollectionForExistNodes(this.b.getCollectionForExistNodes());\nb2.getUsedEvaluationVisitor().setEvaluator(this.b.getUsedEvaluationVisitor().getEvaluator());\n\nb2.setIntersectionVariables(this.b.getIntersectionVariables());\nb2.setUnionVariables(this.b.getUnionVariables());\nb2.getOperatorIDTuple(c).setId(this.operandIDOfFilter);\n\n",
          "use generated code": true
        },
        "additional import declarations": ""
      },
      "documentation": {
        "show visual representation": true,
        "see also": {
          "rule packages": [],
          "rules": ["Push Filter"]
        },
        "short description": "All AND (&&) -operations in filter expressions are factored out.",
        "left image": "",
        "long description": "Let c1 and c2 be boolean expressions. Then this rule factors each c1 && c2 top-level operations in Filter expressions out. We present the general transformation rule in the below given figure:",
        "use generated visual representation": true,
        "right image": "",
        "transition text": ""
      }
    },
    "Generate Pat ConstructPredicate": {
      "visual representation": {
        "left side": {
          "c": {
            "position": [
              5,
              5
            ],
            "also subclasses": false,
            "class type": "ConstructPredicate",
            "op type": "RuleOperator"
          },
          "p": {
            "position": [
              5,
              269
            ],
            "also subclasses": false,
            "class type": "PredicatePattern",
            "op type": "RuleOperator"
          },
          "connections": {"c": [{
            "id": -1,
            "to": "p",
            "active": false,
            "id label": "",
            "mode": "ONLY_SUCCEEDING"
          }]}
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {}
      },
      "implementation": {
        "additional global java code": "",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "return this.c.getPredicatePattern().size() == 1;",
          "use generated code": true
        },
        "replace method": {
          "code": "final lupos.datastructures.items.literal.URILiteral patURI = this.p.getPredicateName();\n\t\tfinal lupos.datastructures.items.Item[] patItems = this.p.getPatternItems().toArray(new lupos.datastructures.items.Item[] {});\n\n\t\tfinal lupos.datastructures.items.literal.URILiteral constructURI = this.c.getPredicatePattern().get(0)\n\t\t\t\t.getFirst();\n\t\tfinal lupos.datastructures.items.Item[] constructItems = this.c.getPredicatePattern().get(0)\n\t\t\t\t.getSecond().toArray(new lupos.datastructures.items.Item[] {});\n\n\t\tlupos.rif.operator.RuleFilter filter = null;\n\t\tfinal lupos.engine.operators.singleinput.ReplaceVar replaceVar = new lupos.engine.operators.singleinput.ReplaceVar();\n\t\treplaceVar.setIntersectionVariables(new java.util.HashSet<lupos.datastructures.items.Variable>());\n\t\treplaceVar.setUnionVariables(replaceVar.getIntersectionVariables());\n\n\t\tfinal java.util.LinkedList<lupos.datastructures.items.Variable> addBindingsVar = new java.util.LinkedList<lupos.datastructures.items.Variable>();\n\t\tfinal java.util.LinkedList<lupos.datastructures.items.literal.Literal> addBindingsLit = new java.util.LinkedList<lupos.datastructures.items.literal.Literal>();\n\n\t\tif (!patURI.equals(constructURI)\n\t\t\t\t|| patItems.length != constructItems.length) {\n\t\t\tfor (final BasicOperator parent : this.c.getPrecedingOperators())\n\t\t\t\tparent.removeSucceedingOperator(this.c);\n\t\t\tthis.c.getPrecedingOperators().clear();\n\t\t\tthis.c.removeFromOperatorGraph();\n\t\t\treturn;\n\t\t}\n\n\t\tfinal lupos.rif.model.Conjunction conj = new lupos.rif.model.Conjunction();\n\t\tfor (int i = 0; i < patItems.length; i++) {\n\t\t\tfinal lupos.datastructures.items.Item patItem = patItems[i];\n\t\t\tfinal lupos.datastructures.items.Item constructItem = constructItems[i];\n\t\t\tif ((!patItem.isVariable()) && constructItem.isVariable()) {\n\t\t\t\t{\n\t\t\t\t\tfinal lupos.rif.model.Equality eq = new lupos.rif.model.Equality();\n\t\t\t\t\teq.leftExpr = new lupos.rif.model.RuleVariable(constructItem.getName());\n\t\t\t\t\teq.rightExpr = new lupos.rif.model.Constant((lupos.datastructures.items.literal.Literal) patItem, eq);\n\t\t\t\t\tconj.addExpr(eq);\n\t\t\t\t}\n\t\t\t} else if (patItem.isVariable() && constructItem.isVariable()) {\n\t\t\t\treplaceVar.addSubstitution((lupos.datastructures.items.Variable) patItem,\n\t\t\t\t\t\t(lupos.datastructures.items.Variable) constructItem);\n\t\t\t\treplaceVar.getIntersectionVariables().add((lupos.datastructures.items.Variable) patItem);\n\t\t\t} else if (patItem.isVariable() && (!constructItem.isVariable())) {\n\t\t\t\taddBindingsVar.add((lupos.datastructures.items.Variable) patItem);\n\t\t\t\taddBindingsLit.add((lupos.datastructures.items.literal.Literal) constructItem);\n\t\t\t} else if (!patItem.isVariable() && !constructItem.isVariable()\n\t\t\t\t\t&& !constructItem.equals(patItem)) {\n\t\t\t\t// cannot match, remove generate.\n\t\t\t\tfor (final BasicOperator parent : this.c.getPrecedingOperators())\n\t\t\t\t\tparent.removeSucceedingOperator(this.c);\n\t\t\t\tthis.c.getPrecedingOperators().clear();\n\t\t\t\tthis.p.removePrecedingOperator(this.c);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tfor (int x = i + 1; x < patItems.length; x++) {\n\t\t\t\tif (patItems[i].equals(patItems[x])) {\n\t\t\t\t\tfinal lupos.rif.model.Equality eq = new lupos.rif.model.Equality();\n\t\t\t\t\tif (constructItems[i].isVariable())\n\t\t\t\t\t\teq.leftExpr = new lupos.rif.model.RuleVariable(\n\t\t\t\t\t\t\t\tconstructItems[i].getName());\n\t\t\t\t\telse\n\t\t\t\t\t\teq.leftExpr = new lupos.rif.model.Constant((lupos.datastructures.items.literal.Literal) constructItems[i],\n\t\t\t\t\t\t\t\teq);\n\t\t\t\t\tif (constructItems[x].isVariable())\n\t\t\t\t\t\teq.rightExpr = new lupos.rif.model.RuleVariable(\n\t\t\t\t\t\t\t\tconstructItems[x].getName());\n\t\t\t\t\telse\n\t\t\t\t\t\teq.rightExpr = new lupos.rif.model.Constant(\n\t\t\t\t\t\t\t\t(lupos.datastructures.items.literal.Literal) constructItems[x], eq);\n\t\t\t\t\tconj.addExpr(eq);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!conj.isEmpty())\n\t\t\tfilter = new lupos.rif.operator.RuleFilter(conj, null);\n\n\t\t// Only Operators with a not empty definition are put into the\n\t\t// operatorgraph\n\t\tfinal java.util.LinkedList<BasicOperator> order = new java.util.LinkedList<BasicOperator>();\n\t\tif (filter != null) {\n\t\t\torder.add(filter);\n\t\t}\n\n\t\tfinal int substVar = replaceVar.getSubstitutionsVariableLeft().size();\n\n\t\tif (substVar > 0) {\n\t\t\torder.add(replaceVar);\n\t\t} else {\n\t\t\tfinal lupos.engine.operators.singleinput.Projection p = new lupos.engine.operators.singleinput.Projection();\n\t\t\tp.setIntersectionVariables(new java.util.HashSet<lupos.datastructures.items.Variable>());\n\t\t\tp.setUnionVariables(p.getUnionVariables());\n\t\t\torder.add(p);\n\t\t}\n\t\tif (addBindingsVar.size() > 0) {\n\t\t\tfinal java.util.Iterator<lupos.datastructures.items.literal.Literal> lit_it = addBindingsLit.iterator();\n\t\t\tfinal java.util.HashSet<lupos.datastructures.items.Variable> hsv = new java.util.HashSet<lupos.datastructures.items.Variable>();\n\t\t\thsv.addAll(replaceVar.getUnionVariables());\n\t\t\tfor (final lupos.datastructures.items.Variable v : addBindingsVar) {\n\t\t\t\tfinal lupos.engine.operators.singleinput.AddBinding ab = new lupos.engine.operators.singleinput.AddBinding(v, lit_it.next());\n\t\t\t\thsv.add(v);\n\t\t\t\tab.setIntersectionVariables((java.util.HashSet<lupos.datastructures.items.Variable>) hsv.clone());\n\t\t\t\tab.setUnionVariables(ab.getIntersectionVariables());\n\t\t\t\torder.add(ab);\n\t\t\t}\n\t\t}\n\n\t\t// In case that Generate or TriplePattern has minimum one variable, than\n\t\t// minimum one operator has to be inserted\n\t\tif (order.size() > 0) {\n\t\t\tfinal java.util.LinkedList<BasicOperator> pres = (java.util.LinkedList<BasicOperator>) this.c.getPrecedingOperators();\n\t\t\tBasicOperator pre;\n\t\t\tfor (int i = 0; i < pres.size(); i++) {\n\t\t\t\tpre = pres.get(i);\n\t\t\t\tpre.addSucceedingOperator(new OperatorIDTuple(order.getFirst(),\n\t\t\t\t\t\t0));\n\t\t\t\tif (filter != null) {\n\t\t\t\t\tjava.util.Collection<lupos.datastructures.items.Variable> vars = filter\n\t\t\t\t\t\t\t.getIntersectionVariables();\n\t\t\t\t\tif (vars == null)\n\t\t\t\t\t\tvars = new java.util.HashSet<lupos.datastructures.items.Variable>();\n\t\t\t\t\tvars.addAll(pre.getIntersectionVariables());\n\t\t\t\t\tfilter.setIntersectionVariables(vars);\n\t\t\t\t\tfilter.setUnionVariables(vars);\n\t\t\t\t}\n\t\t\t\tpre.removeSucceedingOperator(this.c);\n\t\t\t\torder.getFirst().addPrecedingOperator(pre);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < order.size() - 1; i++) {\n\t\t\t\torder.get(i + 1).setPrecedingOperator(order.get(i));\n\t\t\t\torder.get(i).setSucceedingOperator(\n\t\t\t\t\t\tnew OperatorIDTuple(order.get(i + 1), 0));\n\t\t\t}\n\n\t\t\tfinal java.util.List<OperatorIDTuple> succs = (java.util.List<OperatorIDTuple>) this.p.getSucceedingOperators();\n\t\t\tfor (int i = 0; i < succs.size(); i++) {\n\t\t\t\tsuccs.get(i).getOperator()\n\t\t\t\t\t\t.addPrecedingOperator(order.getLast());\n\t\t\t}\n\n\t\t\tfinal java.util.LinkedList<OperatorIDTuple> sops = new java.util.LinkedList<OperatorIDTuple>();\n\t\t\tsops.addAll(this.p.getSucceedingOperators());\n\t\t\torder.getLast().setSucceedingOperators(sops);\n\t\t} else {\n\t\t\tfinal java.util.LinkedList<BasicOperator> pres = (java.util.LinkedList<BasicOperator>) this.c.getPrecedingOperators();\n\t\t\tfinal java.util.LinkedList<OperatorIDTuple> succs = (java.util.LinkedList<OperatorIDTuple>) this.p.getSucceedingOperators();\n\t\t\tBasicOperator pre;\n\t\t\tBasicOperator succ;\n\t\t\tfor (int i = 0; i < pres.size(); i++) {\n\t\t\t\tpre = pres.get(i);\n\t\t\t\tpre.removeSucceedingOperator(this.c);\n\t\t\t\tfor (int x = 0; x < succs.size(); x++) {\n\t\t\t\t\tpre.addSucceedingOperator(succs.get(x));\n\t\t\t\t\tsucc = succs.get(x).getOperator();\n\t\t\t\t\tsucc.removePrecedingOperator(this.p);\n\t\t\t\t\tsucc.addPrecedingOperator(pre);\n\t\t\t\t}\n\t\t\t}\n\t\t}",
          "additional code": "",
          "use generated code": false
        },
        "additional import declarations": ""
      },
      "documentation": {
        "show visual representation": false,
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "A generated predicate is immediately consumed from a Predicate Pattern. This transformation rule reduces this to the direct assignment of variables.",
        "left image": "",
        "long description": "",
        "use generated visual representation": true,
        "right image": "",
        "transition text": ""
      }
    },
    "ReplaceVar Under Index": {
      "visual representation": {
        "left side": {
          "r": {
            "position": [
              5,
              269
            ],
            "also subclasses": false,
            "start node": true,
            "class type": "ReplaceVar",
            "op type": "RuleOperator"
          },
          "o": {
            "position": [
              9,
              533
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {
            "r": [{
              "id": -1,
              "to": "o",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }],
            "i": [{
              "id": -1,
              "to": "r",
              "active": true,
              "id label": "a",
              "mode": "ALL_PRECEDING"
            }]
          },
          "i": {
            "position": [
              6,
              5
            ],
            "also subclasses": true,
            "class type": "Index",
            "op type": "RuleOperator"
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "o": {
            "position": [
              9,
              531
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {"i": [{
            "id": -1,
            "to": "o",
            "active": true,
            "id label": "a",
            "mode": "ALL_PRECEDING"
          }]},
          "i": {
            "position": [
              17,
              7
            ],
            "also subclasses": false,
            "class type": "Index",
            "op type": "RuleOperator"
          }
        }
      },
      "implementation": {
        "additional global java code": "private int varCounter = 0;",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "java.util.Set<lupos.datastructures.items.Variable> vars = new java.util.HashSet<lupos.datastructures.items.Variable>(this.r.getSubstitutionsVariableRight());\n\nif(vars.size() != this.r.getSubstitutionsVariableRight().size()) {\n    return false;\n}\n\nif(this.o instanceof lupos.engine.operators.singleinput.Result) {\n    return false;\n}\n\nfor(lupos.engine.operators.index.BasicIndex tmp_i : this.i) {\n    if(tmp_i.getSucceedingOperators().size() > 1) {\n        return false;\n    }\n}",
          "use generated code": true
        },
        "replace method": {
          "code": "",
          "additional code": "for(lupos.engine.operators.index.BasicIndex index : this.i) {\n    java.util.Map<String, lupos.datastructures.items.Variable> varMap = new java.util.HashMap<String, lupos.datastructures.items.Variable>();\n    java.util.Map<lupos.datastructures.items.Variable, String> aliasMap = new java.util.HashMap<lupos.datastructures.items.Variable, String>();\n\n    for(lupos.datastructures.items.Variable var : index.getUnionVariables()) {\n        String aliasName = \"RepVar_\" + this.varCounter++ + \"_\" + var.getName();\n        varMap.put(aliasName, var);\n        aliasMap.put(var, aliasName);\n    }\n\n    for(lupos.engine.operators.tripleoperator.TriplePattern tp : index.getTriplePattern()) {\n        for(lupos.datastructures.items.Variable var : tp.getVariables()) {\n            tp.replace(var, new lupos.datastructures.items.Variable(aliasMap.get(var)));\n        }\n    }\n\n    for(lupos.engine.operators.tripleoperator.TriplePattern tp : index.getTriplePattern()) {\n        for(lupos.datastructures.items.Variable v : tp.getVariables()) {\n            lupos.datastructures.items.Variable rv = this.r.getReplacement(varMap.get(v.getName()));\n\n            if(rv != null) {\n                tp.replace(v, rv);\n            }\n        }\n    }\n}",
          "use generated code": true
        },
        "additional import declarations": ""
      },
      "documentation": {
        "show visual representation": true,
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "ReplaceVar under Index Scan operators are eliminated by replacing the variable directly in the Index Scan operator.",
        "left image": "",
        "long description": "",
        "use generated visual representation": true,
        "right image": "",
        "transition text": ""
      }
    },
    "Split PredicatePattern": {
      "visual representation": {
        "left side": {
          "o2": {
            "position": [
              5,
              533
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "o1": {
            "position": [
              5,
              5
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "p": {
            "position": [
              5,
              269
            ],
            "also subclasses": false,
            "start node": true,
            "class type": "PredicatePattern",
            "op type": "RuleOperator"
          },
          "connections": {
            "o1": [{
              "id": -1,
              "to": "p",
              "active": true,
              "id label": "a",
              "mode": "ALL_PRECEDING"
            }],
            "p": [{
              "id": -1,
              "to": "o2",
              "active": false,
              "id label": "",
              "mode": "ONLY_SUCCEEDING"
            }]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "o2": {
            "position": [
              5,
              467
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "o1": {
            "position": [
              5,
              5
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "p_new": {
            "position": [
              5,
              236
            ],
            "also subclasses": false,
            "class type": "PredicatePattern",
            "op type": "RuleOperator"
          },
          "connections": {
            "o1": [{
              "id": -1,
              "to": "p_new",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "p_new": [{
              "id": -1,
              "to": "o2",
              "active": true,
              "id label": "a",
              "mode": "ALL_PRECEDING"
            }]
          }
        }
      },
      "implementation": {
        "additional global java code": "",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "return this.p.getPrecedingOperators().size() > 1;",
          "use generated code": true
        },
        "replace method": {
          "code": "",
          "additional code": "for(lupos.rif.operator.PredicatePattern tmp_p : p_new) {\n    tmp_p.setUnionVariables(new java.util.HashSet<lupos.datastructures.items.Variable>(this.p.getUnionVariables()));\n    tmp_p.setIntersectionVariables(new java.util.HashSet<lupos.datastructures.items.Variable>(this.p.getIntersectionVariables()));\n    tmp_p.setPredicateName(this.p.getPredicateName());\n    tmp_p.setPatternItems(this.p.getPatternItems());\n}",
          "use generated code": true
        },
        "additional import declarations": ""
      },
      "documentation": {
        "show visual representation": true,
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "Creation of one PredicatePattern for each of its predecessors, which simplifies further optimizations.",
        "left image": "",
        "long description": "",
        "use generated visual representation": true,
        "right image": "",
        "transition text": ""
      }
    },
    "Bound Variable in Union": {
      "visual representation": {
        "left side": {
          "f": {
            "position": [
              51,
              545
            ],
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator"
          },
          "u": {
            "position": [
              52,
              811
            ],
            "also subclasses": false,
            "start node": true,
            "class type": "Union",
            "op type": "RuleOperator"
          },
          "o2": {
            "position": [
              34,
              5
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "o3": {
            "position": [
              520,
              417
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "jump_filter": {
            "conditions": "",
            "position": [
              5,
              269
            ],
            "also subclasses": false,
            "class type": "Filter",
            "op type": "JumpOverOperator",
            "cardinality": "*"
          },
          "o": {
            "position": [
              512,
              1344
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {
            "f": [{
              "id": -1,
              "to": "u",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "u": [{
              "id": -1,
              "to": "j",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "o2": [{
              "id": -1,
              "to": "jump_filter",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }],
            "o3": [{
              "id": -1,
              "to": "j",
              "active": false,
              "id label": "",
              "mode": "ONLY_SUCCEEDING"
            }],
            "jump_filter": [{
              "id": -1,
              "to": "f",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }],
            "j": [{
              "id": -1,
              "to": "o",
              "active": false,
              "id label": "",
              "mode": "ALL_SUCCEEDING"
            }]
          },
          "j": {
            "position": [
              512,
              1073
            ],
            "also subclasses": false,
            "class type": "Join",
            "op type": "RuleOperator"
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "f": {
            "position": [
              288,
              759
            ],
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator"
          },
          "u": {
            "position": [
              288,
              995
            ],
            "also subclasses": false,
            "class type": "Union",
            "op type": "RuleOperator"
          },
          "o2": {
            "position": [
              6,
              9
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "o3": {
            "position": [
              904,
              8
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "jump_filter": {
            "conditions": "",
            "position": [
              286,
              527
            ],
            "also subclasses": false,
            "class type": "Filter",
            "op type": "JumpOverOperator",
            "cardinality": "*"
          },
          "o": {
            "position": [
              289,
              1226
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "j_new": {
            "position": [
              287,
              293
            ],
            "also subclasses": false,
            "class type": "Join",
            "op type": "RuleOperator"
          },
          "connections": {
            "f": [{
              "id": -1,
              "to": "u",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "u": [{
              "id": -1,
              "to": "o",
              "active": false,
              "id label": "",
              "mode": "ALL_SUCCEEDING"
            }],
            "o2": [{
              "id": -1,
              "to": "j_new",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "o3": [{
              "id": -1,
              "to": "j_new",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "jump_filter": [{
              "id": -1,
              "to": "f",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }],
            "j_new": [{
              "id": -1,
              "to": "jump_filter",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }]
          }
        }
      },
      "implementation": {
        "additional global java code": "",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "if(this.u.getOperatorIDTuple(this.j).getId()==this.o3.getOperatorIDTuple(this.j).getId()){\n\treturn false;\n}\n\nlupos.engine.operators.singleinput.Filter filterOutestFilter = this.f;\njava.util.Collection<lupos.datastructures.items.Variable> variablesInnerUnion = this.o2.getIntersectionVariables();\njava.util.Collection<lupos.datastructures.items.Variable> variablesOuterUnion = this.o3.getUnionVariables();\nboolean checkFurther = true;\n\nwhile(checkFurther) {\n    if(!variablesInnerUnion.containsAll(filterOutestFilter.getUsedVariables())) {\n        for(lupos.datastructures.items.Variable v : filterOutestFilter.getUsedVariables()) {\n            if(!variablesInnerUnion.contains(v) && variablesOuterUnion.contains(v)) {\n                return true;\n            }\n        }\n    }\n\n    BasicOperator nextOp = filterOutestFilter.getPrecedingOperators().get(0);\n\n    if(nextOp.equals(this.o2)) {\n        checkFurther = false;\n    }\n    else {\n        filterOutestFilter = (lupos.engine.operators.singleinput.Filter) nextOp;\n    }\n}",
          "use generated code": true
        },
        "replace method": {
          "code": "",
          "additional code": "j_new.setUnionVariables(new HashSet<lupos.datastructures.items.Variable>());\nj_new.getUnionVariables().addAll(this.o2.getUnionVariables());\nj_new.getUnionVariables().addAll(this.o3.getUnionVariables());\n\nj_new.setIntersectionVariables(new HashSet<lupos.datastructures.items.Variable>());\nj_new.getIntersectionVariables().addAll(this.o2.getUnionVariables());\nj_new.getIntersectionVariables().retainAll(this.o3.getUnionVariables());\n\nthis.o2.getOperatorIDTuple(j_new).setId(0);\nthis.o3.getOperatorIDTuple(j_new).setId(1);\n\nfor(BasicOperator precOp : this.u.getPrecedingOperators()) {\n    if(!precOp.equals(this.f)) {\n        BasicOperator tmpOp = precOp;\n\n        while(tmpOp instanceof lupos.engine.operators.singleinput.Filter) {\n            tmpOp = tmpOp.getPrecedingOperators().get(0);\n        }\n\n\n        lupos.engine.operators.multiinput.join.Join newJoin = new lupos.engine.operators.multiinput.join.Join();\n\n        newJoin.addPrecedingOperator(tmpOp);\n        newJoin.addPrecedingOperator(this.o3);\n\n        for(OperatorIDTuple opIDt : tmpOp.getSucceedingOperators()) {\n            opIDt.getOperator().removePrecedingOperator(tmpOp);\n            opIDt.getOperator().addPrecedingOperator(newJoin);\n        }\n\n        newJoin.setSucceedingOperators(tmpOp.getSucceedingOperators());\n        tmpOp.setSucceedingOperator(new OperatorIDTuple(newJoin, 0));\n        this.o3.addSucceedingOperator(new OperatorIDTuple(newJoin, 1));\n\n\n        HashSet<lupos.datastructures.items.Variable> intersectionVariables = new HashSet<lupos.datastructures.items.Variable>();\n        intersectionVariables.addAll(tmpOp.getUnionVariables());\n        intersectionVariables.retainAll(this.o3.getUnionVariables());\n\n        HashSet<lupos.datastructures.items.Variable> unionVariables = new HashSet<lupos.datastructures.items.Variable>();\n        unionVariables.addAll(tmpOp.getUnionVariables());\n        unionVariables.addAll(this.o3.getUnionVariables());\n\n        newJoin.setIntersectionVariables(intersectionVariables);\n        newJoin.setUnionVariables(unionVariables);\n\n\n        tmpOp = tmpOp.getSucceedingOperators().get(0).getOperator();\n\n        while(!tmpOp.equals(this.u)) {\n            tmpOp.setUnionVariables(unionVariables);\n            tmpOp.setIntersectionVariables(intersectionVariables);\n\n            tmpOp = tmpOp.getSucceedingOperators().get(0).getOperator();\n        }\n    }\n}",
          "use generated code": true
        },
        "additional import declarations": ""
      },
      "documentation": {
        "show visual representation": true,
        "see also": {
          "rule packages": [],
          "rules": ["Bound Variable in Optional"]
        },
        "short description": "This rule corrects the operator graph after its generation from the abstract syntax tree, especially for the case that variables are used in filter expressions, which are bound outside of the UNION-clause.",
        "left image": "",
        "long description": "This rule avoids failures in SPARQL queries like <span style=\"font-family:monospace;\">{ ?X ?Y ?Z. { ?X2 ?Y2 ?Z2. Filter(?X=?X2).} UNION { ... } }<\/span>\n\nLet P1 = ?X ?Y ?Z. and P2 = ?X2 ?Y2 ?Z2. If we do not correct the operator graph after generating the operator graph from the abstract syntax tree, then the Filter-expression is evaluated on results of P2, which is every time false (as ?X is not bound). Thus, we have to correct the operator graph and first join P1 and P2 before the evaluation of the filter expression.We display the graphical representation of the general transformation rule in the below given figure:",
        "use generated visual representation": true,
        "right image": "",
        "transition text": "?X is not necessarily bound in results of O2, but can be bound in results of O3"
      }
    },
    "Split Generate": {
      "visual representation": {
        "left side": {
          "g": {
            "position": [
              5,
              269
            ],
            "also subclasses": false,
            "class type": "Generate",
            "op type": "RuleOperator"
          },
          "o1": {
            "position": [
              5,
              5
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "t": {
            "position": [
              5,
              533
            ],
            "also subclasses": true,
            "class type": "TriplePattern",
            "op type": "RuleOperator"
          },
          "connections": {
            "g": [{
              "id": -1,
              "to": "t",
              "active": true,
              "id label": "a",
              "mode": "ALL_SUCCEEDING"
            }],
            "o1": [{
              "id": -1,
              "to": "g",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING"
            }]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "g_new": {
            "position": [
              5,
              236
            ],
            "also subclasses": false,
            "class type": "Generate",
            "op type": "RuleOperator"
          },
          "o1": {
            "position": [
              5,
              5
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "t": {
            "position": [
              5,
              467
            ],
            "also subclasses": false,
            "class type": "TriplePattern",
            "op type": "RuleOperator"
          },
          "connections": {
            "g_new": [{
              "id": -1,
              "to": "t",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "o1": [{
              "id": -1,
              "to": "g_new",
              "active": true,
              "id label": "a",
              "mode": "ALL_SUCCEEDING"
            }]
          }
        }
      },
      "implementation": {
        "additional global java code": "",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "return this.g.getSucceedingOperators().size() > 1;",
          "use generated code": true
        },
        "replace method": {
          "code": "",
          "additional code": "for(lupos.engine.operators.singleinput.generate.Generate tmp_g : g_new) {\n    tmp_g.setValueOrVariable(this.g.getValueOrVariable());\n}",
          "use generated code": true
        },
        "additional import declarations": ""
      },
      "documentation": {
        "show visual representation": true,
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "Creation of one Generate for each of its predecessors, which simplifies further optimizations.",
        "left image": "",
        "long description": "",
        "use generated visual representation": true,
        "right image": "",
        "transition text": ""
      }
    },
    "Binary Join": {
      "visual representation": {
        "left side": {
          "o2": {
            "position": [
              5,
              533
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "o1": {
            "position": [
              5,
              5
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {
            "o1": [{
              "id": -1,
              "to": "join",
              "active": false,
              "id label": "",
              "mode": "ALL_PRECEDING"
            }],
            "join": [{
              "id": -1,
              "to": "o2",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }]
          },
          "join": {
            "position": [
              5,
              269
            ],
            "also subclasses": false,
            "start node": true,
            "class type": "Join",
            "op type": "RuleOperator"
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {}
      },
      "implementation": {
        "additional global java code": "            public BasicOperator getBinaryJoin(lupos.engine.operators.multiinput.join.Join oldJoin, HashMap<Class<?>, HashSet<BasicOperator>> _startNodes) {\n            \tjava.util.LinkedList<BasicOperator> oldJoinPrec = new java.util.LinkedList<BasicOperator>();\n            \toldJoinPrec.addAll(oldJoin.getPrecedingOperators());\n                java.util.Collection<BasicOperator> newOrder = this.optimizeJoinOrderAccordingToMostRestrictionsForMergeJoin(oldJoinPrec);\n                java.util.Collection<BasicOperator> remainingJoins = new java.util.LinkedList<BasicOperator>();\n                java.util.HashSet<BasicOperator> alreadyUsed = new java.util.HashSet<BasicOperator>();\n                \n                java.util.Iterator<BasicOperator> itp = newOrder.iterator();\n            \n                while(itp.hasNext()) {\n         \n                    BasicOperator first = this.getNext(itp, alreadyUsed);\n                    \n                    if(first==null)\n                    \tbreak;\n                    \n                    if(itp.hasNext()) {\n                    \tfeedAlreadyUsed(oldJoin, first.getOperatorIDTuple(oldJoin).getId(), alreadyUsed);\n                    \t\n                        BasicOperator second = this.getNext(itp, alreadyUsed);\n                        if(second==null){\n                            remainingJoins.add(first);\n                            break;\n                        }\n                        \n                        lupos.engine.operators.multiinput.join.Join newJoin = new lupos.engine.operators.multiinput.join.Join();\n                        this.addNodeToStartNodeMapNullCheck(newJoin, _startNodes);\n                            \n                        handleJoinOperand(oldJoin, first.getOperatorIDTuple(oldJoin).getId(), newJoin, 0, alreadyUsed);\n                        handleJoinOperand(oldJoin, second.getOperatorIDTuple(oldJoin).getId(), newJoin, 1, alreadyUsed);\n                            \n                        HashSet<lupos.datastructures.items.Variable> hv = new HashSet<lupos.datastructures.items.Variable>();\n                        for(BasicOperator bo: newJoin.getPrecedingOperators()){\n                        \thv.addAll(bo.getUnionVariables());\n                        }    \n                        newJoin.setUnionVariables(hv);\n            \n                        newJoin.setIntersectionVariables(new HashSet<lupos.datastructures.items.Variable>());\n                        newJoin.getIntersectionVariables().addAll(first.getUnionVariables());\n                        for(BasicOperator bo: newJoin.getPrecedingOperators()){\n                        \tnewJoin.getIntersectionVariables().retainAll(bo.getUnionVariables());\n                        }\n                        \n                        remainingJoins.add(newJoin);\n                    }\n                    else {\n                        remainingJoins.add(first);\n                    }\n                }\n            \n                while(remainingJoins.size() > 1) {\n                    // choose best combination\n                    java.util.Collection<BasicOperator> co = this.getNextJoin(remainingJoins);\n                    java.util.Iterator<BasicOperator> io = co.iterator();\n                    BasicOperator first = io.next();\n                    BasicOperator second = io.next();\n            \n                    lupos.engine.operators.multiinput.join.Join join = new lupos.engine.operators.multiinput.join.Join();\n                    this.addNodeToStartNodeMapNullCheck(join, _startNodes);\n                    \n                    if(first instanceof lupos.engine.operators.multiinput.join.Join && second instanceof lupos.engine.operators.multiinput.join.Join){        \t        \n    \t                first.setSucceedingOperator(new OperatorIDTuple(join, 0));\t    \t        \n    \t                join.addPrecedingOperator(first);\n                    } else {\n                    \tif(first instanceof lupos.engine.operators.multiinput.join.Join){\n                    \t\tBasicOperator tmp = first;\n                    \t\tfirst = second;\n                    \t\tsecond = tmp;\n                    \t}\n                    \t// second is now a join and first something else...\n                        handleJoinOperand(oldJoin, first.getOperatorIDTuple(oldJoin).getId(), join, 0, alreadyUsed);                \t\n                    }\n                    \n                    second.setSucceedingOperator(new OperatorIDTuple(join, 1));    \t        \n                    join.addPrecedingOperator(second);\n                    \n                    HashSet<lupos.datastructures.items.Variable> hv = new HashSet<lupos.datastructures.items.Variable>();\n                    for(BasicOperator bo: join.getPrecedingOperators()){\n                    \thv.addAll(bo.getUnionVariables());\n                    }    \n                    join.setUnionVariables(hv);\n        \n                    join.setIntersectionVariables(new HashSet<lupos.datastructures.items.Variable>());\n                    join.getIntersectionVariables().addAll(first.getUnionVariables());\n                    for(BasicOperator bo: join.getPrecedingOperators()){\n                    \tjoin.getIntersectionVariables().retainAll(bo.getUnionVariables());\n                    }\n            \n                    remainingJoins.remove(first);\n                    remainingJoins.remove(second);\n                    remainingJoins.add(join);\n                }\n            \n                return remainingJoins.iterator().next();\n            }\n            \n            private void feedAlreadyUsed(lupos.engine.operators.multiinput.join.Join oldJoin, int oldOperandID, java.util.HashSet<BasicOperator> alreadyUsed){\n            \tfor(BasicOperator bo: oldJoin.getPrecedingOperators()){\n            \t\tOperatorIDTuple opID=bo.getOperatorIDTuple(oldJoin);\n            \t\tif(opID!=null && opID.getId()==oldOperandID){\n            \t\t\talreadyUsed.add(bo);\n            \t\t}\n            \t}        \t\n            }\n            \n            private void handleJoinOperand(lupos.engine.operators.multiinput.join.Join oldJoin, int oldOperandID, lupos.engine.operators.multiinput.join.Join newJoin, int newOperandID, java.util.HashSet<BasicOperator> alreadyUsed){\n            \tjava.util.LinkedList<lupos.engine.operators.BasicOperator> tmp = new java.util.LinkedList<lupos.engine.operators.BasicOperator>();\n            \ttmp.addAll(oldJoin.getPrecedingOperators());\n            \tfor(BasicOperator bo: tmp){\n            \t\tOperatorIDTuple opID=bo.getOperatorIDTuple(oldJoin);\n            \t\tif(opID!=null && opID.getId()==oldOperandID){\n            \t\t\talreadyUsed.add(bo);\n            \t\t\tbo.replaceOperatorIDTuple(opID, new OperatorIDTuple(newJoin, newOperandID));\n            \t\t\tnewJoin.addPrecedingOperator(bo);\n            \t\t}\n            \t}\n            }\n            \n        private BasicOperator getNext(java.util.Iterator<BasicOperator> itp, java.util.HashSet<BasicOperator> alreadyUsed){\n                    BasicOperator first = itp.next();\n                    while(itp.hasNext() && alreadyUsed.contains(first)){\n                    \tfirst = itp.next();\n                    }\n                    \n                    if(alreadyUsed.contains(first))\n                    \treturn null;\n                    \n                    alreadyUsed.add(first);\n                    \n                    return first;\n        }\n    \n    private java.util.Collection<BasicOperator> optimizeJoinOrderAccordingToMostRestrictionsForMergeJoin(List<BasicOperator> remaining) {\n        java.util.Collection<BasicOperator> newOrder = new java.util.LinkedList<BasicOperator>();\n    \n        while(remaining.size() > 1) {\n            BasicOperator best1 = null;\n            BasicOperator best2 = null;\n            int minOpenPositions = 4;\n    \n            for(BasicOperator bo1 : remaining) {\n                for(BasicOperator bo2 : remaining) {\n                    if(!bo1.equals(bo2)) {\n                        java.util.Collection<lupos.datastructures.items.Variable> v = new java.util.LinkedList<lupos.datastructures.items.Variable>(); \n                        v.addAll(bo1.getUnionVariables());\n                        v.retainAll(bo2.getUnionVariables());\n    \n                        int openPositions = bo1.getUnionVariables().size() - v.size();\n    \n                        if(openPositions < minOpenPositions) {\n                            minOpenPositions = openPositions;\n                            best1 = bo1;\n                            best2 = bo2;\n                        }\n                    }\n                }\n            }\n    \n            newOrder.add(best1);\n            newOrder.add(best2);\n    \n            remaining.remove(best1);\n            remaining.remove(best2);\n        }\n    \n        if(remaining.size() == 1) {\n            for(BasicOperator bo1 : remaining) {\n                newOrder.add(bo1);\n            }\n        }\n    \n        return newOrder;\n    }\n    \n    private java.util.Collection<BasicOperator> getNextJoin(java.util.Collection<BasicOperator> remainingJoins) {\n        java.util.Collection<BasicOperator> co = new java.util.LinkedList<BasicOperator>();\n        BasicOperator best1 = null;\n        BasicOperator best2 = null;\n        int minCommonVariables = -1;\n    \n        for(BasicOperator o1 : remainingJoins) {\n            for(BasicOperator o2 : remainingJoins) {\n                if(!o1.equals(o2)) {\n                    java.util.Collection<lupos.datastructures.items.Variable> v = new java.util.LinkedList<lupos.datastructures.items.Variable>();\n                    v.addAll(o1.getUnionVariables());\n                    v.retainAll(o2.getUnionVariables());\n    \n                    int commonVariables = v.size();\n    \n                    if(commonVariables > minCommonVariables) {\n                        minCommonVariables = commonVariables;\n                        best1 = o1;\n                        best2 = o2;\n                    }\n                }\n            }\n        }\n    \n        co.add(best1);\n        co.add(best2);\n    \n        return co;\n    }\n",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "if(this.join instanceof lupos.engine.operators.multiinput.optional.parallel.ParallelOptional || this.join instanceof lupos.engine.operators.multiinput.optional.parallel.MergeParallelOptional) {\n    return false;\n}\n\nreturn (this.join.getNumberOfOperands() > 2);",
          "use generated code": true
        },
        "replace method": {
          "code": "BasicOperator finalJoin = this.getBinaryJoin(this.join, _startNodes);\nfinalJoin.setSucceedingOperators(this.join.getSucceedingOperators());\n\nfor(OperatorIDTuple opIDt : finalJoin.getSucceedingOperators()) {\n    opIDt.getOperator().removePrecedingOperator(this.join);\n    opIDt.getOperator().addPrecedingOperator(finalJoin);\n}\n\nthis.deleteNodeFromStartNodeMapNullCheck(this.join, _startNodes);",
          "additional code": "",
          "use generated code": false
        },
        "additional import declarations": ""
      },
      "documentation": {
        "show visual representation": false,
        "see also": {
          "rule packages": [],
          "rules": ["Optimizing Join Order"]
        },
        "short description": "This transformation rule generates only binary joins.",
        "left image": "",
        "long description": "The operator graph can contain joins with more than two operands. In this case, this transformation rule generates several join operators, which have only two operands (in a deep right-tree) and which first join those triple patterns, which have the smallest number of not already bound variables. In the case of the Stream approach, we must optimize before any read input data, and thus we cannot use statistics about them for the optimization of the join order. Note that there are more sophisticated join ordering optimization implemented for the other approaches, which use different kinds of estimations.",
        "use generated visual representation": true,
        "right image": "",
        "transition text": ""
      }
    },
    "Merge Memory Indexes": {
      "visual representation": {
        "left side": {
          "o2": {
            "position": [
              8,
              797
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "o1": {
            "position": [
              8,
              5
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {
            "o1": [{
              "id": -1,
              "to": "i",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING"
            }],
            "j": [{
              "id": -1,
              "to": "o2",
              "active": false,
              "id label": "",
              "mode": "ONLY_SUCCEEDING"
            }],
            "i": [{
              "id": -1,
              "to": "j",
              "active": false,
              "id label": "",
              "mode": "ALL_PRECEDING"
            }]
          },
          "j": {
            "position": [
              6,
              533
            ],
            "also subclasses": true,
            "start node": true,
            "class type": "Join",
            "op type": "RuleOperator"
          },
          "i": {
            "position": [
              5,
              269
            ],
            "also subclasses": true,
            "class type": "MemoryIndex",
            "op type": "RuleOperator"
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "o2": {
            "position": [
              5,
              467
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "o1": {
            "position": [
              5,
              5
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "i_new": {
            "position": [
              5,
              236
            ],
            "also subclasses": false,
            "class type": "MemoryIndex",
            "op type": "RuleOperator"
          },
          "connections": {
            "o1": [{
              "id": -1,
              "to": "i_new",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING"
            }],
            "i_new": [{
              "id": -1,
              "to": "o2",
              "active": false,
              "id label": "",
              "mode": "ONLY_SUCCEEDING"
            }]
          }
        }
      },
      "implementation": {
        "additional global java code": "",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "if(this._dim_0<=1)\r\n   return false;",
          "use generated code": true
        },
        "replace method": {
          "code": "        // remove obsolete connections...\n        for(lupos.engine.operators.index.memoryindex.MemoryIndex _parent : this.i) {\n            _parent.removeSucceedingOperator(this.j);\n            this.j.removePrecedingOperator(_parent);\n        }\n\n        for(this._dim_0 = 0; this._dim_0 < this.o1.length; this._dim_0 += 1) {\n            this.o1[this._dim_0].removeSucceedingOperator(this.i[this._dim_0]);\n            this.i[this._dim_0].removePrecedingOperator(this.o1[this._dim_0]);\n        }\n        this.j.removeSucceedingOperator(this.o2);\n        this.o2.removePrecedingOperator(this.j);\n\n        // add new operators...\n        lupos.engine.operators.index.memoryindex.MemoryIndex i_new = null;\n        i_new = new lupos.engine.operators.index.memoryindex.MemoryIndex(this.i[0].getIndexCollection());\n\n\n        // add new connections...\n        i_new.addSucceedingOperator(this.o2);\n        this.o2.addPrecedingOperator(i_new);\n\n        this.o1[0].addSucceedingOperator(i_new);\n        i_new.addPrecedingOperator(this.o1[0]);\n\n\n        // delete unreachable operators...\n        this.deleteOperatorWithoutParentsRecursive(this.j, _startNodes);\n        for(this._dim_0 = 0; this._dim_0 < i.length; this._dim_0 += 1) {\n            this.deleteOperatorWithoutParentsRecursive(this.i[this._dim_0], _startNodes);\n        }\n\n\n\n        // additional replace method code...\n        i_new.setTriplePatterns(new java.util.LinkedList<lupos.engine.operators.tripleoperator.TriplePattern>());\n        for(lupos.engine.operators.index.memoryindex.MemoryIndex index : this.i) {\n            i_new.getTriplePattern().addAll(index.getTriplePattern());\n        \n            i_new.getIntersectionVariables().addAll(index.getIntersectionVariables());\n            i_new.getUnionVariables().addAll(index.getUnionVariables());\n        }",
          "additional code": "",
          "use generated code": false
        },
        "additional import declarations": ""
      },
      "documentation": {
        "show visual representation": true,
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "A Join operator joining several Memory Index Scans is replaced by one Memory Index Scan containing all Triple Patterns of the Memory Index Scan operators of the Join operator.",
        "left image": "",
        "long description": "",
        "use generated visual representation": true,
        "right image": "",
        "transition text": ""
      }
    },
    "Optimizing Join Order": {
      "visual representation": {
        "left side": {},
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {}
      },
      "implementation": {
        "additional global java code": "",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "",
          "use generated code": true
        },
        "replace method": {
          "code": "",
          "additional code": "",
          "use generated code": true
        },
        "additional import declarations": ""
      },
      "documentation": {
        "show visual representation": false,
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "The join order is optimized by etimating the cardinality of the result of single joins and first joining those, which have the estimated smallest number of intermediate results.",
        "left image": "",
        "long description": "We have two different types of query optimizers.\n\nThe first type is a simple query optimizer, which generates right-order trees for the overall join computation. This type of query optimizer just joins the intermediate result of a previous join with the result of that triple pattern, which have (a) the smallest number of results, (b) the smallest number of new bound variables, or (c) a combination of both, i.e. the query optimizers uses (b) as primary and (c) as secondary criterion. This query optimizer is used for the Index-approach (except with the optimization option set to BINARY). The Stream approach can only use (b) as criterion as the query has to be optimized before the data arrives as stream.\n\nThe previous type of query optimizer does not consider the number of results after one or more join computations, which considers our second type of query optimizer. This second type of query optimizer is used for the RDF3X (- Presorting), Hexastore (- Presorting) and Index (with optimization option set to BINARY) approaches.\n\nFor the second type of query optimizer, we use equi-depth histograms [1] for the join cardinality estimation in order to calculate the cost of each join and thus the overall cost of a concrete plan. We employ the technique of the dynamic programming for generating the execution plan with the optimal join order, i.e. our query optimizer composes a new best solution by considering the best solutions of its subproblems. In more detail, for a set S of triple patterns, our query optimizer builds every possible disjoint subsets S1 and S2, the union of which is S, i.e. S = S1 union S2. For each of these subsets S1 and S2, our query optimizer looks up the best solutions for their join orderings, which has been computed earlier, and calculates a new cost for this solution. Among these solutions, our query optimizer chooses the ones with the minimal costs for the overall solution for S.\n\nA merge join can be computed using different collation orders. For example, a merge join can be applied to compute the triple patterns ?a <type> ?b and <book> ?b ?a, using either ?a as the primary order, or ?b as the primary order. In order to reduce the number of intermediate plans, our query optimizer only checks whether or not a merge join can be applied, but does not store the collation orders used to compute the join at this step. The used collation orders for answering the single triple patterns are fixed (and stored) in the last step, when the whole plan is considered.\n\nSince merge joins without additional sorting phases are very cheap, our query optimizer chooses merge joins without additional sorting phases as much as possible.\n\n[1] Piatetsky-Shapiro G., Connell C.: Accurate Estimation of the Number of Tuples Satisfying a Condition. SIGMOD Conf., 1984.",
        "use generated visual representation": true,
        "right image": "",
        "transition text": ""
      }
    },
    "Remove Empty Index": {
      "visual representation": {
        "left side": {
          "o": {
            "position": [
              26,
              18
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {"o": [{
            "id": -1,
            "to": "i",
            "active": false,
            "id label": "",
            "mode": "ONLY_PRECEDING"
          }]},
          "i": {
            "position": [
              35,
              278
            ],
            "also subclasses": true,
            "start node": true,
            "class type": "Index",
            "op type": "RuleOperator"
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {"o": {
          "position": [
            18,
            20
          ],
          "also subclasses": false,
          "class type": "Operator",
          "op type": "RuleOperator"
        }}
      },
      "implementation": {
        "additional global java code": "",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "if(this.i instanceof lupos.rif.operator.PredicateIndex\n    || this.i instanceof lupos.rif.operator.BooleanIndex\n    || this.i instanceof lupos.engine.operators.index.EmptyIndex\n    || this.i instanceof lupos.rif.operator.IteratorIndex\n    || (!this.i.getPrecedingOperators().isEmpty()\n        && !this.i.getPrecedingOperators().get(0).getSucceedingOperators().isEmpty()\n        && this.i.getPrecedingOperators().get(0).getSucceedingOperators().get(0).getOperator() instanceof lupos.rif.operator.InsertTripleIndex)) {\n\t\t\t\t\treturn false;\n}\n\nlupos.datastructures.queryresult.QueryResult qr = null;\n\t\t\t\tif (this.i instanceof lupos.engine.operators.index.memoryindex.MemoryIndex) {\n\t\t\t\t\tfinal lupos.engine.operators.index.memoryindex.MemoryIndex temp = new lupos.engine.operators.index.memoryindex.MemoryIndex(this.i.getIndexCollection());\n\t\t\t\t\tboolean found = false;\n\t\t\t\t\tfor (lupos.engine.operators.tripleoperator.TriplePattern pat : ((lupos.engine.operators.index.memoryindex.MemoryIndex) this.i).getTriplePattern()) {\n\t\t\t\t\t\ttemp.setTriplePatterns(java.util.Arrays.asList(pat));\n\t\t\t\t\t\tlupos.datastructures.queryresult.QueryResult qrtemp = temp.join(this.i.getIndexCollection().dataset);\n\t\t\t\t\t\tif (qrtemp != null && qrtemp.oneTimeIterator().hasNext()) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!found) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n                    return false;\n\t\t\t\t} else {\n\t\t\t\t\tqr = this.i.join(this.i.getIndexCollection().dataset);\n                }\n\t\t\t\tif (qr != null) {\n\t\t\t\t\tfinal java.util.Iterator<lupos.datastructures.bindings.Bindings> pib = qr.oneTimeIterator();\n\t\t\t\t\tif (pib.hasNext()) {\n\t\t\t\t\t\tif (pib instanceof lupos.datastructures.queryresult.ParallelIterator) {\n\t\t\t\t\t\t\t((lupos.datastructures.queryresult.ParallelIterator) pib).close();\n                        }\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (pib instanceof lupos.datastructures.queryresult.ParallelIterator) {\n\t\t\t\t\t\t((lupos.datastructures.queryresult.ParallelIterator) pib).close();\n                    }\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\treturn true;\n\t\t\t\t}",
          "use generated code": true
        },
        "replace method": {
          "code": "",
          "additional code": "",
          "use generated code": true
        },
        "additional import declarations": ""
      },
      "documentation": {
        "show visual representation": true,
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "This transformation rule checks an index scan operator for empty result. In case of empty result, the index scan operator is removed, which can lead to an enormous simplification of the operator graph.",
        "left image": "",
        "long description": "",
        "use generated visual representation": true,
        "right image": "",
        "transition text": ""
      }
    },
    "Remove Distinct": {
      "visual representation": {
        "left side": {
          "o2": {
            "position": [
              15,
              533
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "d": {
            "position": [
              9,
              269
            ],
            "also subclasses": false,
            "class type": "Distinct",
            "op type": "RuleOperator"
          },
          "o1": {
            "position": [
              5,
              5
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {
            "d": [{
              "id": -1,
              "to": "o2",
              "active": true,
              "id label": "a",
              "mode": "ALL_SUCCEEDING"
            }],
            "o1": [{
              "id": -1,
              "to": "d",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING"
            }]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "o2": {
            "position": [
              5,
              236
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "o1": {
            "position": [
              5,
              5
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {"o1": [{
            "id": -1,
            "to": "o2",
            "active": true,
            "id label": "a",
            "mode": "ALL_SUCCEEDING"
          }]}
        }
      },
      "implementation": {
        "additional global java code": "",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "return !(this.d.getSucceedingOperators().get(0).getOperator() instanceof lupos.engine.operators.singleinput.Result);",
          "use generated code": true
        },
        "replace method": {
          "code": "",
          "additional code": "",
          "use generated code": true
        },
        "additional import declarations": ""
      },
      "documentation": {
        "show visual representation": true,
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "Removes all early duplicate eliminations...",
        "left image": "",
        "long description": "",
        "use generated visual representation": true,
        "right image": "",
        "transition text": ""
      }
    },
    "Factor out OR in Filter": {
      "visual representation": {
        "left side": {
          "f": {
            "position": [
              68,
              807
            ],
            "also subclasses": false,
            "start node": true,
            "class type": "Filter",
            "op type": "RuleOperator"
          },
          "op": {
            "position": [
              57,
              5
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "o": {
            "position": [
              46,
              1071
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {
            "f": [{
              "id": -1,
              "to": "o",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }],
            "op": [{
              "id": -1,
              "to": "i",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "j": [{
              "id": -1,
              "to": "f",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }],
            "i": [{
              "id": -1,
              "to": "j",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }]
          },
          "j": {
            "conditions": "",
            "position": [
              16,
              533
            ],
            "also subclasses": false,
            "class type": "Filter",
            "op type": "JumpOverOperator",
            "cardinality": "*"
          },
          "i": {
            "position": [
              68,
              269
            ],
            "also subclasses": true,
            "class type": "Index",
            "op type": "RuleOperator"
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "f": {
            "position": [
              83,
              698
            ],
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator"
          },
          "u": {
            "position": [
              644,
              926
            ],
            "also subclasses": false,
            "class type": "Union",
            "op type": "RuleOperator"
          },
          "op": {
            "position": [
              57,
              5
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "o": {
            "position": [
              646,
              1155
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {
            "f": [{
              "id": -1,
              "to": "u",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "u": [{
              "id": -1,
              "to": "o",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }],
            "op": [{
              "id": -1,
              "to": "i",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "j": [{
              "id": -1,
              "to": "f",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }],
            "f2": [{
              "id": -1,
              "to": "u",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "i": [{
              "id": -1,
              "to": "j",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }]
          },
          "j": {
            "conditions": "",
            "position": [
              31,
              467
            ],
            "also subclasses": false,
            "class type": "Filter",
            "op type": "JumpOverOperator",
            "cardinality": "*"
          },
          "f2": {
            "position": [
              1238,
              691
            ],
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator"
          },
          "i": {
            "position": [
              109,
              236
            ],
            "also subclasses": false,
            "class type": "Index",
            "op type": "RuleOperator"
          }
        }
      },
      "implementation": {
        "additional global java code": "int operandID;",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "lupos.sparql1_1.Node n = this.f.getNodePointer();\n\nthis.operandID = this.f.getOperatorIDTuple(this.o).getId();\n\nif(this.i.getSucceedingOperators().size()>1)\n   return false;\n            \nif(n.jjtGetNumChildren() > 0) {\n    n = n.jjtGetChild(0);\n\n    return (n instanceof lupos.sparql1_1.ASTOrNode);\n}",
          "use generated code": true
        },
        "replace method": {
          "code": "",
          "additional code": "// --- update index - begin ---\nlupos.engine.operators.index.BasicIndex i2 = (lupos.engine.operators.index.BasicIndex) this.i.clone();\nthis.addNodeToStartNodeMapNullCheck(i2, _startNodes);\n\njava.util.LinkedList<lupos.engine.operators.tripleoperator.TriplePattern> lltp = new java.util.LinkedList<lupos.engine.operators.tripleoperator.TriplePattern>();\n\nfor(lupos.engine.operators.tripleoperator.TriplePattern tp : this.i.getTriplePattern()) {\n    lltp.add(tp.clone());\n}\n\ni2.setTriplePatterns(lltp);\n\nthis.op.addSucceedingOperator(i2);\ni2.setPrecedingOperator(this.op);\n// --- update index - end ---\n\n\n// --- update filter - begin ---\nlupos.sparql1_1.Node n = this.f.getNodePointer();\n\nn = n.jjtGetChild(0);\nlupos.sparql1_1.ASTFilterConstraint node1 = new lupos.sparql1_1.ASTFilterConstraint(0);\nlupos.sparql1_1.ASTFilterConstraint node2 = new lupos.sparql1_1.ASTFilterConstraint(1);\nnode1.jjtAddChild(n.jjtGetChild(0), 0);\nnode2.jjtAddChild(n.jjtGetChild(1), 0);\nn.jjtGetChild(0).jjtSetParent(node1);\nn.jjtGetChild(1).jjtSetParent(node2);\n\nthis.f.setNodePointer(node1);\nf2.setNodePointer(node2);\n\nf2.setCollectionForExistNodes(this.f.getCollectionForExistNodes());\nf2.setEvaluator(this.f.getUsedEvaluationVisitor().getEvaluator());\nf2.getUsedEvaluationVisitor().setEvaluator(this.f.getUsedEvaluationVisitor().getEvaluator());\n\n\nf2.setIntersectionVariables(this.f.getIntersectionVariables());\nf2.setUnionVariables(this.f.getUnionVariables());\n// --- update filter - end ---\n\n\n// --- clone jump-over operators - begin ---\nBasicOperator tmpOp = this.i.getSucceedingOperators().get(0).getOperator();\nBasicOperator parentOp = i2;\n\nwhile(!tmpOp.equals(this.f)) {\n    BasicOperator newOp = tmpOp.clone();\n    this.addNodeToStartNodeMapNullCheck(newOp, _startNodes);\n\n    parentOp.setSucceedingOperator(new lupos.engine.operators.OperatorIDTuple(newOp, 0));\n    newOp.setPrecedingOperator(parentOp);\n\n    parentOp = tmpOp;\n    tmpOp = tmpOp.getSucceedingOperators().get(0).getOperator();\n}\n\nparentOp.setSucceedingOperator(new lupos.engine.operators.OperatorIDTuple(f2, 0));\nf2.addPrecedingOperator(parentOp);\n// --- clone jump-over operators - end ---\nu.getOperatorIDTuple(this.o).setId(this.operandID);\nu.setIntersectionVariables(new HashSet<Variable>(this.f.getIntersectionVariables()));\nu.setUnionVariables(new HashSet<Variable>(this.f.getUnionVariables()));\n",
          "use generated code": true
        },
        "additional import declarations": "import lupos.datastructures.items.Variable;"
      },
      "documentation": {
        "show visual representation": true,
        "see also": {
          "rule packages": [],
          "rules": [
            "Variable Propagation",
            "Constant Propagation of Filter in Index"
          ]
        },
        "short description": "This rule implements constant propagation for a set of constants.",
        "left image": "",
        "long description": "If there Filter expressions with a equal-comparision of a variable with a set of constant values, e.g. Filter(?X=&lt;http://myURL.de&gt; || ?X=\"hello\" || ?X=\"myContent\"^^myURL:myDatatype), then this constant values can be propagated to preceding (RDF3X/Hexastore) Index operators in certain cases. Afterwards, the corresponding variable (here ?X) must be bound with the constant values (here &lt;http://myURL.de&gt;, \"hello\" and \"myContent\"^^myURL:myDatatype), e.g. ?Y ?Z ?X. Filter(?X=&lt;http://myURL.de&gt; || ?X=\"hello\" || ?X=\"myContent\"^^myURL:myDatatype) is transformed into {?Y ?Z &lt;http://myURL.de&gt;. AddBinding(?X=&lt;http://myURL.de&gt;)} UNION {?Y ?Z \"hello\". AddBinding(?X=\"hello\")} UNION { ?Y ?Z \"myContent\"^^myURL:myDatatype. AddBinding(?X=\"myContent\"^^myURL:myDatatype)}. However, there are problems with this approach if one of the constant values can be value-equal with another constant value using a different representation, e.g. +01^^xsd:int is value-equal, but not identical to 1^^xsd:int. Thus, this transformation rule is not applied whenever one of the constant values is a numerical value or a language tagged literal.\n\nThe following figure contains the graphical representation of the transformation rule.",
        "use generated visual representation": true,
        "right image": "",
        "transition text": "c1, ..., cn are neither numerical values nor language tagged literals"
      }
    },
    "Physical Optimization Rule": {
      "visual representation": {
        "left side": {},
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {}
      },
      "implementation": {
        "additional global java code": "",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "",
          "use generated code": true
        },
        "replace method": {
          "code": "",
          "additional code": "",
          "use generated code": true
        },
        "additional import declarations": ""
      },
      "documentation": {
        "show visual representation": false,
        "see also": {
          "rule packages": ["Physical Optimization"],
          "rules": []
        },
        "short description": "Physical optimization aims to choose the algorithm with the best estimated execution times in the context of the operator for each operator in the operator graph.",
        "left image": "",
        "long description": "This transformation rule considers several aspects.\n\nThis transformation rule chooses the concrete algorithm for a logical operator according to the option, if the memory-based variant of our prototype is used (where all the data remains in the main memory), or the disk-based variant is used (where the indices and the intermediate results on demand are stored on disk).\n\nFurthermore, this transformation rule considers specific preferences of the user for specific algorithms. This means that the user can specify (e.g. per command line option) to use e.g. the DBMergeSortedBagMergeJoin as default Join algorithm, which is considered in this transformation rule.\n\nFor the Sort operator, the transformation rule checks, whether the intermediate result is already sorted in the correct way (or can be retrieved in a sorted way), such that the Sort operator can be left out.\n\nFor the Distinct operator, this transformation rule checks whether or not the intermediate data is sorted in the correct way, such that the effcient SortedDataDistinct operator can be used.",
        "use generated visual representation": true,
        "right image": "",
        "transition text": ""
      }
    },
    "HashSetNonBlockingDistinctWithIndexAccess": {
      "visual representation": {
        "left side": {
          "d": {
            "position": [
              5,
              276
            ],
            "also subclasses": true,
            "class type": "Distinct",
            "op type": "RuleOperator"
          },
          "connections": {"i": [{
            "id": -1,
            "to": "d",
            "active": false,
            "id label": "",
            "mode": "EXISTS"
          }]},
          "i": {
            "position": [
              5,
              5
            ],
            "also subclasses": true,
            "class type": "Index",
            "op type": "RuleOperator"
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {}
      },
      "implementation": {
        "additional global java code": "",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "// check if there is only one index scan operator\r\nif(this.d instanceof HashSetNonBlockingDistinctWithIndexAccess){\r\n\treturn false;\r\n}\r\nfor(BasicOperator prec: this.d.getPrecedingOperators()){\r\n\tif(prec instanceof lupos.engine.operators.index.BasicIndex){\r\n\t\tif(!prec.equals(this.i)){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n}\r\n",
          "use generated code": true
        },
        "replace method": {
          "code": "HashSetNonBlockingDistinctWithIndexAccess distinct_new = new HashSetNonBlockingDistinctWithIndexAccess(this.i);\r\nthis.d.replaceWith(distinct_new);\r\nthis.deleteNodeFromStartNodeMapNullCheck(this.d, _startNodes);\r\nthis.addNodeToStartNodeMapNullCheck(distinct_new, _startNodes);\r\ndistinct_new.setPrecedingOperators(this.d.getPrecedingOperators());\r\ndistinct_new.setSucceedingOperators(this.d.getSucceedingOperators());\r\n// now correct operandID of BasicIndex operand to 0 and the other to 1 (requirement of the HashSetNonBlockingDistinctWithIndexAccess-operator!)\r\nfor(BasicOperator bo: distinct_new.getPrecedingOperators()){\r\n\tint operandID = (bo instanceof lupos.engine.operators.index.BasicIndex)? 0: 1;\r\n\tbo.getOperatorIDTuple(distinct_new).setId(operandID);\r\n}",
          "additional code": "",
          "use generated code": false
        },
        "additional import declarations": "import lupos.engine.operators.singleinput.modifiers.distinct.HashSetNonBlockingDistinctWithIndexAccess;"
      },
      "documentation": {
        "show visual representation": true,
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "",
        "left image": "",
        "long description": "",
        "use generated visual representation": true,
        "right image": "",
        "transition text": ""
      }
    },
    "SortLimit over Sort": {
      "visual representation": {
        "left side": {
          "limit": {
            "position": [
              51,
              828
            ],
            "also subclasses": true,
            "start node": true,
            "class type": "Limit",
            "op type": "RuleOperator"
          },
          "sort": {
            "position": [
              51,
              276
            ],
            "also subclasses": true,
            "class type": "Sort",
            "op type": "RuleOperator"
          },
          "above": {
            "position": [
              51,
              5
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {
            "sort": [{
              "id": -1,
              "to": "offset",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }],
            "above": [{
              "id": -1,
              "to": "sort",
              "active": true,
              "id label": "a",
              "mode": "ALL_PRECEDING"
            }],
            "offset": [{
              "id": -1,
              "to": "limit",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }]
          },
          "offset": {
            "conditions": "",
            "position": [
              5,
              547
            ],
            "also subclasses": true,
            "class type": "Offset",
            "op type": "JumpOverOperator",
            "cardinality": "*"
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "limit": {
            "position": [
              5,
              925
            ],
            "also subclasses": false,
            "class type": "Limit",
            "op type": "RuleOperator"
          },
          "sort": {
            "position": [
              5,
              465
            ],
            "also subclasses": false,
            "class type": "Sort",
            "op type": "RuleOperator"
          },
          "sortLimit": {
            "position": [
              5,
              235
            ],
            "also subclasses": false,
            "class type": "SortLimit",
            "op type": "RuleOperator"
          },
          "above": {
            "position": [
              5,
              5
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {
            "sort": [{
              "id": -1,
              "to": "offset",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }],
            "sortLimit": [{
              "id": 0,
              "to": "sort",
              "active": true,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }],
            "above": [{
              "id": -1,
              "to": "sortLimit",
              "active": true,
              "id label": "a",
              "mode": "ALL_PRECEDING"
            }],
            "offset": [{
              "id": -1,
              "to": "limit",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }]
          },
          "offset": {
            "conditions": "",
            "position": [
              9,
              681
            ],
            "also subclasses": false,
            "class type": "Offset",
            "op type": "JumpOverOperator",
            "cardinality": "*"
          }
        }
      },
      "implementation": {
        "additional global java code": "private final static int MAXLIMIT = 1000;\r\nprivate int limitSortLimit = 0;",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "for(BasicOperator bo:above){\r\n\tif(bo instanceof SortLimit){\r\n\t\treturn false;\r\n\t}\r\n}\r\nthis.limitSortLimit = this.limit.getLimit();\r\nif(this.offset_begin!=null && this.offset_begin instanceof Offset){\r\n\tthis.limitSortLimit += ((Offset)this.offset_begin).getOffset();\r\n}\r\nif(this.limitSortLimit > MAXLIMIT){\r\n\treturn false;\r\n}",
          "use generated code": true
        },
        "replace method": {
          "code": "",
          "additional code": "sortLimit.setLimit(this.limitSortLimit);\r\nsortLimit.setComparator(this.sort.getComparator());\r\n\r\nfinal Collection<Variable> cv = new LinkedList<Variable>();\r\ncv.addAll(this.sort.getIntersectionVariables());\r\nsortLimit.setIntersectionVariables(cv);\r\nsortLimit.setUnionVariables(cv);",
          "use generated code": true
        },
        "additional import declarations": "import java.util.Collection;\r\nimport java.util.LinkedList;\r\n\r\nimport lupos.engine.operators.singleinput.modifiers.Offset;\r\nimport lupos.engine.operators.singleinput.modifiers.SortLimit;\r\nimport lupos.engine.operators.singleinput.sort.Comp;\r\nimport lupos.datastructures.items.Variable;"
      },
      "documentation": {
        "show visual representation": true,
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "The SortLimit operator computes the k smallest elements. This transformation rule introduces the SortLimit operator for not sorting all the elements in the case of a sort opertion in combination with a limit operation.",
        "left image": "",
        "long description": "",
        "use generated visual representation": true,
        "right image": "",
        "transition text": ""
      }
    },
    "Projection Over Sort": {
      "visual representation": {
        "left side": {
          "sort": {
            "position": [
              15,
              318
            ],
            "also subclasses": false,
            "start node": true,
            "class type": "Sort",
            "op type": "RuleOperator"
          },
          "projection": {
            "position": [
              14,
              611
            ],
            "also subclasses": false,
            "class type": "Projection",
            "op type": "RuleOperator"
          },
          "below": {
            "position": [
              15,
              915
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "above": {
            "position": [
              17,
              5
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {
            "sort": [{
              "id": -1,
              "to": "projection",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "projection": [{
              "id": -1,
              "to": "below",
              "active": true,
              "id label": "b",
              "mode": "ALL_SUCCEEDING"
            }],
            "above": [{
              "id": -1,
              "to": "sort",
              "active": true,
              "id label": "a",
              "mode": "ALL_PRECEDING"
            }]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "sort": {
            "position": [
              21,
              534
            ],
            "also subclasses": false,
            "class type": "Sort",
            "op type": "RuleOperator"
          },
          "projection": {
            "position": [
              3,
              279
            ],
            "also subclasses": false,
            "class type": "Projection",
            "op type": "RuleOperator"
          },
          "below": {
            "position": [
              14,
              787
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "above": {
            "position": [
              17,
              5
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {
            "sort": [{
              "id": -1,
              "to": "below",
              "active": true,
              "id label": "b",
              "mode": "ALL_SUCCEEDING"
            }],
            "projection": [{
              "id": -1,
              "to": "sort",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "above": [{
              "id": -1,
              "to": "projection",
              "active": true,
              "id label": "a",
              "mode": "ALL_PRECEDING"
            }]
          }
        }
      },
      "implementation": {
        "additional global java code": "",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "final java.util.Collection<lupos.datastructures.items.Variable> sortCrit = this.sort.getSortCriterium();\r\nif (sortCrit != null && this.projection.getProjectedVariables().containsAll(sortCrit))\r\n\treturn true;\r\nelse return false;",
          "use generated code": true
        },
        "replace method": {
          "code": "",
          "additional code": "final java.util.Collection<lupos.datastructures.items.Variable> cv = new java.util.LinkedList<lupos.datastructures.items.Variable>();\r\ncv.addAll(this.projection.getProjectedVariables());\r\nthis.sort.setIntersectionVariables(cv);\r\nthis.sort.setUnionVariables(cv);",
          "use generated code": true
        },
        "additional import declarations": ""
      },
      "documentation": {
        "show visual representation": true,
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "If the list of variables of the projection operator contains all variables of the sort criterium, then we can move the projection operator above the Sort criterium.",
        "left image": "",
        "long description": "",
        "use generated visual representation": true,
        "right image": "",
        "transition text": ""
      }
    },
    "Remove Unnecessary ConstructPredicate": {
      "visual representation": {
        "left side": {
          "t": {
            "position": [
              31,
              269
            ],
            "also subclasses": false,
            "class type": "TriplePattern",
            "op type": "RuleOperator"
          },
          "c": {
            "position": [
              25,
              5
            ],
            "also subclasses": false,
            "class type": "ConstructPredicate",
            "op type": "RuleOperator"
          },
          "connections": {"c": [{
            "id": -1,
            "to": "t",
            "active": false,
            "id label": "",
            "mode": "ONLY_SUCCEEDING"
          }]}
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {"t": {
          "position": [
            18,
            18
          ],
          "also subclasses": false,
          "class type": "TriplePattern",
          "op type": "RuleOperator"
        }}
      },
      "implementation": {
        "additional global java code": "",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "",
          "use generated code": true
        },
        "replace method": {
          "code": "",
          "additional code": "",
          "use generated code": true
        },
        "additional import declarations": ""
      },
      "documentation": {
        "show visual representation": true,
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "If a ConstructPredicate has only a Triple Pattern as succeeding operator, the Triple Pattern Pattern operator will not have any result for the output of a ConstructPredicate and can be therefore removed.",
        "left image": "",
        "long description": "",
        "use generated visual representation": true,
        "right image": "",
        "transition text": ""
      }
    },
    "Replace Generate Pat": {
      "visual representation": {
        "left side": {
          "g": {
            "position": [
              5,
              5
            ],
            "also subclasses": false,
            "class type": "Generate",
            "op type": "RuleOperator"
          },
          "t": {
            "position": [
              5,
              269
            ],
            "also subclasses": false,
            "class type": "TriplePattern",
            "op type": "RuleOperator"
          },
          "connections": {"g": [{
            "id": -1,
            "to": "t",
            "active": false,
            "id label": "",
            "mode": "ONLY_SUCCEEDING"
          }]}
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {}
      },
      "implementation": {
        "additional global java code": "",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "",
          "use generated code": true
        },
        "replace method": {
          "code": "final lupos.datastructures.items.Item[] patItems = this.t.getItems();\n\t\tfinal lupos.datastructures.items.Item[] generateItems = this.g.getValueOrVariable();\n\n\t\tlupos.engine.operators.singleinput.Filter filter = null;\n\t\tfinal lupos.engine.operators.singleinput.ReplaceVar replaceVar = new lupos.engine.operators.singleinput.ReplaceVar();\n\t\treplaceVar.setIntersectionVariables(new java.util.HashSet<lupos.datastructures.items.Variable>());\n\t\treplaceVar.setUnionVariables(replaceVar.getIntersectionVariables());\n\n\t\tfinal java.util.LinkedList<lupos.datastructures.items.Variable> addBindingsVar = new java.util.LinkedList<lupos.datastructures.items.Variable>();\n\t\tfinal java.util.LinkedList<lupos.datastructures.items.literal.Literal> addBindingsLit = new java.util.LinkedList<lupos.datastructures.items.literal.Literal>();\n\n\t\tString filterConstraint = \"Filter( \";\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfinal lupos.datastructures.items.Item patItem = patItems[i];\n\t\t\tfinal lupos.datastructures.items.Item generateItem = generateItems[i];\n\t\t\tif ((!patItem.isVariable()) && generateItem.isVariable()) {\n\t\t\t\tfilterConstraint += generateItems[i].toString() + \" = \"\n\t\t\t\t\t\t+ patItems[i].toString() + \" && \";\n\t\t\t} else if (patItem.isVariable() && generateItem.isVariable()) {\n\t\t\t\treplaceVar.addSubstitution((lupos.datastructures.items.Variable) patItem,\n\t\t\t\t\t\t(lupos.datastructures.items.Variable) generateItem);\n\t\t\t\treplaceVar.getIntersectionVariables().add((lupos.datastructures.items.Variable) patItem);\n\t\t\t} else if (patItem.isVariable() && (!generateItem.isVariable())) {\n\t\t\t\taddBindingsVar.add((lupos.datastructures.items.Variable) patItem);\n\t\t\t\taddBindingsLit.add((lupos.datastructures.items.literal.Literal) generateItem);\n\t\t\t} else if (!patItem.isVariable() && !generateItem.isVariable()\n\t\t\t\t\t&& !generateItem.equals(patItem)) {\n\t\t\t\t// cannot match, remove generate.\n\t\t\t\tfor (final BasicOperator parent : this.g.getPrecedingOperators())\n\t\t\t\t\tparent.removeSucceedingOperator(this.g);\n\t\t\t\tthis.g.getPrecedingOperators().clear();\n\t\t\t\tthis.g.removeFromOperatorGraph();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// If (?x = ?a) and (?x = ?b) then (valueOf(?a) = value(?b)) must be\n\t\t// fulfilled\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tfor (int x = i + 1; x < 3; x++) {\n\t\t\t\tif (patItems[i].equals(patItems[x])) {\n\t\t\t\t\tfilterConstraint += generateItems[i].toString() + \" = \"\n\t\t\t\t\t\t\t+ generateItems[x].toString() + \" && \";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!filterConstraint.equals(\"Filter( \")) {\n\t\t\tfilterConstraint = filterConstraint.substring(0,\n\t\t\t\t\tfilterConstraint.length() - 3)\n\t\t\t\t\t+ \") \";\n\n\t\t\ttry {\n\t\t\t\tfinal lupos.sparql1_1.ASTFilterConstraint ASTfilter = (lupos.sparql1_1.ASTFilterConstraint) lupos.sparql1_1.SPARQL1_1Parser\n\t\t\t\t\t\t.parseFilter(filterConstraint);\n\t\t\t\tfilter = new lupos.engine.operators.singleinput.Filter(ASTfilter);\n\t\t\t} catch (final Exception e) {\n\t\t\t\tSystem.err\n\t\t\t\t\t\t.println(\"This should never happen in RuleReplaceGenPat!\");\n\t\t\t\tSystem.err.println(e);\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\t// Only Operators with a not empty definition are put into the\n\t\t// operatorgraph\n\t\tfinal java.util.LinkedList<BasicOperator> order = new java.util.LinkedList<BasicOperator>();\n\t\tif (filter != null) {\n\t\t\torder.add(filter);\n\t\t}\n\n\t\tfinal int substVar = replaceVar.getSubstitutionsVariableLeft().size();\n\n\t\tif (substVar > 0) {\n\t\t\torder.add(replaceVar);\n\t\t} else {\n\t\t\tfinal lupos.engine.operators.singleinput.Projection p = new lupos.engine.operators.singleinput.Projection();\n\t\t\tp.setIntersectionVariables(new java.util.HashSet<lupos.datastructures.items.Variable>());\n\t\t\tp.setUnionVariables(p.getUnionVariables());\n\t\t\torder.add(p);\n\t\t}\n\t\tif (addBindingsVar.size() > 0) {\n\t\t\tfinal java.util.Iterator<lupos.datastructures.items.literal.Literal> lit_it = addBindingsLit.iterator();\n\t\t\tfinal java.util.HashSet<lupos.datastructures.items.Variable> hsv = new java.util.HashSet<lupos.datastructures.items.Variable>();\n\t\t\thsv.addAll(replaceVar.getUnionVariables());\n\t\t\tfor (final lupos.datastructures.items.Variable v : addBindingsVar) {\n\t\t\t\tfinal lupos.engine.operators.singleinput.AddBinding ab = new lupos.engine.operators.singleinput.AddBinding(v, lit_it.next());\n\t\t\t\thsv.add(v);\n\t\t\t\tab.setIntersectionVariables((java.util.HashSet<lupos.datastructures.items.Variable>) hsv.clone());\n\t\t\t\tab.setUnionVariables(ab.getIntersectionVariables());\n\t\t\t\torder.add(ab);\n\t\t\t}\n\t\t}\n\n\t\t// In case that Generate or TriplePattern has minimum one variable, than\n\t\t// minimum one operator has to be inserted\n\t\tif (order.size() > 0) {\n\t\t\tfinal java.util.List<BasicOperator> pres = (java.util.List<BasicOperator>) this.g.getPrecedingOperators();\n\t\t\tBasicOperator pre;\n\t\t\tfor (int i = 0; i < pres.size(); i++) {\n\t\t\t\tpre = pres.get(i);\n\t\t\t\tpre.addSucceedingOperator(new OperatorIDTuple(order.getFirst(),\n\t\t\t\t\t\t0));\n\t\t\t\tif (filter != null) {\n\t\t\t\t\tjava.util.Collection<lupos.datastructures.items.Variable> vars = filter\n\t\t\t\t\t\t\t.getIntersectionVariables();\n\t\t\t\t\tif (vars == null)\n\t\t\t\t\t\tvars = new java.util.HashSet<lupos.datastructures.items.Variable>();\n\t\t\t\t\tvars.addAll(pre.getIntersectionVariables());\n\t\t\t\t\tfilter.setIntersectionVariables(vars);\n\t\t\t\t\tfilter.setUnionVariables(vars);\n\t\t\t\t}\n\t\t\t\tpre.removeSucceedingOperator(this.g);\n\t\t\t\torder.getFirst().addPrecedingOperator(pre);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < order.size() - 1; i++) {\n\t\t\t\torder.get(i + 1).setPrecedingOperator(order.get(i));\n\t\t\t\torder.get(i).setSucceedingOperator(\n\t\t\t\t\t\tnew OperatorIDTuple(order.get(i + 1), 0));\n\t\t\t}\n\n\t\t\tfinal java.util.LinkedList<OperatorIDTuple> succs = (java.util.LinkedList<OperatorIDTuple>) this.t.getSucceedingOperators();\n\t\t\tfor (int i = 0; i < succs.size(); i++) {\n\t\t\t\tsuccs.get(i).getOperator()\n\t\t\t\t\t\t.addPrecedingOperator(order.getLast());\n\t\t\t}\n\n\t\t\tfinal java.util.LinkedList<OperatorIDTuple> sops = new java.util.LinkedList<OperatorIDTuple>();\n\t\t\tsops.addAll(this.t.getSucceedingOperators());\n\t\t\torder.getLast().setSucceedingOperators(sops);\n\t\t} else {\n\t\t\tfinal java.util.LinkedList<BasicOperator> pres = (java.util.LinkedList<BasicOperator>) this.g.getPrecedingOperators();\n\t\t\tfinal java.util.LinkedList<OperatorIDTuple> succs = (java.util.LinkedList<OperatorIDTuple>) this.t.getSucceedingOperators();\n\t\t\tBasicOperator pre;\n\t\t\tBasicOperator succ;\n\t\t\tfor (int i = 0; i < pres.size(); i++) {\n\t\t\t\tpre = pres.get(i);\n\t\t\t\tpre.removeSucceedingOperator(this.g);\n\t\t\t\tfor (int x = 0; x < succs.size(); x++) {\n\t\t\t\t\tpre.addSucceedingOperator(succs.get(x));\n\t\t\t\t\tsucc = succs.get(x).getOperator();\n\t\t\t\t\tsucc.removePrecedingOperator(this.t);\n\t\t\t\t\tsucc.addPrecedingOperator(pre);\n\t\t\t\t}\n\t\t\t}\n\t\t}",
          "additional code": "",
          "use generated code": false
        },
        "additional import declarations": ""
      },
      "documentation": {
        "show visual representation": false,
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "A generated triple is immediately consumed from a Triple Pattern. This transformation rule reduces this to the direct assignment of variables.",
        "left image": "",
        "long description": "",
        "use generated visual representation": true,
        "right image": "",
        "transition text": ""
      }
    },
    "Constant Propagation of Filter in Index": {
      "visual representation": {
        "left side": {
          "f": {
            "position": [
              52,
              543
            ],
            "also subclasses": false,
            "start node": true,
            "class type": "Filter",
            "op type": "RuleOperator"
          },
          "o": {
            "position": [
              54,
              807
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {
            "f": [{
              "id": -1,
              "to": "o",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "j": [{
              "id": -1,
              "to": "f",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }],
            "i": [{
              "id": -1,
              "to": "j",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }]
          },
          "j": {
            "conditions": "",
            "position": [
              19,
              269
            ],
            "also subclasses": true,
            "class type": "Operator",
            "op type": "JumpOverOperator",
            "cardinality": "*"
          },
          "i": {
            "position": [
              135,
              5
            ],
            "also subclasses": true,
            "class type": "Index",
            "op type": "RuleOperator"
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        },
        "right side": {
          "b": {
            "position": [
              40,
              467
            ],
            "also subclasses": false,
            "class type": "AddBinding",
            "op type": "RuleOperator"
          },
          "o": {
            "position": [
              63,
              698
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator"
          },
          "connections": {
            "b": [{
              "id": -1,
              "to": "o",
              "active": false,
              "id label": "",
              "mode": "EXISTS"
            }],
            "j": [{
              "id": -1,
              "to": "b",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }],
            "i": [{
              "id": -1,
              "to": "j",
              "active": false,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING"
            }]
          },
          "j": {
            "conditions": "",
            "position": [
              33,
              234
            ],
            "also subclasses": false,
            "class type": "Operator",
            "op type": "JumpOverOperator",
            "cardinality": "*"
          },
          "i": {
            "position": [
              42,
              5
            ],
            "also subclasses": false,
            "class type": "Index",
            "op type": "RuleOperator"
          }
        }
      },
      "implementation": {
        "additional global java code": "private lupos.datastructures.items.Variable var = null;\nprivate lupos.datastructures.items.literal.Literal constant = null;\nprivate int operandIDOfFilter;",
        "check method": {
          "start node": "Operator",
          "code": "",
          "additional code": "this.operandIDOfFilter = this.f.getOperatorIDTuple(o).getId();\n\nlupos.sparql1_1.Node n = this.f.getNodePointer();\n\nif(n.jjtGetNumChildren() > 0) {\n    n = n.jjtGetChild(0);\n\n    if(n instanceof lupos.sparql1_1.ASTEqualsNode) {\n        lupos.sparql1_1.Node left = n.jjtGetChild(0);\n        lupos.sparql1_1.Node right = n.jjtGetChild(1);\n\n        if(right instanceof lupos.sparql1_1.ASTVar) {\n            lupos.sparql1_1.Node tmp = left;\n            left = right;\n            right = tmp;\n        }\n\n        if(left instanceof lupos.sparql1_1.ASTVar) {\n            this.var = new lupos.datastructures.items.Variable(((lupos.sparql1_1.ASTVar) left).getName());\n\n            if(right instanceof lupos.sparql1_1.ASTQName\n               || right instanceof lupos.sparql1_1.ASTQuotedURIRef\n               || right instanceof lupos.sparql1_1.ASTFloatingPoint\n               || right instanceof lupos.sparql1_1.ASTInteger\n               || right instanceof lupos.sparql1_1.ASTStringLiteral\n               || right instanceof lupos.sparql1_1.ASTDoubleCircumflex) {\n                this.constant = lupos.datastructures.items.literal.LazyLiteral.getLiteral(right);\n\n                // Is it possible to loose the information of the original string representation?\n                if(this.constant instanceof lupos.datastructures.items.literal.TypedLiteralOriginalContent || this.constant instanceof lupos.datastructures.items.literal.LanguageTaggedLiteralOriginalLanguage) {\n                    return false;\n                }\n                else if(this.constant instanceof lupos.datastructures.items.literal.TypedLiteral) {\n                    if(lupos.engine.operators.singleinput.ExpressionEvaluation.Helper.isNumeric(((lupos.datastructures.items.literal.TypedLiteral) this.constant).getType())) {\n                        return false;\n                    } else {\n                        return true;\n                    }\n                } else {\n                    return true;\n                }\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    else {\n        return false;\n    }\n}\nelse {\n    return false;\n}",
          "use generated code": true
        },
        "replace method": {
          "code": "",
          "additional code": "this.i.replace(this.var, this.constant);\n\nb.setVar(this.var);\nb.setLiteral(this.constant);\n\nBasicOperator tmp = this.i;\n\nwhile(!tmp.equals(b)) {\n    tmp.getUnionVariables().remove(this.var);\n    tmp.getIntersectionVariables().remove(this.var);\n\n    tmp = tmp.getSucceedingOperators().get(0).getOperator();\n}\n\nb.setUnionVariables(this.f.getUnionVariables());\nb.setIntersectionVariables(this.f.getIntersectionVariables());\nb.getOperatorIDTuple(o).setId(this.operandIDOfFilter);",
          "use generated code": true
        },
        "additional import declarations": ""
      },
      "documentation": {
        "show visual representation": true,
        "see also": {
          "rule packages": [],
          "rules": [
            "Variable Propagation",
            "Factor out OR in Filter",
            "Constant Propagation of Filter in Triple Pattern"
          ]
        },
        "short description": "This rule implements constant propagation from Filter to Index.",
        "left image": "",
        "long description": "If there Filter expressions with a equal-comparision of a variable with a constant value, e.g. Filter(?X=&lt;http://myURL.de&gt;), then this constant value can be propagated to preceding (RDF3X/Hexastore) Index operators. Afterwards, the corresponding variable (here ?X) must be bound with the constant value (here &lt;http://myURL.de&gt;), e.g. ?X ?Y ?Z. Filter(?X=&lt;http://myURL.de&gt;) is transformed into &lt;http://myURL.de&gt; ?Y ?Z. AddBinding(?X=&lt;http://myURL.de&gt;). However, there are problems with this approach if the constant value can be value-equal with another constant value using a different representation, e.g. +01^^xsd:int is value-equal, but not identical to 1^^xsd:int. Thus, this transformation rule is not applied whenever the constant value is a numerical value or a language tagged literal.\n\nThe following figure contains the graphical representation of the transformation rule.",
        "use generated visual representation": true,
        "right image": "",
        "transition text": "c is neither a numerical value nor a language tagged literal"
      }
    }
  }
}