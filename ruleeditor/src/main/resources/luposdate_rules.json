{
  "associations": {
    "After Physical Optimization": [
      "Replace UsingJoinOptional With BasicIndexOptional",
      "Replace HashMapIndexJoin with HashMapIndexJoinOnLeftOperand",
      "Push Filter"
    ],
    "Correct Operatorgraph": [
      "Bound Variable in Optional",
      "Bound Variable in Union"
    ],
    "Logical Optimization": [
      "Factor out AND in Filter",
      "Push Filter",
      "Factor out OR in Filter",
      "ConstantPropagation of Filter in Index",
      "Constant Propagation of Filter in Index With Additional Operators Between",
      "Bound In Filter under Index",
      "Combine Unions",
      "Variable Propagation",
      "Projection Over Sort",
      "SortLimit over Sort",
      "Binary Join",
      "Optimizing Join Order",
      "Bound in Filter Under Add",
      "Unnecessary Optional Because of Projection"
    ],
    "Logical Optimization For Stream Engine": [
      "Factor out AND in Filter",
      "Push Filter",
      "Binary Join",
      "Constant Propagation of Filter in Triple Pattern",
      "Constant Propagation of Filter in Triple Pattern with Operators Between",
      "Bound in Filter Under Add",
      "Unnecessary Optional Because of Projection"
    ],
    "Physical Optimization": ["Physical Optimization Rule"],
    "RIF Rules": [
      "Remove Empty Index",
      "Remove Unnecessary Construct",
      "Remove Unnecessary ConstructPredicate",
      "Construct To Generate",
      "Split Generate",
      "Split PredicatePattern",
      "Split ConstructPredicate",
      "Replace Generate Pat",
      "Generate Pat ConstructPredicate",
      "Remove Union",
      "Remove Distinct",
      "Factor out AND in Filter",
      "Replace Filter With RuleFilter",
      "ReplaceVar Under Index",
      "Merge Memory Indexes",
      "Push RuleFilter"
    ],
    "RIF Rules 0": ["Remove Empty Index"],
    "RIF Rules 1": ["Remove Unnecessary Construct"],
    "RIF Rules 10": ["Factor out AND in Filter"],
    "RIF Rules 11": ["Replace Filter With RuleFilter"],
    "RIF Rules 12": ["ReplaceVar Under Index"],
    "RIF Rules 13": ["Merge Memory Indexes"],
    "RIF Rules 14": ["Push RuleFilter"],
    "RIF Rules 15": ["HashSetNonBlockingDistinctWithIndexAccess"],
    "RIF Rules 16": ["Remove Union"],
    "RIF Rules 2": ["Remove Unnecessary ConstructPredicate"],
    "RIF Rules 3": ["Construct To Generate"],
    "RIF Rules 4": ["Split Generate"],
    "RIF Rules 5": ["Split PredicatePattern"],
    "RIF Rules 6": ["Split ConstructPredicate"],
    "RIF Rules 7": ["Replace Generate Pat"],
    "RIF Rules 8": ["Generate Pat ConstructPredicate"],
    "RIF Rules 9": ["Remove Union"]
  },
  "rule packages": {
    "After Physical Optimization": {"documentation": {
      "long description": "",
      "see also": {
        "rule packages": ["Physical Optimization"],
        "rules": [
          "Push Filter",
          "Physical Optimization Rule"
        ]
      },
      "short description": "This rule package is used after the physical optimization as the physical optimization may produce an operatorgraph where pushing filters is again possible."
    }},
    "Correct Operatorgraph": {"documentation": {
      "long description": "Directly after its generation from the abstract syntax tree, the operator graph does not consider constructs, where variables are already bound outside the scope of UNION and OPTIONAL-clauses and have to be used in filter expressions inside the scope of UNION and OPTIONAL-clauses. For these cases, the results inside and outside of the UNION and OPTIONAL-clauses must be first joined before the filter is evaluated.",
      "see also": {
        "rule packages": [],
        "rules": [
          "Bound Variable in Optional",
          "Bound Variable in Union"
        ]
      },
      "short description": "The rules of this package correct the operator graph after its generation from the abstract syntax tree."
    }},
    "Logical Optimization": {"documentation": {
      "long description": "",
      "see also": {
        "rule packages": [
          "Physical Optimization",
          "Logical Optimization For Stream Engine"
        ],
        "rules": [
          "Binary Join",
          "Optimizing Join Order",
          "Push Filter",
          "Combine Unions",
          "Variable Propagation",
          "Factor out OR in Filter",
          "Factor out AND in Filter",
          "SortLimit over Sort",
          "Projection Over Sort",
          "Bound Variable in Union",
          "Constant Propagation of Filter in Index With Additional Operators Between"
        ]
      },
      "short description": "Logical optimization aims to reorganize the operator graph into an equivalent operator graph, which generates the same output for any input as the original operator graph, in order to optimize the execution time of query evaluation."
    }},
    "Logical Optimization For Stream Engine": {"documentation": {
      "long description": "",
      "see also": {
        "rule packages": ["Logical Optimization"],
        "rules": [
          "Binary Join",
          "Push Filter",
          "Factor out AND in Filter"
        ]
      },
      "short description": "Logical optimization aims to reorganize the operator graph into an equivalent operator graph, which generates the same output for any input as the original operator graph, in order to optimize the execution time of query evaluation. This Rule Package is especially designed for the Stream Engine."
    }},
    "Physical Optimization": {"documentation": {
      "long description": "",
      "see also": {
        "rule packages": ["Logical Optimization"],
        "rules": ["Physical Optimization Rule"]
      },
      "short description": "Physical optimization aims to choose the algorithm with the best estimated execution times in the context of the operator for each operator in the operator graph."
    }},
    "RIF Rules": {"documentation": {
      "long description": "",
      "see also": {
        "rule packages": [
          "Logical Optimization",
          "Logical Optimization For Stream Engine"
        ],
        "rules": [
          "Push RuleFilter",
          "Construct To Generate",
          "Remove Unnecessary Construct",
          "Split ConstructPredicate",
          "Remove Union",
          "Generate Pat ConstructPredicate",
          "ReplaceVar Under Index",
          "Split PredicatePattern",
          "Split Generate",
          "Merge Memory Indexes",
          "Remove Empty Index",
          "Remove Distinct",
          "Remove Unnecessary ConstructPredicate",
          "Replace Generate Pat"
        ]
      },
      "short description": "The rules of this rule package are applied to operatorgraphs generated from a RIF document. Among other optimizations, the rules deal with optimizations of recursive rules."
    }},
    "RIF Rules 0": {"documentation": {
      "long description": "",
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": ""
    }},
    "RIF Rules 1": {"documentation": {
      "long description": "",
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": ""
    }},
    "RIF Rules 10": {"documentation": {
      "long description": "",
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": ""
    }},
    "RIF Rules 11": {"documentation": {
      "long description": "",
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": ""
    }},
    "RIF Rules 12": {"documentation": {
      "long description": "",
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": ""
    }},
    "RIF Rules 13": {"documentation": {
      "long description": "",
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": ""
    }},
    "RIF Rules 14": {"documentation": {
      "long description": "",
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": ""
    }},
    "RIF Rules 15": {"documentation": {
      "long description": "",
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": ""
    }},
    "RIF Rules 16": {"documentation": {
      "long description": "",
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": ""
    }},
    "RIF Rules 2": {"documentation": {
      "long description": "",
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": ""
    }},
    "RIF Rules 3": {"documentation": {
      "long description": "",
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": ""
    }},
    "RIF Rules 4": {"documentation": {
      "long description": "",
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": ""
    }},
    "RIF Rules 5": {"documentation": {
      "long description": "",
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": ""
    }},
    "RIF Rules 6": {"documentation": {
      "long description": "",
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": ""
    }},
    "RIF Rules 7": {"documentation": {
      "long description": "",
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": ""
    }},
    "RIF Rules 8": {"documentation": {
      "long description": "",
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": ""
    }},
    "RIF Rules 9": {"documentation": {
      "long description": "",
      "see also": {
        "rule packages": [],
        "rules": []
      },
      "short description": ""
    }}
  },
  "rules": {
    "Binary Join": {
      "documentation": {
        "left image": "",
        "long description": "The operator graph can contain joins with more than two operands. In this case, this transformation rule generates several join operators, which have only two operands (in a deep right-tree) and which first join those triple patterns, which have the smallest number of not already bound variables. In the case of the Stream approach, we must optimize before any read input data, and thus we cannot use statistics about them for the optimization of the join order. Note that there are more sophisticated join ordering optimization implemented for the other approaches, which use different kinds of estimations.",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": ["Optimizing Join Order"]
        },
        "short description": "This transformation rule generates only binary joins.",
        "show visual representation": false,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "            public BasicOperator getBinaryJoin(lupos.engine.operators.multiinput.join.Join oldJoin, HashMap<Class<?>, HashSet<BasicOperator>> _startNodes) {\n            \tjava.util.LinkedList<BasicOperator> oldJoinPrec = new java.util.LinkedList<BasicOperator>();\n            \toldJoinPrec.addAll(oldJoin.getPrecedingOperators());\n                java.util.Collection<BasicOperator> newOrder = this.optimizeJoinOrderAccordingToMostRestrictionsForMergeJoin(oldJoinPrec);\n                java.util.Collection<BasicOperator> remainingJoins = new java.util.LinkedList<BasicOperator>();\n                java.util.HashSet<BasicOperator> alreadyUsed = new java.util.HashSet<BasicOperator>();\n                \n                java.util.Iterator<BasicOperator> itp = newOrder.iterator();\n            \n                while(itp.hasNext()) {\n         \n                    BasicOperator first = this.getNext(itp, alreadyUsed);\n                    \n                    if(first==null)\n                    \tbreak;\n                    \n                    if(itp.hasNext()) {\n                    \tfeedAlreadyUsed(oldJoin, first.getOperatorIDTuple(oldJoin).getId(), alreadyUsed);\n                    \t\n                        BasicOperator second = this.getNext(itp, alreadyUsed);\n                        if(second==null){\n                            remainingJoins.add(first);\n                            break;\n                        }\n                        \n                        lupos.engine.operators.multiinput.join.Join newJoin = new lupos.engine.operators.multiinput.join.Join();\n                        this.addNodeToStartNodeMapNullCheck(newJoin, _startNodes);\n                            \n                        handleJoinOperand(oldJoin, first.getOperatorIDTuple(oldJoin).getId(), newJoin, 0, alreadyUsed);\n                        handleJoinOperand(oldJoin, second.getOperatorIDTuple(oldJoin).getId(), newJoin, 1, alreadyUsed);\n                            \n                        HashSet<lupos.datastructures.items.Variable> hv = new HashSet<lupos.datastructures.items.Variable>();\n                        for(BasicOperator bo: newJoin.getPrecedingOperators()){\n                        \thv.addAll(bo.getUnionVariables());\n                        }    \n                        newJoin.setUnionVariables(hv);\n            \n                        newJoin.setIntersectionVariables(new HashSet<lupos.datastructures.items.Variable>());\n                        newJoin.getIntersectionVariables().addAll(first.getUnionVariables());\n                        for(BasicOperator bo: newJoin.getPrecedingOperators()){\n                        \tnewJoin.getIntersectionVariables().retainAll(bo.getUnionVariables());\n                        }\n                        \n                        remainingJoins.add(newJoin);\n                    }\n                    else {\n                        remainingJoins.add(first);\n                    }\n                }\n            \n                while(remainingJoins.size() > 1) {\n                    // choose best combination\n                    java.util.Collection<BasicOperator> co = this.getNextJoin(remainingJoins);\n                    java.util.Iterator<BasicOperator> io = co.iterator();\n                    BasicOperator first = io.next();\n                    BasicOperator second = io.next();\n            \n                    lupos.engine.operators.multiinput.join.Join join = new lupos.engine.operators.multiinput.join.Join();\n                    this.addNodeToStartNodeMapNullCheck(join, _startNodes);\n                    \n                    if(first instanceof lupos.engine.operators.multiinput.join.Join && second instanceof lupos.engine.operators.multiinput.join.Join){        \t        \n    \t                first.setSucceedingOperator(new OperatorIDTuple(join, 0));\t    \t        \n    \t                join.addPrecedingOperator(first);\n                    } else {\n                    \tif(first instanceof lupos.engine.operators.multiinput.join.Join){\n                    \t\tBasicOperator tmp = first;\n                    \t\tfirst = second;\n                    \t\tsecond = tmp;\n                    \t}\n                    \t// second is now a join and first something else...\n                        handleJoinOperand(oldJoin, first.getOperatorIDTuple(oldJoin).getId(), join, 0, alreadyUsed);                \t\n                    }\n                    \n                    second.setSucceedingOperator(new OperatorIDTuple(join, 1));    \t        \n                    join.addPrecedingOperator(second);\n                    \n                    HashSet<lupos.datastructures.items.Variable> hv = new HashSet<lupos.datastructures.items.Variable>();\n                    for(BasicOperator bo: join.getPrecedingOperators()){\n                    \thv.addAll(bo.getUnionVariables());\n                    }    \n                    join.setUnionVariables(hv);\n        \n                    join.setIntersectionVariables(new HashSet<lupos.datastructures.items.Variable>());\n                    join.getIntersectionVariables().addAll(first.getUnionVariables());\n                    for(BasicOperator bo: join.getPrecedingOperators()){\n                    \tjoin.getIntersectionVariables().retainAll(bo.getUnionVariables());\n                    }\n            \n                    remainingJoins.remove(first);\n                    remainingJoins.remove(second);\n                    remainingJoins.add(join);\n                }\n            \n                return remainingJoins.iterator().next();\n            }\n            \n            private void feedAlreadyUsed(lupos.engine.operators.multiinput.join.Join oldJoin, int oldOperandID, java.util.HashSet<BasicOperator> alreadyUsed){\n            \tfor(BasicOperator bo: oldJoin.getPrecedingOperators()){\n            \t\tOperatorIDTuple opID=bo.getOperatorIDTuple(oldJoin);\n            \t\tif(opID!=null && opID.getId()==oldOperandID){\n            \t\t\talreadyUsed.add(bo);\n            \t\t}\n            \t}        \t\n            }\n            \n            private void handleJoinOperand(lupos.engine.operators.multiinput.join.Join oldJoin, int oldOperandID, lupos.engine.operators.multiinput.join.Join newJoin, int newOperandID, java.util.HashSet<BasicOperator> alreadyUsed){\n            \tjava.util.LinkedList<lupos.engine.operators.BasicOperator> tmp = new java.util.LinkedList<lupos.engine.operators.BasicOperator>();\n            \ttmp.addAll(oldJoin.getPrecedingOperators());\n            \tfor(BasicOperator bo: tmp){\n            \t\tOperatorIDTuple opID=bo.getOperatorIDTuple(oldJoin);\n            \t\tif(opID!=null && opID.getId()==oldOperandID){\n            \t\t\talreadyUsed.add(bo);\n            \t\t\tbo.replaceOperatorIDTuple(opID, new OperatorIDTuple(newJoin, newOperandID));\n            \t\t\tnewJoin.addPrecedingOperator(bo);\n            \t\t}\n            \t}\n            }\n            \n        private BasicOperator getNext(java.util.Iterator<BasicOperator> itp, java.util.HashSet<BasicOperator> alreadyUsed){\n                    BasicOperator first = itp.next();\n                    while(itp.hasNext() && alreadyUsed.contains(first)){\n                    \tfirst = itp.next();\n                    }\n                    \n                    if(alreadyUsed.contains(first))\n                    \treturn null;\n                    \n                    alreadyUsed.add(first);\n                    \n                    return first;\n        }\n    \n    private java.util.Collection<BasicOperator> optimizeJoinOrderAccordingToMostRestrictionsForMergeJoin(List<BasicOperator> remaining) {\n        java.util.Collection<BasicOperator> newOrder = new java.util.LinkedList<BasicOperator>();\n    \n        while(remaining.size() > 1) {\n            BasicOperator best1 = null;\n            BasicOperator best2 = null;\n            int minOpenPositions = 4;\n    \n            for(BasicOperator bo1 : remaining) {\n                for(BasicOperator bo2 : remaining) {\n                    if(!bo1.equals(bo2)) {\n                        java.util.Collection<lupos.datastructures.items.Variable> v = new java.util.LinkedList<lupos.datastructures.items.Variable>(); \n                        v.addAll(bo1.getUnionVariables());\n                        v.retainAll(bo2.getUnionVariables());\n    \n                        int openPositions = bo1.getUnionVariables().size() - v.size();\n    \n                        if(openPositions < minOpenPositions) {\n                            minOpenPositions = openPositions;\n                            best1 = bo1;\n                            best2 = bo2;\n                        }\n                    }\n                }\n            }\n    \n            newOrder.add(best1);\n            newOrder.add(best2);\n    \n            remaining.remove(best1);\n            remaining.remove(best2);\n        }\n    \n        if(remaining.size() == 1) {\n            for(BasicOperator bo1 : remaining) {\n                newOrder.add(bo1);\n            }\n        }\n    \n        return newOrder;\n    }\n    \n    private java.util.Collection<BasicOperator> getNextJoin(java.util.Collection<BasicOperator> remainingJoins) {\n        java.util.Collection<BasicOperator> co = new java.util.LinkedList<BasicOperator>();\n        BasicOperator best1 = null;\n        BasicOperator best2 = null;\n        int minCommonVariables = -1;\n    \n        for(BasicOperator o1 : remainingJoins) {\n            for(BasicOperator o2 : remainingJoins) {\n                if(!o1.equals(o2)) {\n                    java.util.Collection<lupos.datastructures.items.Variable> v = new java.util.LinkedList<lupos.datastructures.items.Variable>();\n                    v.addAll(o1.getUnionVariables());\n                    v.retainAll(o2.getUnionVariables());\n    \n                    int commonVariables = v.size();\n    \n                    if(commonVariables > minCommonVariables) {\n                        minCommonVariables = commonVariables;\n                        best1 = o1;\n                        best2 = o2;\n                    }\n                }\n            }\n        }\n    \n        co.add(best1);\n        co.add(best2);\n    \n        return co;\n    }\n",
        "additional import declarations": "",
        "check method": {
          "additional code": "if(this.join instanceof lupos.engine.operators.multiinput.optional.parallel.ParallelOptional || this.join instanceof lupos.engine.operators.multiinput.optional.parallel.MergeParallelOptional) {\n    return false;\n}\n\nreturn (this.join.getNumberOfOperands() > 2);",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "",
          "code": "BasicOperator finalJoin = this.getBinaryJoin(this.join, _startNodes);\nfinalJoin.setSucceedingOperators(this.join.getSucceedingOperators());\n\nfor(OperatorIDTuple opIDt : finalJoin.getSucceedingOperators()) {\n    opIDt.getOperator().removePrecedingOperator(this.join);\n    opIDt.getOperator().addPrecedingOperator(finalJoin);\n}\n\nthis.deleteNodeFromStartNodeMapNullCheck(this.join, _startNodes);",
          "use generated code": false
        }
      },
      "visual representation": {
        "left side": {
          "connections": {
            "join": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "o2"
            }],
            "o1": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ALL_PRECEDING",
              "to": "join"
            }]
          },
          "join": {
            "also subclasses": false,
            "class type": "Join",
            "op type": "RuleOperator",
            "position": [
              5,
              269
            ],
            "start node": true
          },
          "o1": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              5
            ]
          },
          "o2": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              533
            ]
          }
        },
        "right side": {},
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Bound In Filter under Index": {
      "documentation": {
        "left image": "",
        "long description": "",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "",
        "show visual representation": true,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "private boolean deleteAll;",
        "additional import declarations": "",
        "check method": {
          "additional code": "lupos.sparql1_1.Node n = this.f.getNodePointer();\r\n\r\nboolean negated = false;\r\n\r\nif(n.jjtGetNumChildren() > 0) {\r\n    n = n.jjtGetChild(0);\r\n\r\n    while(n instanceof lupos.sparql1_1.ASTNotNode){\r\n        negated = !negated;\r\n    n = n.jjtGetChild(0);\r\n    }\r\n    if(n instanceof lupos.sparql1_1.ASTBoundFuncNode){\r\n        n = n.jjtGetChild(0);\r\n        if(n instanceof lupos.sparql1_1.ASTVar) {\r\n            lupos.datastructures.items.Variable var = new lupos.datastructures.items.Variable(((lupos.sparql1_1.ASTVar) n).getName());\r\n            this.deleteAll = (this.i.getVarsInTriplePatterns().contains(var)) == negated;\r\n            return true;\r\n        }\r\n    }\r\n}\r\nreturn false;",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "",
          "code": "this.f.removeFromOperatorGraph();\r\nif(this.deleteAll){\r\n    this.i.removeFromOperatorGraphWithoutConnectingPrecedingWithSucceedingOperators();\r\n    this.deleteNodeFromStartNodeMapNullCheck(this.i, _startNodes);\r\n    for(lupos.engine.operators.BasicOperator child : this.o) {\r\n        this.deleteOperatorWithoutParentsRecursive(child, _startNodes);\r\n    }\r\n}",
          "use generated code": false
        }
      },
      "visual representation": {
        "left side": {
          "connections": {
            "f": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ALL_SUCCEEDING",
              "to": "o"
            }],
            "f2": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "f"
            }],
            "i": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "f2"
            }]
          },
          "f": {
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator",
            "position": [
              11,
              595
            ]
          },
          "f2": {
            "also subclasses": false,
            "cardinality": "*",
            "class type": "Filter",
            "conditions": "",
            "op type": "JumpOverOperator",
            "position": [
              0,
              287
            ]
          },
          "i": {
            "also subclasses": true,
            "class type": "Index",
            "op type": "RuleOperator",
            "position": [
              5,
              5
            ]
          },
          "o": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              0,
              887
            ]
          }
        },
        "right side": {},
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Bound Variable in Optional": {
      "documentation": {
        "left image": "",
        "long description": "This rule avoids failures in SPARQL queries like <span style=\"font-family:monospace;\">{ ?X ?Y ?Z. Optional { ?X2 ?Y2 ?Z2. Filter(?X=?X2).} }<\/span>\n\nLet P1 = ?X ?Y ?Z. and P2 = ?X2 ?Y2 ?Z2. If we do not correct the operator graph after generating the operator graph from the abstract syntax tree, then the Filter-expression is evaluated on results of P2, which is every time false (as ?X is not bound). Thus, we have to correct the operator graph and first join P1 and P2 before the evaluation of the filter expression.We display the graphical representation of the general transformation rule in the below given figure:",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": ["Bound Variable in Union"]
        },
        "short description": "This rule corrects the operator graph after its generation from the abstract syntax tree, especially for the case that variables are used in filter expressions, which are bound outside of the OPTIONAL-clause.",
        "show visual representation": true,
        "transition text": "?X is not necessarily bound in results of O1, but can be bound in results of O2",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "",
        "additional import declarations": "",
        "check method": {
          "additional code": "if(this.o1 instanceof lupos.engine.operators.multiinput.join.Join && this.o1.getPrecedingOperators().contains(this.o2)) {\n    return false;\n}\n\nlupos.engine.operators.singleinput.Filter filterOutestFilter = this.f;\njava.util.Collection<lupos.datastructures.items.Variable> variablesInnerUnion = this.o1.getIntersectionVariables();\njava.util.Collection<lupos.datastructures.items.Variable> variablesOuterUnion = this.o2.getUnionVariables();\nboolean checkFurther = true;\n\nwhile(checkFurther) {\n    if(!variablesInnerUnion.containsAll(filterOutestFilter.getUsedVariables())) {\n        for(lupos.datastructures.items.Variable v : filterOutestFilter.getUsedVariables()) {\n            if(!variablesInnerUnion.contains(v) && variablesOuterUnion.contains(v)) {\n                return true;\n            }\n        }\n    }\n\n    BasicOperator nextOp = filterOutestFilter.getPrecedingOperators().get(0);\n\n    if(nextOp.equals(this.o1)) {\n        checkFurther = false;\n    }\n    else {\n        filterOutestFilter = (lupos.engine.operators.singleinput.Filter) nextOp;\n    }\n}\nreturn false;",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "this.o1.getOperatorIDTuple(j).setId(0);\nthis.o2.getOperatorIDTuple(j).setId(1);\n\nHashSet<lupos.datastructures.items.Variable> intersectionVariables = new HashSet<lupos.datastructures.items.Variable>();\nintersectionVariables.addAll(this.o1.getUnionVariables());\nintersectionVariables.retainAll(this.o2.getUnionVariables());\n\nHashSet<lupos.datastructures.items.Variable> unionVariables = new HashSet<lupos.datastructures.items.Variable>();\nunionVariables.addAll(this.o1.getUnionVariables());\nunionVariables.addAll(this.o2.getUnionVariables());\n\nBasicOperator tmpOp = j;\n\nwhile(!tmpOp.equals(this.opt)) {\n    tmpOp.setUnionVariables(unionVariables);\n    tmpOp.setIntersectionVariables(intersectionVariables);\n\n    tmpOp = tmpOp.getSucceedingOperators().get(0).getOperator();\n}\n\nthis.opt.setUnionVariables(unionVariables);\nthis.opt.setIntersectionVariables(intersectionVariables);",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {
          "connections": {
            "f": [{
              "active": true,
              "id": 1,
              "id label": "",
              "mode": "EXISTS",
              "to": "opt"
            }],
            "jump_filter": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "f"
            }],
            "o1": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "jump_filter"
            }],
            "o2": [{
              "active": true,
              "id": 0,
              "id label": "",
              "mode": "ONLY_SUCCEEDING",
              "to": "opt"
            }]
          },
          "f": {
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator",
            "position": [
              43,
              555
            ]
          },
          "jump_filter": {
            "also subclasses": false,
            "cardinality": "*",
            "class type": "Filter",
            "conditions": "",
            "op type": "JumpOverOperator",
            "position": [
              2,
              282
            ]
          },
          "o1": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              43,
              19
            ]
          },
          "o2": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              526,
              17
            ]
          },
          "opt": {
            "also subclasses": false,
            "class type": "Optional",
            "op type": "RuleOperator",
            "position": [
              498,
              820
            ],
            "start node": true
          }
        },
        "right side": {
          "connections": {
            "f": [{
              "active": true,
              "id": 1,
              "id label": "",
              "mode": "EXISTS",
              "to": "opt"
            }],
            "j": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "jump_filter"
            }],
            "jump_filter": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "f"
            }],
            "o1": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "j"
            }],
            "o2": [
              {
                "active": false,
                "id": -1,
                "id label": "",
                "mode": "EXISTS",
                "to": "j"
              },
              {
                "active": true,
                "id": 0,
                "id label": "",
                "mode": "EXISTS",
                "to": "opt"
              }
            ]
          },
          "f": {
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator",
            "position": [
              292,
              762
            ]
          },
          "j": {
            "also subclasses": false,
            "class type": "Join",
            "op type": "RuleOperator",
            "position": [
              290,
              292
            ]
          },
          "jump_filter": {
            "also subclasses": false,
            "cardinality": "*",
            "class type": "Filter",
            "conditions": "",
            "op type": "JumpOverOperator",
            "position": [
              291,
              524
            ]
          },
          "o1": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              2,
              21
            ]
          },
          "o2": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              891,
              21
            ]
          },
          "opt": {
            "also subclasses": false,
            "class type": "Optional",
            "op type": "RuleOperator",
            "position": [
              769,
              992
            ]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Bound Variable in Union": {
      "documentation": {
        "left image": "",
        "long description": "This rule avoids failures in SPARQL queries like <span style=\"font-family:monospace;\">{ ?X ?Y ?Z. { ?X2 ?Y2 ?Z2. Filter(?X=?X2).} UNION { ... } }<\/span>\n\nLet P1 = ?X ?Y ?Z. and P2 = ?X2 ?Y2 ?Z2. If we do not correct the operator graph after generating the operator graph from the abstract syntax tree, then the Filter-expression is evaluated on results of P2, which is every time false (as ?X is not bound). Thus, we have to correct the operator graph and first join P1 and P2 before the evaluation of the filter expression.We display the graphical representation of the general transformation rule in the below given figure:",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": ["Bound Variable in Optional"]
        },
        "short description": "This rule corrects the operator graph after its generation from the abstract syntax tree, especially for the case that variables are used in filter expressions, which are bound outside of the UNION-clause.",
        "show visual representation": true,
        "transition text": "?X is not necessarily bound in results of O2, but can be bound in results of O3",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "",
        "additional import declarations": "",
        "check method": {
          "additional code": "if(this.u.getOperatorIDTuple(this.j).getId()==this.o3.getOperatorIDTuple(this.j).getId()){\n\treturn false;\n}\n\nlupos.engine.operators.singleinput.Filter filterOutestFilter = this.f;\njava.util.Collection<lupos.datastructures.items.Variable> variablesInnerUnion = this.o2.getIntersectionVariables();\njava.util.Collection<lupos.datastructures.items.Variable> variablesOuterUnion = this.o3.getUnionVariables();\nboolean checkFurther = true;\n\nwhile(checkFurther) {\n    if(!variablesInnerUnion.containsAll(filterOutestFilter.getUsedVariables())) {\n        for(lupos.datastructures.items.Variable v : filterOutestFilter.getUsedVariables()) {\n            if(!variablesInnerUnion.contains(v) && variablesOuterUnion.contains(v)) {\n                return true;\n            }\n        }\n    }\n\n    BasicOperator nextOp = filterOutestFilter.getPrecedingOperators().get(0);\n\n    if(nextOp.equals(this.o2)) {\n        checkFurther = false;\n    }\n    else {\n        filterOutestFilter = (lupos.engine.operators.singleinput.Filter) nextOp;\n    }\n}\nreturn false;",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "j_new.setUnionVariables(new HashSet<lupos.datastructures.items.Variable>());\nj_new.getUnionVariables().addAll(this.o2.getUnionVariables());\nj_new.getUnionVariables().addAll(this.o3.getUnionVariables());\n\nj_new.setIntersectionVariables(new HashSet<lupos.datastructures.items.Variable>());\nj_new.getIntersectionVariables().addAll(this.o2.getUnionVariables());\nj_new.getIntersectionVariables().retainAll(this.o3.getUnionVariables());\n\nthis.o2.getOperatorIDTuple(j_new).setId(0);\nthis.o3.getOperatorIDTuple(j_new).setId(1);\n\nfor(BasicOperator precOp : this.u.getPrecedingOperators()) {\n    if(!precOp.equals(this.f)) {\n        BasicOperator tmpOp = precOp;\n\n        while(tmpOp instanceof lupos.engine.operators.singleinput.Filter) {\n            tmpOp = tmpOp.getPrecedingOperators().get(0);\n        }\n\n\n        lupos.engine.operators.multiinput.join.Join newJoin = new lupos.engine.operators.multiinput.join.Join();\n\n        newJoin.addPrecedingOperator(tmpOp);\n        newJoin.addPrecedingOperator(this.o3);\n\n        for(OperatorIDTuple opIDt : tmpOp.getSucceedingOperators()) {\n            opIDt.getOperator().removePrecedingOperator(tmpOp);\n            opIDt.getOperator().addPrecedingOperator(newJoin);\n        }\n\n        newJoin.setSucceedingOperators(tmpOp.getSucceedingOperators());\n        tmpOp.setSucceedingOperator(new OperatorIDTuple(newJoin, 0));\n        this.o3.addSucceedingOperator(new OperatorIDTuple(newJoin, 1));\n\n\n        HashSet<lupos.datastructures.items.Variable> intersectionVariables = new HashSet<lupos.datastructures.items.Variable>();\n        intersectionVariables.addAll(tmpOp.getUnionVariables());\n        intersectionVariables.retainAll(this.o3.getUnionVariables());\n\n        HashSet<lupos.datastructures.items.Variable> unionVariables = new HashSet<lupos.datastructures.items.Variable>();\n        unionVariables.addAll(tmpOp.getUnionVariables());\n        unionVariables.addAll(this.o3.getUnionVariables());\n\n        newJoin.setIntersectionVariables(intersectionVariables);\n        newJoin.setUnionVariables(unionVariables);\n\n\n        tmpOp = tmpOp.getSucceedingOperators().get(0).getOperator();\n\n        while(!tmpOp.equals(this.u)) {\n            tmpOp.setUnionVariables(unionVariables);\n            tmpOp.setIntersectionVariables(intersectionVariables);\n\n            tmpOp = tmpOp.getSucceedingOperators().get(0).getOperator();\n        }\n    }\n}",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {
          "connections": {
            "f": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "u"
            }],
            "j": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ALL_SUCCEEDING",
              "to": "o"
            }],
            "jump_filter": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "f"
            }],
            "o2": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "jump_filter"
            }],
            "o3": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_SUCCEEDING",
              "to": "j"
            }],
            "u": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "j"
            }]
          },
          "f": {
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator",
            "position": [
              51,
              545
            ]
          },
          "j": {
            "also subclasses": false,
            "class type": "Join",
            "op type": "RuleOperator",
            "position": [
              512,
              1073
            ]
          },
          "jump_filter": {
            "also subclasses": false,
            "cardinality": "*",
            "class type": "Filter",
            "conditions": "",
            "op type": "JumpOverOperator",
            "position": [
              5,
              269
            ]
          },
          "o": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              512,
              1344
            ]
          },
          "o2": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              34,
              5
            ]
          },
          "o3": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              520,
              417
            ]
          },
          "u": {
            "also subclasses": false,
            "class type": "Union",
            "op type": "RuleOperator",
            "position": [
              52,
              811
            ],
            "start node": true
          }
        },
        "right side": {
          "connections": {
            "f": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "u"
            }],
            "j_new": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "jump_filter"
            }],
            "jump_filter": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "f"
            }],
            "o2": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "j_new"
            }],
            "o3": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "j_new"
            }],
            "u": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ALL_SUCCEEDING",
              "to": "o"
            }]
          },
          "f": {
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator",
            "position": [
              288,
              759
            ]
          },
          "j_new": {
            "also subclasses": false,
            "class type": "Join",
            "op type": "RuleOperator",
            "position": [
              287,
              293
            ]
          },
          "jump_filter": {
            "also subclasses": false,
            "cardinality": "*",
            "class type": "Filter",
            "conditions": "",
            "op type": "JumpOverOperator",
            "position": [
              286,
              527
            ]
          },
          "o": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              289,
              1226
            ]
          },
          "o2": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              6,
              9
            ]
          },
          "o3": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              904,
              8
            ]
          },
          "u": {
            "also subclasses": false,
            "class type": "Union",
            "op type": "RuleOperator",
            "position": [
              288,
              995
            ]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Bound in Filter Under Add": {
      "documentation": {
        "left image": "",
        "long description": "",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "",
        "show visual representation": true,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "private boolean deleteAll = false;",
        "additional import declarations": "",
        "check method": {
          "additional code": "lupos.sparql1_1.Node n = this.f.getNodePointer();\r\n\r\nboolean negated = false;\r\n\r\nif(n.jjtGetNumChildren() > 0) {\r\n    n = n.jjtGetChild(0);\r\n\r\n    while(n instanceof lupos.sparql1_1.ASTNotNode){\r\n        negated = !negated;\r\n    n = n.jjtGetChild(0);\r\n    }\r\n    if(n instanceof lupos.sparql1_1.ASTBoundFuncNode){\r\n        n = n.jjtGetChild(0);\r\n        if(n instanceof lupos.sparql1_1.ASTVar) {\r\n            lupos.datastructures.items.Variable var = new lupos.datastructures.items.Variable(((lupos.sparql1_1.ASTVar) n).getName());\r\n      this.deleteAll = negated;\r\n            return var.equals(this.a.getVar());\r\n        }\r\n    }\r\n}\r\nreturn false;",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "if(this.deleteAll){\r\n  this.deleteOperatorWithParentsAndChildren(this.a ,_startNodes);\r\n}",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {
          "a": {
            "also subclasses": false,
            "class type": "AddBinding",
            "op type": "RuleOperator",
            "position": [
              5,
              5
            ]
          },
          "connections": {
            "a": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "f"
            }],
            "f": [{
              "active": true,
              "id": -1,
              "id label": "o_id",
              "mode": "ALL_SUCCEEDING",
              "to": "o"
            }]
          },
          "f": {
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator",
            "position": [
              5,
              276
            ]
          },
          "o": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              547
            ]
          }
        },
        "right side": {
          "a": {
            "also subclasses": false,
            "class type": "AddBinding",
            "op type": "RuleOperator",
            "position": [
              5,
              5
            ]
          },
          "connections": {"a": [{
            "active": true,
            "id": -1,
            "id label": "o_id",
            "mode": "ALL_SUCCEEDING",
            "to": "o"
          }]},
          "o": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              235
            ]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Combine Unions": {
      "documentation": {
        "left image": "",
        "long description": "",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "This transformtion rule combines two succeeding union operators into one in order to save the processing costs of a superfluous union operation.",
        "show visual representation": true,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "",
        "additional import declarations": "",
        "check method": {
          "additional code": "",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "int id = 0;\n        \nfor(BasicOperator precOp : this.u2.getPrecedingOperators()) {\n    precOp.getOperatorIDTuple(this.u2).setId(id++);\n}",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {
          "connections": {
            "o1": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ALL_PRECEDING",
              "to": "u1"
            }],
            "u1": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "u2"
            }]
          },
          "o1": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              5
            ]
          },
          "u1": {
            "also subclasses": false,
            "class type": "Union",
            "op type": "RuleOperator",
            "position": [
              5,
              269
            ]
          },
          "u2": {
            "also subclasses": false,
            "class type": "Union",
            "op type": "RuleOperator",
            "position": [
              5,
              533
            ],
            "start node": true
          }
        },
        "right side": {
          "connections": {"o1": [{
            "active": false,
            "id": -1,
            "id label": "",
            "mode": "ALL_PRECEDING",
            "to": "u2"
          }]},
          "o1": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              10,
              18
            ]
          },
          "u2": {
            "also subclasses": false,
            "class type": "Union",
            "op type": "RuleOperator",
            "position": [
              22,
              246
            ]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Constant Propagation of Filter in Index With Additional Operators Between": {
      "documentation": {
        "left image": "",
        "long description": "If there Filter expressions with a equal-comparision of a variable with a constant value, e.g. Filter(?X=&lt;http://myURL.de&gt;), then this constant value can be propagated to preceding (RDF3X/Hexastore) Index operators. Afterwards, the corresponding variable (here ?X) must be bound with the constant value (here &lt;http://myURL.de&gt;), e.g. ?X ?Y ?Z. Filter(?X=&lt;http://myURL.de&gt;) is transformed into &lt;http://myURL.de&gt; ?Y ?Z. AddBinding(?X=&lt;http://myURL.de&gt;). However, there are problems with this approach if the constant value can be value-equal with another constant value using a different representation, e.g. +01^^xsd:int is value-equal, but not identical to 1^^xsd:int. Thus, this transformation rule is not applied whenever the constant value is a numerical value or a language tagged literal.\n\nThe following figure contains the graphical representation of the transformation rule.",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": [
            "Variable Propagation",
            "Factor out OR in Filter",
            "ConstantPropagation of Filter in Index"
          ]
        },
        "short description": "This rule implements constant propagation from Filter to Index.",
        "show visual representation": true,
        "transition text": "c is neither a numerical value nor a language tagged literal",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "private lupos.datastructures.items.Variable var = null;\nprivate lupos.datastructures.items.literal.Literal constant = null;\nprivate int operandIDOfFilter;",
        "additional import declarations": "",
        "check method": {
          "additional code": "this.operandIDOfFilter = this.f.getOperatorIDTuple(o).getId();\n\nlupos.sparql1_1.Node n = this.f.getNodePointer();\n\nif(n.jjtGetNumChildren() > 0) {\n    n = n.jjtGetChild(0);\n\n    if(n instanceof lupos.sparql1_1.ASTEqualsNode) {\n        lupos.sparql1_1.Node left = n.jjtGetChild(0);\n        lupos.sparql1_1.Node right = n.jjtGetChild(1);\n\n        if(right instanceof lupos.sparql1_1.ASTVar) {\n            lupos.sparql1_1.Node tmp = left;\n            left = right;\n            right = tmp;\n        }\n\n        if(left instanceof lupos.sparql1_1.ASTVar) {\n            this.var = new lupos.datastructures.items.Variable(((lupos.sparql1_1.ASTVar) left).getName());\n\n            if(!this.i.getVarsInTriplePatterns().contains(this.var)){\n              return false;\n            }\n\n            if(right instanceof lupos.sparql1_1.ASTQName\n               || right instanceof lupos.sparql1_1.ASTQuotedURIRef\n               || right instanceof lupos.sparql1_1.ASTFloatingPoint\n               || right instanceof lupos.sparql1_1.ASTInteger\n               || right instanceof lupos.sparql1_1.ASTStringLiteral\n               || right instanceof lupos.sparql1_1.ASTDoubleCircumflex\n       || right instanceof lupos.sparql1_1.ASTRDFLiteral) {\n                this.constant = lupos.datastructures.items.literal.LazyLiteral.getLiteral(right);\n\n                // Is it possible to loose the information of the original string representation?\n                if(this.constant instanceof lupos.datastructures.items.literal.TypedLiteralOriginalContent || this.constant instanceof lupos.datastructures.items.literal.LanguageTaggedLiteralOriginalLanguage) {\n                    return false;\n                }\n                else if(this.constant instanceof lupos.datastructures.items.literal.TypedLiteral) {\n                    if(lupos.engine.operators.singleinput.ExpressionEvaluation.Helper.isNumeric(((lupos.datastructures.items.literal.TypedLiteral) this.constant).getType())) {\n                        return false;\n                    } else {\n                        return true;\n                    }\n                } else {\n                    return true;\n                }\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    else {\n        return false;\n    }\n}\nelse {\n    return false;\n}",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "this.constant = this.constant.createThisLiteralNew();\nthis.i.replace(this.var, this.constant);\nthis.i.getUnionVariables().remove(this.var);\nthis.i.getIntersectionVariables().remove(this.var);\n\nb.setVar(this.var);\nb.setLiteral(this.constant);\n\njava.util.LinkedList<lupos.datastructures.items.Variable> unionVars=new java.util.LinkedList<lupos.datastructures.items.Variable>(this.i.getUnionVariables());\nunionVars.add(this.var);\njava.util.LinkedList<lupos.datastructures.items.Variable> intersectionVars=new java.util.LinkedList<lupos.datastructures.items.Variable>(unionVars);\n\nb.setUnionVariables(unionVars);\nb.setIntersectionVariables(intersectionVars);\nthis.j_end.getOperatorIDTuple(o).setId(this.operandIDOfFilter);",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {
          "connections": {
            "f": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_SUCCEEDING",
              "to": "o"
            }],
            "i": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "j"
            }],
            "j": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "f"
            }]
          },
          "f": {
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator",
            "position": [
              32,
              557
            ],
            "start node": true
          },
          "i": {
            "also subclasses": true,
            "class type": "Index",
            "op type": "RuleOperator",
            "position": [
              33,
              5
            ]
          },
          "j": {
            "also subclasses": true,
            "cardinality": "*",
            "class type": "Operator",
            "conditions": "",
            "op type": "JumpOverOperator",
            "position": [
              5,
              276
            ]
          },
          "o": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              30,
              828
            ]
          }
        },
        "right side": {
          "b": {
            "also subclasses": false,
            "class type": "AddBinding",
            "op type": "RuleOperator",
            "position": [
              5,
              235
            ]
          },
          "connections": {
            "b": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "j"
            }],
            "i": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "b"
            }],
            "j": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "o"
            }]
          },
          "i": {
            "also subclasses": false,
            "class type": "Index",
            "op type": "RuleOperator",
            "position": [
              8,
              5
            ]
          },
          "j": {
            "also subclasses": false,
            "cardinality": "*",
            "class type": "Operator",
            "conditions": "",
            "op type": "JumpOverOperator",
            "position": [
              7,
              465
            ]
          },
          "o": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              695
            ]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Constant Propagation of Filter in Triple Pattern": {
      "documentation": {
        "left image": "",
        "long description": "",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "This rule implements constant propagation from Filter to Triple Pattern.",
        "show visual representation": true,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "private lupos.datastructures.items.Variable var = null;\r\nprivate lupos.datastructures.items.literal.Literal constant = null;",
        "additional import declarations": "",
        "check method": {
          "additional code": "lupos.sparql1_1.Node n = this.f.getNodePointer();\r\n\r\nif(n.jjtGetNumChildren() > 0) {\r\n    n = n.jjtGetChild(0);\r\n\r\n    if(n instanceof lupos.sparql1_1.ASTEqualsNode) {\r\n        lupos.sparql1_1.Node left = n.jjtGetChild(0);\r\n        lupos.sparql1_1.Node right = n.jjtGetChild(1);\r\n\r\n        if(right instanceof lupos.sparql1_1.ASTVar) {\r\n            lupos.sparql1_1.Node tmp = left;\r\n            left = right;\r\n            right = tmp;\r\n        }\r\n\r\n        if(left instanceof lupos.sparql1_1.ASTVar) {\r\n            String varname = ((lupos.sparql1_1.ASTVar) left).getName();\r\n            this.var = new lupos.datastructures.items.Variable(varname);\r\n\r\n            if(!this.tp.getVariables().contains(this.var)){\r\n              return false;\r\n            }\r\n\r\n            if(!this.tp.getVariables().contains(this.var) && !this.tp.getVariables().contains(new lupos.datastructures.items.VariableInInferenceRule(varname))) {\r\n                // TODO: delete triple pattern as it will never have a result!\r\n                System.err.println(\"Can be optimized by extending RuleReplaceConstantOfFilterInTriplePattern: delete triple pattern with succeeding unsatisfiable filter expression!\");\r\n\r\n                return false;\r\n            }\r\n\r\n            if(right instanceof lupos.sparql1_1.ASTQName\r\n               || right instanceof lupos.sparql1_1.ASTRDFLiteral\r\n               || right instanceof lupos.sparql1_1.ASTQuotedURIRef\r\n               || right instanceof lupos.sparql1_1.ASTFloatingPoint\r\n               || right instanceof lupos.sparql1_1.ASTInteger\r\n               || right instanceof lupos.sparql1_1.ASTStringLiteral\r\n               || right instanceof lupos.sparql1_1.ASTDoubleCircumflex) {\r\n                this.constant = lupos.datastructures.items.literal.LazyLiteral.getLiteral(right);\r\n\r\n                // Is it possible to loose the information of the original string representation?\r\n                if(this.constant instanceof lupos.datastructures.items.literal.TypedLiteralOriginalContent || constant instanceof lupos.datastructures.items.literal.LanguageTaggedLiteralOriginalLanguage) {\r\n                    \treturn false;\r\n                }\r\n                else if(this.constant instanceof lupos.datastructures.items.literal.TypedLiteral) {\r\n                    if(lupos.engine.operators.singleinput.ExpressionEvaluation.Helper.isNumeric(((lupos.datastructures.items.literal.TypedLiteral) constant).getType())) {\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        return true;\r\n                    }\r\n                }\r\n                else {\r\n                    return true;\r\n                }\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\nelse {\r\n    return false;\r\n}",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "this.constant = this.constant.createThisLiteralNew();\r\njava.util.Set<lupos.datastructures.items.Variable> replacedVars = this.tp.replace(this.var, this.constant);\r\nthis.tp.getIntersectionVariables().removeAll(replacedVars);\r\nthis.tp.getUnionVariables().removeAll(replacedVars);\r\n\r\nb.setVar(this.var);\r\nb.setLiteral(this.constant);\r\n\r\njava.util.LinkedList<lupos.datastructures.items.Variable> unionVars=new java.util.LinkedList<lupos.datastructures.items.Variable>(this.tp.getUnionVariables());\r\nunionVars.add(this.var);\r\njava.util.LinkedList<lupos.datastructures.items.Variable> intersectionVars=new java.util.LinkedList<lupos.datastructures.items.Variable>(unionVars);\r\n\r\nb.setUnionVariables(unionVars);\r\nb.setIntersectionVariables(intersectionVars);",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {
          "connections": {
            "f": [{
              "active": true,
              "id": -1,
              "id label": "a",
              "mode": "ALL_SUCCEEDING",
              "to": "o"
            }],
            "tp": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "f"
            }]
          },
          "f": {
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator",
            "position": [
              0,
              267
            ],
            "start node": true
          },
          "o": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              0,
              566
            ]
          },
          "tp": {
            "also subclasses": false,
            "class type": "TriplePattern",
            "op type": "RuleOperator",
            "position": [
              1,
              0
            ]
          }
        },
        "right side": {
          "b": {
            "also subclasses": false,
            "class type": "AddBinding",
            "op type": "RuleOperator",
            "position": [
              5,
              282
            ]
          },
          "connections": {
            "b": [{
              "active": true,
              "id": -1,
              "id label": "a",
              "mode": "ALL_SUCCEEDING",
              "to": "o"
            }],
            "tp": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "b"
            }]
          },
          "o": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              611
            ]
          },
          "tp": {
            "also subclasses": false,
            "class type": "TriplePattern",
            "op type": "RuleOperator",
            "position": [
              2,
              0
            ]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Constant Propagation of Filter in Triple Pattern with Operators Between": {
      "documentation": {
        "left image": "",
        "long description": "",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "This rule implements constant propagation from Filter to Triple Pattern.",
        "show visual representation": true,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "private lupos.datastructures.items.Variable var = null;\r\nprivate lupos.datastructures.items.literal.Literal constant = null;\r\nprivate int operandIDOfFilter;",
        "additional import declarations": "",
        "check method": {
          "additional code": "this.operandIDOfFilter = this.f.getOperatorIDTuple(o).getId();\r\n\r\nlupos.sparql1_1.Node n = this.f.getNodePointer();\r\n\r\nif(n.jjtGetNumChildren() > 0) {\r\n    n = n.jjtGetChild(0);\r\n\r\n    if(n instanceof lupos.sparql1_1.ASTEqualsNode) {\r\n        lupos.sparql1_1.Node left = n.jjtGetChild(0);\r\n        lupos.sparql1_1.Node right = n.jjtGetChild(1);\r\n\r\n        if(right instanceof lupos.sparql1_1.ASTVar) {\r\n            lupos.sparql1_1.Node tmp = left;\r\n            left = right;\r\n            right = tmp;\r\n        }\r\n\r\n        if(left instanceof lupos.sparql1_1.ASTVar) {\r\n            String varname = ((lupos.sparql1_1.ASTVar) left).getName();\r\n            this.var = new lupos.datastructures.items.Variable(varname);\r\n\r\n            if(!this.tp.getVariables().contains(this.var)){\r\n              return false;\r\n            }\r\n\r\n            if(!this.tp.getVariables().contains(this.var) && !this.tp.getVariables().contains(new lupos.datastructures.items.VariableInInferenceRule(varname))) {\r\n                // TODO: delete triple pattern as it will never have a result!\r\n                System.err.println(\"Can be optimized by extending RuleReplaceConstantOfFilterInTriplePattern: delete triple pattern with succeeding unsatisfiable filter expression!\");\r\n\r\n                return false;\r\n            }\r\n\r\n            if(right instanceof lupos.sparql1_1.ASTQName\r\n               || right instanceof lupos.sparql1_1.ASTRDFLiteral\r\n               || right instanceof lupos.sparql1_1.ASTQuotedURIRef\r\n               || right instanceof lupos.sparql1_1.ASTFloatingPoint\r\n               || right instanceof lupos.sparql1_1.ASTInteger\r\n               || right instanceof lupos.sparql1_1.ASTStringLiteral\r\n               || right instanceof lupos.sparql1_1.ASTDoubleCircumflex) {\r\n                this.constant = lupos.datastructures.items.literal.LazyLiteral.getLiteral(right);\r\n\r\n                // Is it possible to loose the information of the original string representation?\r\n                if(this.constant instanceof lupos.datastructures.items.literal.TypedLiteralOriginalContent || constant instanceof lupos.datastructures.items.literal.LanguageTaggedLiteralOriginalLanguage) {\r\n                    \treturn false;\r\n                }\r\n                else if(this.constant instanceof lupos.datastructures.items.literal.TypedLiteral) {\r\n                    if(lupos.engine.operators.singleinput.ExpressionEvaluation.Helper.isNumeric(((lupos.datastructures.items.literal.TypedLiteral) constant).getType())) {\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        return true;\r\n                    }\r\n                }\r\n                else {\r\n                    return true;\r\n                }\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\nelse {\r\n    return false;\r\n}",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "this.constant = this.constant.createThisLiteralNew();\r\njava.util.Set<lupos.datastructures.items.Variable> replacedVars = this.tp.replace(this.var, this.constant);\r\nthis.tp.getIntersectionVariables().removeAll(replacedVars);\r\nthis.tp.getUnionVariables().removeAll(replacedVars);\r\n\r\nb.setVar(this.var);\r\nb.setLiteral(this.constant);\r\n\r\njava.util.LinkedList<lupos.datastructures.items.Variable> unionVars=new java.util.LinkedList<lupos.datastructures.items.Variable>(this.tp.getUnionVariables());\r\nunionVars.add(this.var);\r\njava.util.LinkedList<lupos.datastructures.items.Variable> intersectionVars=new java.util.LinkedList<lupos.datastructures.items.Variable>(unionVars);\r\n\r\nb.setUnionVariables(unionVars);\r\nb.setIntersectionVariables(intersectionVars);\r\nthis.j_end.getOperatorIDTuple(o).setId(this.operandIDOfFilter);",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {
          "connections": {
            "f": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_SUCCEEDING",
              "to": "o"
            }],
            "j": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "f"
            }],
            "tp": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "j"
            }]
          },
          "f": {
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator",
            "position": [
              34,
              557
            ],
            "start node": true
          },
          "j": {
            "also subclasses": true,
            "cardinality": "*",
            "class type": "Operator",
            "conditions": "",
            "op type": "JumpOverOperator",
            "position": [
              5,
              276
            ]
          },
          "o": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              34,
              828
            ]
          },
          "tp": {
            "also subclasses": false,
            "class type": "TriplePattern",
            "op type": "RuleOperator",
            "position": [
              34,
              5
            ]
          }
        },
        "right side": {
          "b": {
            "also subclasses": false,
            "class type": "AddBinding",
            "op type": "RuleOperator",
            "position": [
              5,
              235
            ]
          },
          "connections": {
            "b": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "j"
            }],
            "j": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "o"
            }],
            "tp": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "b"
            }]
          },
          "j": {
            "also subclasses": false,
            "cardinality": "*",
            "class type": "Operator",
            "conditions": "",
            "op type": "JumpOverOperator",
            "position": [
              5,
              465
            ]
          },
          "o": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              695
            ]
          },
          "tp": {
            "also subclasses": false,
            "class type": "TriplePattern",
            "op type": "RuleOperator",
            "position": [
              5,
              5
            ]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "ConstantPropagation of Filter in Index": {
      "documentation": {
        "left image": "",
        "long description": "If there Filter expressions with a equal-comparision of a variable with a constant value, e.g. Filter(?X=&lt;http://myURL.de&gt;), then this constant value can be propagated to preceding (RDF3X/Hexastore) Index operators. Afterwards, the corresponding variable (here ?X) must be bound with the constant value (here &lt;http://myURL.de&gt;), e.g. ?X ?Y ?Z. Filter(?X=&lt;http://myURL.de&gt;) is transformed into &lt;http://myURL.de&gt; ?Y ?Z. AddBinding(?X=&lt;http://myURL.de&gt;). However, there are problems with this approach if the constant value can be value-equal with another constant value using a different representation, e.g. +01^^xsd:int is value-equal, but not identical to 1^^xsd:int. Thus, this transformation rule is not applied whenever the constant value is a numerical value or a language tagged literal.\r\n\r\nThe following figure contains the graphical representation of the transformation rule.",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": ["Constant Propagation of Filter in Index With Additional Operators Between"]
        },
        "short description": "This rule implements constant propagation from Filter to Index.",
        "show visual representation": true,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "private lupos.datastructures.items.Variable var = null;\r\nprivate lupos.datastructures.items.literal.Literal constant = null;",
        "additional import declarations": "",
        "check method": {
          "additional code": "lupos.sparql1_1.Node n = this.f.getNodePointer();\r\n\r\nif(n.jjtGetNumChildren() > 0) {\r\n    n = n.jjtGetChild(0);\r\n\r\n    if(n instanceof lupos.sparql1_1.ASTEqualsNode) {\r\n        lupos.sparql1_1.Node left = n.jjtGetChild(0);\r\n        lupos.sparql1_1.Node right = n.jjtGetChild(1);\r\n\r\n        if(right instanceof lupos.sparql1_1.ASTVar) {\r\n            lupos.sparql1_1.Node tmp = left;\r\n            left = right;\r\n            right = tmp;\r\n        }\r\n\r\n        if(left instanceof lupos.sparql1_1.ASTVar) {\r\n            this.var = new lupos.datastructures.items.Variable(((lupos.sparql1_1.ASTVar) left).getName());\r\n\r\n            if(!this.i.getVarsInTriplePatterns().contains(this.var)){\r\n              return false;\r\n            }\r\n\r\n            if(right instanceof lupos.sparql1_1.ASTQName\r\n               || right instanceof lupos.sparql1_1.ASTQuotedURIRef\r\n               || right instanceof lupos.sparql1_1.ASTFloatingPoint\r\n               || right instanceof lupos.sparql1_1.ASTInteger\r\n               || right instanceof lupos.sparql1_1.ASTStringLiteral\r\n               || right instanceof lupos.sparql1_1.ASTDoubleCircumflex\r\n       || right instanceof lupos.sparql1_1.ASTRDFLiteral) {\r\n                this.constant = lupos.datastructures.items.literal.LazyLiteral.getLiteral(right);\r\n\r\n                // Is it possible to loose the information of the original string representation?\r\n                if(this.constant instanceof lupos.datastructures.items.literal.TypedLiteralOriginalContent || this.constant instanceof lupos.datastructures.items.literal.LanguageTaggedLiteralOriginalLanguage) {\r\n                    return false;\r\n                }\r\n                else if(this.constant instanceof lupos.datastructures.items.literal.TypedLiteral) {\r\n                    if(lupos.engine.operators.singleinput.ExpressionEvaluation.Helper.isNumeric(((lupos.datastructures.items.literal.TypedLiteral) this.constant).getType())) {\r\n                        return false;\r\n                    } else {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    return true;\r\n                }\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\nelse {\r\n    return false;\r\n}",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "this.constant = this.constant.createThisLiteralNew();\r\nthis.i.replace(this.var, this.constant);\r\nthis.i.getUnionVariables().remove(this.var);\r\nthis.i.getIntersectionVariables().remove(this.var);\r\n\r\nb.setVar(this.var);\r\nb.setLiteral(this.constant);\r\n\r\njava.util.LinkedList<lupos.datastructures.items.Variable> unionVars=new java.util.LinkedList<lupos.datastructures.items.Variable>(this.i.getUnionVariables());\r\nunionVars.add(this.var);\r\njava.util.LinkedList<lupos.datastructures.items.Variable> intersectionVars=new java.util.LinkedList<lupos.datastructures.items.Variable>(unionVars);\r\n\r\nb.setUnionVariables(unionVars);\r\nb.setIntersectionVariables(intersectionVars);",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {
          "connections": {
            "f": [{
              "active": true,
              "id": -1,
              "id label": "a",
              "mode": "ALL_SUCCEEDING",
              "to": "o"
            }],
            "i": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "f"
            }]
          },
          "f": {
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator",
            "position": [
              5,
              276
            ],
            "start node": true
          },
          "i": {
            "also subclasses": true,
            "class type": "Index",
            "op type": "RuleOperator",
            "position": [
              5,
              5
            ]
          },
          "o": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              547
            ]
          }
        },
        "right side": {
          "b": {
            "also subclasses": false,
            "class type": "AddBinding",
            "op type": "RuleOperator",
            "position": [
              5,
              235
            ]
          },
          "connections": {
            "b": [{
              "active": true,
              "id": -1,
              "id label": "a",
              "mode": "ALL_SUCCEEDING",
              "to": "o"
            }],
            "i": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "b"
            }]
          },
          "i": {
            "also subclasses": false,
            "class type": "Index",
            "op type": "RuleOperator",
            "position": [
              5,
              5
            ]
          },
          "o": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              465
            ]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Construct To Generate": {
      "documentation": {
        "left image": "",
        "long description": "",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "If a Construct has only a Triple Pattern as succeeding operator, we can transform the Construct into Generate operators (for each triple pattern template in the Construct, one Generate operator).",
        "show visual representation": false,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "",
        "additional import declarations": "",
        "check method": {
          "additional code": "",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "",
          "code": "for(lupos.engine.operators.tripleoperator.TriplePattern tp : this.c.getTemplates()) {\n    lupos.engine.operators.singleinput.generate.Generate generate = new lupos.engine.operators.singleinput.generate.Generate(this.t, tp.getItems());\n    generate.setPrecedingOperators(new java.util.ArrayList<lupos.engine.operators.BasicOperator>(this.c.getPrecedingOperators()));\n\n    this.addNodeToStartNodeMapNullCheck(generate, _startNodes);\n\n    for(lupos.engine.operators.BasicOperator prec : generate.getPrecedingOperators()) {\n        prec.addSucceedingOperator(generate);\n    }\n\n    this.t.addPrecedingOperator(generate);\n}\n\nfor (final OperatorIDTuple oidtuple : this.c.getSucceedingOperators()) {\n    oidtuple.getOperator().removePrecedingOperator(this.c);\n}\nfor (final BasicOperator prec : this.c.getPrecedingOperators()) {\n    prec.removeSucceedingOperator(this.c);\n}\nthis.deleteNodeFromStartNodeMapNullCheck(this.c, _startNodes);\n",
          "use generated code": false
        }
      },
      "visual representation": {
        "left side": {
          "c": {
            "also subclasses": false,
            "class type": "Construct",
            "op type": "RuleOperator",
            "position": [
              5,
              5
            ]
          },
          "connections": {"c": [{
            "active": false,
            "id": -1,
            "id label": "",
            "mode": "ONLY_SUCCEEDING",
            "to": "t"
          }]},
          "t": {
            "also subclasses": false,
            "class type": "TriplePattern",
            "op type": "RuleOperator",
            "position": [
              5,
              269
            ]
          }
        },
        "right side": {},
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Factor out AND in Filter": {
      "documentation": {
        "left image": "",
        "long description": "Let c1 and c2 be boolean expressions. Then this rule factors each c1 && c2 top-level operations in Filter expressions out. We present the general transformation rule in the below given figure:",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": ["Push Filter"]
        },
        "short description": "All AND (&&) -operations in filter expressions are factored out.",
        "show visual representation": true,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "private int operandIDOfFilter;",
        "additional import declarations": "",
        "check method": {
          "additional code": "this.operandIDOfFilter = this.b.getOperatorIDTuple(c).getId();\nlupos.sparql1_1.Node n = this.b.getNodePointer();\n\nif(n.jjtGetNumChildren() > 0) {\n    n = n.jjtGetChild(0);\n\n    return (n instanceof lupos.sparql1_1.ASTAndNode);\n}",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "lupos.sparql1_1.Node n = this.b.getNodePointer();\n\nn = n.jjtGetChild(0);\nlupos.sparql1_1.ASTFilterConstraint node1 = new lupos.sparql1_1.ASTFilterConstraint(\t0);\nlupos.sparql1_1.ASTFilterConstraint node2 = new lupos.sparql1_1.ASTFilterConstraint(\t1);\nnode1.jjtAddChild(n.jjtGetChild(0), 0);\nnode2.jjtAddChild(n.jjtGetChild(1), 0);\nn.jjtGetChild(0).jjtSetParent(node1);\nn.jjtGetChild(1).jjtSetParent(node2);\n\nthis.b.setNodePointer(node1);\nb2.setNodePointer(node2);\n\nb2.setCollectionForExistNodes(this.b.getCollectionForExistNodes());\nb2.getUsedEvaluationVisitor().setEvaluator(this.b.getUsedEvaluationVisitor().getEvaluator());\n\nb2.setIntersectionVariables(this.b.getIntersectionVariables());\nb2.setUnionVariables(this.b.getUnionVariables());\nb2.getOperatorIDTuple(c).setId(this.operandIDOfFilter);\n\n",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {
          "a": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              29,
              5
            ]
          },
          "b": {
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator",
            "position": [
              74,
              269
            ],
            "start node": true
          },
          "c": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              29,
              533
            ]
          },
          "connections": {
            "a": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "b"
            }],
            "b": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_SUCCEEDING",
              "to": "c"
            }]
          }
        },
        "right side": {
          "a": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              32,
              5
            ]
          },
          "b": {
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator",
            "position": [
              72,
              236
            ]
          },
          "b2": {
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator",
            "position": [
              66,
              467
            ]
          },
          "c": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              32,
              698
            ]
          },
          "connections": {
            "a": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "b"
            }],
            "b": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "b2"
            }],
            "b2": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_SUCCEEDING",
              "to": "c"
            }]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Factor out OR in Filter": {
      "documentation": {
        "left image": "",
        "long description": "If there Filter expressions with a equal-comparision of a variable with a set of constant values, e.g. Filter(?X=&lt;http://myURL.de&gt; || ?X=\"hello\" || ?X=\"myContent\"^^myURL:myDatatype), then this constant values can be propagated to preceding (RDF3X/Hexastore) Index operators in certain cases. Afterwards, the corresponding variable (here ?X) must be bound with the constant values (here &lt;http://myURL.de&gt;, \"hello\" and \"myContent\"^^myURL:myDatatype), e.g. ?Y ?Z ?X. Filter(?X=&lt;http://myURL.de&gt; || ?X=\"hello\" || ?X=\"myContent\"^^myURL:myDatatype) is transformed into {?Y ?Z &lt;http://myURL.de&gt;. AddBinding(?X=&lt;http://myURL.de&gt;)} UNION {?Y ?Z \"hello\". AddBinding(?X=\"hello\")} UNION { ?Y ?Z \"myContent\"^^myURL:myDatatype. AddBinding(?X=\"myContent\"^^myURL:myDatatype)}. However, there are problems with this approach if one of the constant values can be value-equal with another constant value using a different representation, e.g. +01^^xsd:int is value-equal, but not identical to 1^^xsd:int. Thus, this transformation rule is not applied whenever one of the constant values is a numerical value or a language tagged literal.\n\nThe following figure contains the graphical representation of the transformation rule.",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": [
            "Variable Propagation",
            "Constant Propagation of Filter in Index With Additional Operators Between",
            "ConstantPropagation of Filter in Index"
          ]
        },
        "short description": "This rule implements constant propagation for a set of constants.",
        "show visual representation": true,
        "transition text": "c1, ..., cn are neither numerical values nor language tagged literals",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "int operandID;",
        "additional import declarations": "import lupos.datastructures.items.Variable;",
        "check method": {
          "additional code": "lupos.sparql1_1.Node n = this.f.getNodePointer();\n\nthis.operandID = this.f.getOperatorIDTuple(this.o).getId();\n\nif(this.i.getSucceedingOperators().size()>1)\n   return false;\n            \nif(n.jjtGetNumChildren() > 0) {\n    n = n.jjtGetChild(0);\n\n    return (n instanceof lupos.sparql1_1.ASTOrNode);\n}",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "// --- update index - begin ---\nlupos.engine.operators.index.BasicIndexScan i2 = (lupos.engine.operators.index.BasicIndexScan) this.i.clone();\nthis.addNodeToStartNodeMapNullCheck(i2, _startNodes);\n\njava.util.LinkedList<lupos.engine.operators.tripleoperator.TriplePattern> lltp = new java.util.LinkedList<lupos.engine.operators.tripleoperator.TriplePattern>();\n\nfor(lupos.engine.operators.tripleoperator.TriplePattern tp : this.i.getTriplePattern()) {\n    lltp.add(tp.clone());\n}\n\ni2.setTriplePatterns(lltp);\n\nthis.op.addSucceedingOperator(i2);\ni2.setPrecedingOperator(this.op);\n// --- update index - end ---\n\n\n// --- update filter - begin ---\nlupos.sparql1_1.Node n = this.f.getNodePointer();\n\nn = n.jjtGetChild(0);\nlupos.sparql1_1.ASTFilterConstraint node1 = new lupos.sparql1_1.ASTFilterConstraint(0);\nlupos.sparql1_1.ASTFilterConstraint node2 = new lupos.sparql1_1.ASTFilterConstraint(1);\nnode1.jjtAddChild(n.jjtGetChild(0), 0);\nnode2.jjtAddChild(n.jjtGetChild(1), 0);\nn.jjtGetChild(0).jjtSetParent(node1);\nn.jjtGetChild(1).jjtSetParent(node2);\n\nthis.f.setNodePointer(node1);\nf2.setNodePointer(node2);\n\nf2.setCollectionForExistNodes(this.f.getCollectionForExistNodes());\nf2.setEvaluator(this.f.getUsedEvaluationVisitor().getEvaluator());\nf2.getUsedEvaluationVisitor().setEvaluator(this.f.getUsedEvaluationVisitor().getEvaluator());\n\n\nf2.setIntersectionVariables(this.f.getIntersectionVariables());\nf2.setUnionVariables(this.f.getUnionVariables());\n// --- update filter - end ---\n\n\n// --- clone jump-over operators - begin ---\nBasicOperator tmpOp = this.i.getSucceedingOperators().get(0).getOperator();\nBasicOperator parentOp = i2;\n\nwhile(!tmpOp.equals(this.f)) {\n    BasicOperator newOp = tmpOp.clone();\n    this.addNodeToStartNodeMapNullCheck(newOp, _startNodes);\n\n    parentOp.setSucceedingOperator(new lupos.engine.operators.OperatorIDTuple(newOp, 0));\n    newOp.setPrecedingOperator(parentOp);\n\n    parentOp = newOp;\n    tmpOp = tmpOp.getSucceedingOperators().get(0).getOperator();\n}\n\nparentOp.setSucceedingOperator(new lupos.engine.operators.OperatorIDTuple(f2, 0));\nf2.addPrecedingOperator(parentOp);\n// --- clone jump-over operators - end ---\nu.getOperatorIDTuple(this.o).setId(this.operandID);\nu.setIntersectionVariables(new HashSet<Variable>(this.f.getIntersectionVariables()));\nu.setUnionVariables(new HashSet<Variable>(this.f.getUnionVariables()));",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {
          "connections": {
            "f": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_SUCCEEDING",
              "to": "o"
            }],
            "i": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "j"
            }],
            "j": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "f"
            }],
            "op": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "i"
            }]
          },
          "f": {
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator",
            "position": [
              68,
              807
            ],
            "start node": true
          },
          "i": {
            "also subclasses": true,
            "class type": "Index",
            "op type": "RuleOperator",
            "position": [
              68,
              269
            ]
          },
          "j": {
            "also subclasses": false,
            "cardinality": "*",
            "class type": "Filter",
            "conditions": "",
            "op type": "JumpOverOperator",
            "position": [
              16,
              533
            ]
          },
          "o": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              46,
              1071
            ]
          },
          "op": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              57,
              5
            ]
          }
        },
        "right side": {
          "connections": {
            "f": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "u"
            }],
            "f2": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "u"
            }],
            "i": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "j"
            }],
            "j": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "f"
            }],
            "op": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "i"
            }],
            "u": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_SUCCEEDING",
              "to": "o"
            }]
          },
          "f": {
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator",
            "position": [
              83,
              698
            ]
          },
          "f2": {
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator",
            "position": [
              1238,
              691
            ]
          },
          "i": {
            "also subclasses": false,
            "class type": "Index",
            "op type": "RuleOperator",
            "position": [
              109,
              236
            ]
          },
          "j": {
            "also subclasses": false,
            "cardinality": "*",
            "class type": "Filter",
            "conditions": "",
            "op type": "JumpOverOperator",
            "position": [
              31,
              467
            ]
          },
          "o": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              646,
              1155
            ]
          },
          "op": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              57,
              5
            ]
          },
          "u": {
            "also subclasses": false,
            "class type": "Union",
            "op type": "RuleOperator",
            "position": [
              644,
              926
            ]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Generate Pat ConstructPredicate": {
      "documentation": {
        "left image": "",
        "long description": "",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "A generated predicate is immediately consumed from a Predicate Pattern. This transformation rule reduces this to the direct assignment of variables.",
        "show visual representation": false,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "",
        "additional import declarations": "",
        "check method": {
          "additional code": "return this.c.getPredicatePattern().size() == 1;",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "",
          "code": "final lupos.datastructures.items.literal.URILiteral patURI = this.p.getPredicateName();\n\t\tfinal lupos.datastructures.items.Item[] patItems = this.p.getPatternItems().toArray(new lupos.datastructures.items.Item[] {});\n\n\t\tfinal lupos.datastructures.items.literal.URILiteral constructURI = this.c.getPredicatePattern().get(0)\n\t\t\t\t.getFirst();\n\t\tfinal lupos.datastructures.items.Item[] constructItems = this.c.getPredicatePattern().get(0)\n\t\t\t\t.getSecond().toArray(new lupos.datastructures.items.Item[] {});\n\n\t\tlupos.rif.operator.RuleFilter filter = null;\n\t\tfinal lupos.engine.operators.singleinput.ReplaceVar replaceVar = new lupos.engine.operators.singleinput.ReplaceVar();\n\t\treplaceVar.setIntersectionVariables(new java.util.HashSet<lupos.datastructures.items.Variable>());\n\t\treplaceVar.setUnionVariables(replaceVar.getIntersectionVariables());\n\n\t\tfinal java.util.LinkedList<lupos.datastructures.items.Variable> addBindingsVar = new java.util.LinkedList<lupos.datastructures.items.Variable>();\n\t\tfinal java.util.LinkedList<lupos.datastructures.items.literal.Literal> addBindingsLit = new java.util.LinkedList<lupos.datastructures.items.literal.Literal>();\n\n\t\tif (!patURI.equals(constructURI)\n\t\t\t\t|| patItems.length != constructItems.length) {\n\t\t\tfor (final BasicOperator parent : this.c.getPrecedingOperators())\n\t\t\t\tparent.removeSucceedingOperator(this.c);\n\t\t\tthis.c.getPrecedingOperators().clear();\n\t\t\tthis.c.removeFromOperatorGraph();\n\t\t\treturn;\n\t\t}\n\n\t\tfinal lupos.rif.model.Conjunction conj = new lupos.rif.model.Conjunction();\n\t\tfor (int i = 0; i < patItems.length; i++) {\n\t\t\tfinal lupos.datastructures.items.Item patItem = patItems[i];\n\t\t\tfinal lupos.datastructures.items.Item constructItem = constructItems[i];\n\t\t\tif ((!patItem.isVariable()) && constructItem.isVariable()) {\n\t\t\t\t{\n\t\t\t\t\tfinal lupos.rif.model.Equality eq = new lupos.rif.model.Equality();\n\t\t\t\t\teq.leftExpr = new lupos.rif.model.RuleVariable(constructItem.getName());\n\t\t\t\t\teq.rightExpr = new lupos.rif.model.Constant((lupos.datastructures.items.literal.Literal) patItem, eq);\n\t\t\t\t\tconj.addExpr(eq);\n\t\t\t\t}\n\t\t\t} else if (patItem.isVariable() && constructItem.isVariable()) {\n\t\t\t\treplaceVar.addSubstitution((lupos.datastructures.items.Variable) patItem,\n\t\t\t\t\t\t(lupos.datastructures.items.Variable) constructItem);\n\t\t\t\treplaceVar.getIntersectionVariables().add((lupos.datastructures.items.Variable) patItem);\n\t\t\t} else if (patItem.isVariable() && (!constructItem.isVariable())) {\n\t\t\t\taddBindingsVar.add((lupos.datastructures.items.Variable) patItem);\n\t\t\t\taddBindingsLit.add((lupos.datastructures.items.literal.Literal) constructItem);\n\t\t\t} else if (!patItem.isVariable() && !constructItem.isVariable()\n\t\t\t\t\t&& !constructItem.equals(patItem)) {\n\t\t\t\t// cannot match, remove generate.\n\t\t\t\tfor (final BasicOperator parent : this.c.getPrecedingOperators())\n\t\t\t\t\tparent.removeSucceedingOperator(this.c);\n\t\t\t\tthis.c.getPrecedingOperators().clear();\n\t\t\t\tthis.p.removePrecedingOperator(this.c);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tfor (int x = i + 1; x < patItems.length; x++) {\n\t\t\t\tif (patItems[i].equals(patItems[x])) {\n\t\t\t\t\tfinal lupos.rif.model.Equality eq = new lupos.rif.model.Equality();\n\t\t\t\t\tif (constructItems[i].isVariable())\n\t\t\t\t\t\teq.leftExpr = new lupos.rif.model.RuleVariable(\n\t\t\t\t\t\t\t\tconstructItems[i].getName());\n\t\t\t\t\telse\n\t\t\t\t\t\teq.leftExpr = new lupos.rif.model.Constant((lupos.datastructures.items.literal.Literal) constructItems[i],\n\t\t\t\t\t\t\t\teq);\n\t\t\t\t\tif (constructItems[x].isVariable())\n\t\t\t\t\t\teq.rightExpr = new lupos.rif.model.RuleVariable(\n\t\t\t\t\t\t\t\tconstructItems[x].getName());\n\t\t\t\t\telse\n\t\t\t\t\t\teq.rightExpr = new lupos.rif.model.Constant(\n\t\t\t\t\t\t\t\t(lupos.datastructures.items.literal.Literal) constructItems[x], eq);\n\t\t\t\t\tconj.addExpr(eq);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!conj.isEmpty())\n\t\t\tfilter = new lupos.rif.operator.RuleFilter(conj, null);\n\n\t\t// Only Operators with a not empty definition are put into the\n\t\t// operatorgraph\n\t\tfinal java.util.LinkedList<BasicOperator> order = new java.util.LinkedList<BasicOperator>();\n\t\tif (filter != null) {\n\t\t\torder.add(filter);\n\t\t}\n\n\t\tfinal int substVar = replaceVar.getSubstitutionsVariableLeft().size();\n\n\t\tif (substVar > 0) {\n\t\t\torder.add(replaceVar);\n\t\t} else {\n\t\t\tfinal lupos.engine.operators.singleinput.Projection p = new lupos.engine.operators.singleinput.Projection();\n\t\t\tp.setIntersectionVariables(new java.util.HashSet<lupos.datastructures.items.Variable>());\n\t\t\tp.setUnionVariables(p.getUnionVariables());\n\t\t\torder.add(p);\n\t\t}\n\t\tif (addBindingsVar.size() > 0) {\n\t\t\tfinal java.util.Iterator<lupos.datastructures.items.literal.Literal> lit_it = addBindingsLit.iterator();\n\t\t\tfinal java.util.HashSet<lupos.datastructures.items.Variable> hsv = new java.util.HashSet<lupos.datastructures.items.Variable>();\n\t\t\thsv.addAll(replaceVar.getUnionVariables());\n\t\t\tfor (final lupos.datastructures.items.Variable v : addBindingsVar) {\n\t\t\t\tfinal lupos.engine.operators.singleinput.AddBinding ab = new lupos.engine.operators.singleinput.AddBinding(v, lit_it.next());\n\t\t\t\thsv.add(v);\n\t\t\t\tab.setIntersectionVariables((java.util.HashSet<lupos.datastructures.items.Variable>) hsv.clone());\n\t\t\t\tab.setUnionVariables(ab.getIntersectionVariables());\n\t\t\t\torder.add(ab);\n\t\t\t}\n\t\t}\n\n\t\t// In case that Generate or TriplePattern has minimum one variable, than\n\t\t// minimum one operator has to be inserted\n\t\tif (order.size() > 0) {\n\t\t\tfinal java.util.LinkedList<BasicOperator> pres = (java.util.LinkedList<BasicOperator>) this.c.getPrecedingOperators();\n\t\t\tBasicOperator pre;\n\t\t\tfor (int i = 0; i < pres.size(); i++) {\n\t\t\t\tpre = pres.get(i);\n\t\t\t\tpre.addSucceedingOperator(new OperatorIDTuple(order.getFirst(),\n\t\t\t\t\t\t0));\n\t\t\t\tif (filter != null) {\n\t\t\t\t\tjava.util.Collection<lupos.datastructures.items.Variable> vars = filter\n\t\t\t\t\t\t\t.getIntersectionVariables();\n\t\t\t\t\tif (vars == null)\n\t\t\t\t\t\tvars = new java.util.HashSet<lupos.datastructures.items.Variable>();\n\t\t\t\t\tvars.addAll(pre.getIntersectionVariables());\n\t\t\t\t\tfilter.setIntersectionVariables(vars);\n\t\t\t\t\tfilter.setUnionVariables(vars);\n\t\t\t\t}\n\t\t\t\tpre.removeSucceedingOperator(this.c);\n\t\t\t\torder.getFirst().addPrecedingOperator(pre);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < order.size() - 1; i++) {\n\t\t\t\torder.get(i + 1).setPrecedingOperator(order.get(i));\n\t\t\t\torder.get(i).setSucceedingOperator(\n\t\t\t\t\t\tnew OperatorIDTuple(order.get(i + 1), 0));\n\t\t\t}\n\n\t\t\tfinal java.util.List<OperatorIDTuple> succs = (java.util.List<OperatorIDTuple>) this.p.getSucceedingOperators();\n\t\t\tfor (int i = 0; i < succs.size(); i++) {\n\t\t\t\tsuccs.get(i).getOperator()\n\t\t\t\t\t\t.addPrecedingOperator(order.getLast());\n\t\t\t}\n\n\t\t\tfinal java.util.LinkedList<OperatorIDTuple> sops = new java.util.LinkedList<OperatorIDTuple>();\n\t\t\tsops.addAll(this.p.getSucceedingOperators());\n\t\t\torder.getLast().setSucceedingOperators(sops);\n\t\t} else {\n\t\t\tfinal java.util.LinkedList<BasicOperator> pres = (java.util.LinkedList<BasicOperator>) this.c.getPrecedingOperators();\n\t\t\tfinal java.util.LinkedList<OperatorIDTuple> succs = (java.util.LinkedList<OperatorIDTuple>) this.p.getSucceedingOperators();\n\t\t\tBasicOperator pre;\n\t\t\tBasicOperator succ;\n\t\t\tfor (int i = 0; i < pres.size(); i++) {\n\t\t\t\tpre = pres.get(i);\n\t\t\t\tpre.removeSucceedingOperator(this.c);\n\t\t\t\tfor (int x = 0; x < succs.size(); x++) {\n\t\t\t\t\tpre.addSucceedingOperator(succs.get(x));\n\t\t\t\t\tsucc = succs.get(x).getOperator();\n\t\t\t\t\tsucc.removePrecedingOperator(this.p);\n\t\t\t\t\tsucc.addPrecedingOperator(pre);\n\t\t\t\t}\n\t\t\t}\n\t\t}",
          "use generated code": false
        }
      },
      "visual representation": {
        "left side": {
          "c": {
            "also subclasses": false,
            "class type": "ConstructPredicate",
            "op type": "RuleOperator",
            "position": [
              5,
              5
            ]
          },
          "connections": {"c": [{
            "active": false,
            "id": -1,
            "id label": "",
            "mode": "ONLY_SUCCEEDING",
            "to": "p"
          }]},
          "p": {
            "also subclasses": false,
            "class type": "PredicatePattern",
            "op type": "RuleOperator",
            "position": [
              5,
              269
            ]
          }
        },
        "right side": {},
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "HashSetNonBlockingDistinctWithIndexAccess": {
      "documentation": {
        "left image": "",
        "long description": "",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "",
        "show visual representation": true,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "",
        "additional import declarations": "import lupos.engine.operators.singleinput.modifiers.distinct.HashSetNonBlockingDistinctWithIndexAccess;",
        "check method": {
          "additional code": "// check if there is only one index scan operator\r\nif(this.d instanceof HashSetNonBlockingDistinctWithIndexAccess){\r\n\treturn false;\r\n}\r\nfor(BasicOperator prec: this.d.getPrecedingOperators()){\r\n\tif(prec instanceof lupos.engine.operators.index.BasicIndexScan){\r\n\t\tif(!prec.equals(this.i)){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n}\r\n",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "",
          "code": "HashSetNonBlockingDistinctWithIndexAccess distinct_new = new HashSetNonBlockingDistinctWithIndexAccess(this.i);\r\nthis.d.replaceWith(distinct_new);\r\nthis.deleteNodeFromStartNodeMapNullCheck(this.d, _startNodes);\r\nthis.addNodeToStartNodeMapNullCheck(distinct_new, _startNodes);\r\ndistinct_new.setPrecedingOperators(this.d.getPrecedingOperators());\r\ndistinct_new.setSucceedingOperators(this.d.getSucceedingOperators());\r\n// now correct operandID of BasicIndexScan operand to 0 and the other to 1 (requirement of the HashSetNonBlockingDistinctWithIndexAccess-operator!)\r\nfor(BasicOperator bo: distinct_new.getPrecedingOperators()){\r\n\tint operandID = (bo instanceof lupos.engine.operators.index.BasicIndexScan)? 0: 1;\r\n\tbo.getOperatorIDTuple(distinct_new).setId(operandID);\r\n}",
          "use generated code": false
        }
      },
      "visual representation": {
        "left side": {
          "connections": {"i": [{
            "active": false,
            "id": -1,
            "id label": "",
            "mode": "EXISTS",
            "to": "d"
          }]},
          "d": {
            "also subclasses": true,
            "class type": "Distinct",
            "op type": "RuleOperator",
            "position": [
              5,
              276
            ]
          },
          "i": {
            "also subclasses": true,
            "class type": "Index",
            "op type": "RuleOperator",
            "position": [
              5,
              5
            ]
          }
        },
        "right side": {},
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Merge Memory Indexes": {
      "documentation": {
        "left image": "",
        "long description": "",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "A Join operator joining several Memory Index Scans is replaced by one Memory Index Scan containing all Triple Patterns of the Memory Index Scan operators of the Join operator.",
        "show visual representation": true,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "",
        "additional import declarations": "",
        "check method": {
          "additional code": "if(this._dim_0<=1)\r\n   return false;",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "",
          "code": "        // remove obsolete connections...\n        for(lupos.engine.operators.index.memoryindex.MemoryIndexScan _parent : this.i) {\n            _parent.removeSucceedingOperator(this.j);\n            this.j.removePrecedingOperator(_parent);\n        }\n\n        for(this._dim_0 = 0; this._dim_0 < this.o1.length; this._dim_0 += 1) {\n            this.o1[this._dim_0].removeSucceedingOperator(this.i[this._dim_0]);\n            this.i[this._dim_0].removePrecedingOperator(this.o1[this._dim_0]);\n        }\n        this.j.removeSucceedingOperator(this.o2);\n        this.o2.removePrecedingOperator(this.j);\n\n        // add new operators...\n        lupos.engine.operators.index.memoryindex.MemoryIndexScan i_new = null;\n        i_new = new lupos.engine.operators.index.memoryindex.MemoryIndexScan(this.i[0].getRoot());\n\n\n        // add new connections...\n        i_new.addSucceedingOperator(this.o2);\n        this.o2.addPrecedingOperator(i_new);\n\n        this.o1[0].addSucceedingOperator(i_new);\n        i_new.addPrecedingOperator(this.o1[0]);\n\n\n        // delete unreachable operators...\n        this.deleteOperatorWithoutParentsRecursive(this.j, _startNodes);\n        for(this._dim_0 = 0; this._dim_0 < i.length; this._dim_0 += 1) {\n            this.deleteOperatorWithoutParentsRecursive(this.i[this._dim_0], _startNodes);\n        }\n\n\n\n        // additional replace method code...\n        i_new.setTriplePatterns(new java.util.LinkedList<lupos.engine.operators.tripleoperator.TriplePattern>());\n        for(lupos.engine.operators.index.memoryindex.MemoryIndexScan index : this.i) {\n            i_new.getTriplePattern().addAll(index.getTriplePattern());\n        \n            i_new.getIntersectionVariables().addAll(index.getIntersectionVariables());\n            i_new.getUnionVariables().addAll(index.getUnionVariables());\n        }",
          "use generated code": false
        }
      },
      "visual representation": {
        "left side": {
          "connections": {
            "i": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ALL_PRECEDING",
              "to": "j"
            }],
            "j": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_SUCCEEDING",
              "to": "o2"
            }],
            "o1": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING",
              "to": "i"
            }]
          },
          "i": {
            "also subclasses": true,
            "class type": "MemoryIndex",
            "op type": "RuleOperator",
            "position": [
              5,
              269
            ]
          },
          "j": {
            "also subclasses": true,
            "class type": "Join",
            "op type": "RuleOperator",
            "position": [
              6,
              533
            ],
            "start node": true
          },
          "o1": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              8,
              5
            ]
          },
          "o2": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              8,
              797
            ]
          }
        },
        "right side": {
          "connections": {
            "i_new": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_SUCCEEDING",
              "to": "o2"
            }],
            "o1": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING",
              "to": "i_new"
            }]
          },
          "i_new": {
            "also subclasses": false,
            "class type": "MemoryIndex",
            "op type": "RuleOperator",
            "position": [
              5,
              236
            ]
          },
          "o1": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              5
            ]
          },
          "o2": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              467
            ]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Optimizing Join Order": {
      "documentation": {
        "left image": "",
        "long description": "We have two different types of query optimizers.\n\nThe first type is a simple query optimizer, which generates right-order trees for the overall join computation. This type of query optimizer just joins the intermediate result of a previous join with the result of that triple pattern, which have (a) the smallest number of results, (b) the smallest number of new bound variables, or (c) a combination of both, i.e. the query optimizers uses (b) as primary and (c) as secondary criterion. This query optimizer is used for the Index-approach (except with the optimization option set to BINARY). The Stream approach can only use (b) as criterion as the query has to be optimized before the data arrives as stream.\n\nThe previous type of query optimizer does not consider the number of results after one or more join computations, which considers our second type of query optimizer. This second type of query optimizer is used for the RDF3X (- Presorting), Hexastore (- Presorting) and Index (with optimization option set to BINARY) approaches.\n\nFor the second type of query optimizer, we use equi-depth histograms [1] for the join cardinality estimation in order to calculate the cost of each join and thus the overall cost of a concrete plan. We employ the technique of the dynamic programming for generating the execution plan with the optimal join order, i.e. our query optimizer composes a new best solution by considering the best solutions of its subproblems. In more detail, for a set S of triple patterns, our query optimizer builds every possible disjoint subsets S1 and S2, the union of which is S, i.e. S = S1 union S2. For each of these subsets S1 and S2, our query optimizer looks up the best solutions for their join orderings, which has been computed earlier, and calculates a new cost for this solution. Among these solutions, our query optimizer chooses the ones with the minimal costs for the overall solution for S.\n\nA merge join can be computed using different collation orders. For example, a merge join can be applied to compute the triple patterns ?a <type> ?b and <book> ?b ?a, using either ?a as the primary order, or ?b as the primary order. In order to reduce the number of intermediate plans, our query optimizer only checks whether or not a merge join can be applied, but does not store the collation orders used to compute the join at this step. The used collation orders for answering the single triple patterns are fixed (and stored) in the last step, when the whole plan is considered.\n\nSince merge joins without additional sorting phases are very cheap, our query optimizer chooses merge joins without additional sorting phases as much as possible.\n\n[1] Piatetsky-Shapiro G., Connell C.: Accurate Estimation of the Number of Tuples Satisfying a Condition. SIGMOD Conf., 1984.",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "The join order is optimized by etimating the cardinality of the result of single joins and first joining those, which have the estimated smallest number of intermediate results.",
        "show visual representation": false,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "",
        "additional import declarations": "",
        "check method": {
          "additional code": "",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {},
        "right side": {},
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Physical Optimization Rule": {
      "documentation": {
        "left image": "",
        "long description": "This transformation rule considers several aspects.\n\nThis transformation rule chooses the concrete algorithm for a logical operator according to the option, if the memory-based variant of our prototype is used (where all the data remains in the main memory), or the disk-based variant is used (where the indices and the intermediate results on demand are stored on disk).\n\nFurthermore, this transformation rule considers specific preferences of the user for specific algorithms. This means that the user can specify (e.g. per command line option) to use e.g. the DBMergeSortedBagMergeJoin as default Join algorithm, which is considered in this transformation rule.\n\nFor the Sort operator, the transformation rule checks, whether the intermediate result is already sorted in the correct way (or can be retrieved in a sorted way), such that the Sort operator can be left out.\n\nFor the Distinct operator, this transformation rule checks whether or not the intermediate data is sorted in the correct way, such that the effcient SortedDataDistinct operator can be used.",
        "right image": "",
        "see also": {
          "rule packages": ["Physical Optimization"],
          "rules": []
        },
        "short description": "Physical optimization aims to choose the algorithm with the best estimated execution times in the context of the operator for each operator in the operator graph.",
        "show visual representation": false,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "",
        "additional import declarations": "",
        "check method": {
          "additional code": "",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {},
        "right side": {},
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Projection Over Sort": {
      "documentation": {
        "left image": "",
        "long description": "",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "If the list of variables of the projection operator contains all variables of the sort criterium, then we can move the projection operator above the Sort criterium.",
        "show visual representation": true,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "",
        "additional import declarations": "",
        "check method": {
          "additional code": "final java.util.Collection<lupos.datastructures.items.Variable> sortCrit = this.sort.getSortCriterium();\r\nif (sortCrit != null && this.projection.getProjectedVariables().containsAll(sortCrit))\r\n\treturn true;\r\nelse return false;",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "final java.util.Collection<lupos.datastructures.items.Variable> cv = new java.util.LinkedList<lupos.datastructures.items.Variable>();\r\ncv.addAll(this.projection.getProjectedVariables());\r\nthis.sort.setIntersectionVariables(cv);\r\nthis.sort.setUnionVariables(cv);",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {
          "above": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              17,
              5
            ]
          },
          "below": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              15,
              915
            ]
          },
          "connections": {
            "above": [{
              "active": true,
              "id": -1,
              "id label": "a",
              "mode": "ALL_PRECEDING",
              "to": "sort"
            }],
            "projection": [{
              "active": true,
              "id": -1,
              "id label": "b",
              "mode": "ALL_SUCCEEDING",
              "to": "below"
            }],
            "sort": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "projection"
            }]
          },
          "projection": {
            "also subclasses": false,
            "class type": "Projection",
            "op type": "RuleOperator",
            "position": [
              14,
              611
            ]
          },
          "sort": {
            "also subclasses": false,
            "class type": "Sort",
            "op type": "RuleOperator",
            "position": [
              15,
              318
            ],
            "start node": true
          }
        },
        "right side": {
          "above": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              17,
              5
            ]
          },
          "below": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              14,
              787
            ]
          },
          "connections": {
            "above": [{
              "active": true,
              "id": -1,
              "id label": "a",
              "mode": "ALL_PRECEDING",
              "to": "projection"
            }],
            "projection": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "sort"
            }],
            "sort": [{
              "active": true,
              "id": -1,
              "id label": "b",
              "mode": "ALL_SUCCEEDING",
              "to": "below"
            }]
          },
          "projection": {
            "also subclasses": false,
            "class type": "Projection",
            "op type": "RuleOperator",
            "position": [
              3,
              279
            ]
          },
          "sort": {
            "also subclasses": false,
            "class type": "Sort",
            "op type": "RuleOperator",
            "position": [
              21,
              534
            ]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Push Filter": {
      "documentation": {
        "left image": "",
        "long description": "The filter is copied over its preceding operator, if the preceding operator is not a triple pattern or an (RDF3X/Hexastore) Index-operator. The filter operator is copied to those operands of the preceding operator, which bind all variables occurring in the filter expression. If the preceding operator is an Union operator, the filter operator is only copied if it can be moved to all of its operands. Currently, the filter is not moved in the case that the preceding operator is an Optional operator. The original filter is deleted if all the operand operators O1 to On of its preceding operator bind all of the used variables of the filter, or if the preceding operator is a Join operator.\n\nThe following figure contains the graphical representation of the transformation rule.",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": ["Factor out AND in Filter"]
        },
        "short description": "Filter operators never increase, but reduce the number of intermediate results in most times. Thus, it is important for the performance to evaluate a filter expression as early as possible. This rule pushes a filter operator upwards in the operator graph whenever possible.",
        "show visual representation": true,
        "transition text": "op is neither a triple pattern nor an (RDF3X/Hexastore) Index operator nor an Optional operator. if op is an Union operator, O1 to On must bind all variables occuring in c.",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "",
        "additional import declarations": "",
        "check method": {
          "additional code": "if(this.op instanceof lupos.engine.operators.tripleoperator.TriplePattern || this.op instanceof lupos.engine.operators.index.BasicIndexScan || this.op instanceof lupos.engine.operators.index.Root) {\n    return false;\n}\n\nif(this.op instanceof lupos.engine.operators.multiinput.Union) {\n    for(BasicOperator o : this.op.getPrecedingOperators()) {\n        if(o.getSucceedingOperators().size() > 1 || (o instanceof lupos.engine.operators.singleinput.Filter && this.f.equalFilterExpression((lupos.engine.operators.singleinput.Filter) o))) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nif(this.op instanceof lupos.engine.operators.multiinput.optional.Optional || this.op instanceof lupos.engine.operators.multiinput.optional.parallel.ParallelOptional || this.op instanceof lupos.engine.operators.multiinput.optional.parallel.MergeParallelOptional) {\n    if(this.op.getPrecedingOperators().size() == 2) {\n        BasicOperator o = this.op.getPrecedingOperatorWithID(0);\n\n        if(o.getUnionVariables().containsAll(this.f.getUsedVariables()) && !(o instanceof lupos.engine.operators.singleinput.Filter && this.f.equalFilterExpression((lupos.engine.operators.singleinput.Filter) o))) {\n        return true;\n        }\n    }\n\n    return false;\n}\n\nif(this.op instanceof lupos.engine.operators.multiinput.join.Join) {\n    // check if the join has preceding this.ops in a loop\n    if(this.op.getCycleOperands() != null && this.op.getCycleOperands().size() > 0) {\n        return false;\n    }\n}\n\nfor(BasicOperator o : this.op.getPrecedingOperators()) {\n    if(o.getSucceedingOperators().size() == 1 && o.getUnionVariables().containsAll(this.f.getUsedVariables()) && !(o instanceof lupos.engine.operators.singleinput.Filter && this.f.equalFilterExpression((lupos.engine.operators.singleinput.Filter) o))) {\n        return true;\n    }\n}\n\nreturn false;",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "boolean deleteFilter = true;\n\nfor(int i = 0; i < this.o.length; i += 1) {\n    BasicOperator o2 = this.o[i];\n\n    if(!(o2 instanceof lupos.engine.operators.singleinput.Filter && this.f.equalFilterExpression((lupos.engine.operators.singleinput.Filter) o2))) {\n        if(o2.getUnionVariables().containsAll(this.f.getUsedVariables())) {\n            f_new[i].setIntersectionVariables(new HashSet<lupos.datastructures.items.Variable>(o2.getUnionVariables()));\n            f_new[i].setUnionVariables(new HashSet<lupos.datastructures.items.Variable>(o2.getUnionVariables()));\n            f_new[i].setNodePointer(this.f.getNodePointer());\n        } else {\n            if(deleteFilter) {\n                for(lupos.datastructures.items.Variable v : o2.getUnionVariables()) {\n                    if(this.f.getUsedVariables().contains(v)) {\n                        deleteFilter = false;\n\n                        break;\n                    }\n                }\n            }\n\n            this.deleteOperator(f_new[i], _startNodes);\n        }\n    }\n}\n\nif(deleteFilter || this.op instanceof lupos.engine.operators.multiinput.join.Join) {\n    this.deleteOperator(this.f, _startNodes);\n}",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {
          "connections": {
            "f": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "op2"
            }],
            "j": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "f"
            }],
            "o": [{
              "active": true,
              "id": -1,
              "id label": "a",
              "mode": "ALL_PRECEDING",
              "to": "op"
            }],
            "op": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "j"
            }]
          },
          "f": {
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator",
            "position": [
              68,
              807
            ],
            "start node": true
          },
          "j": {
            "also subclasses": false,
            "cardinality": "*",
            "class type": "Filter",
            "conditions": "",
            "op type": "JumpOverOperator",
            "position": [
              16,
              533
            ]
          },
          "o": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              57,
              5
            ]
          },
          "op": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              68,
              269
            ]
          },
          "op2": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              46,
              1071
            ]
          }
        },
        "right side": {
          "connections": {
            "f": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "op2"
            }],
            "f_new": [{
              "active": true,
              "id": -1,
              "id label": "a",
              "mode": "ALL_PRECEDING",
              "to": "op"
            }],
            "j": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "f"
            }],
            "o": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "f_new"
            }],
            "op": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "j"
            }]
          },
          "f": {
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator",
            "position": [
              57,
              929
            ]
          },
          "f_new": {
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator",
            "position": [
              109,
              236
            ]
          },
          "j": {
            "also subclasses": false,
            "cardinality": "*",
            "class type": "Filter",
            "conditions": "",
            "op type": "JumpOverOperator",
            "position": [
              109,
              698
            ]
          },
          "o": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              57,
              5
            ]
          },
          "op": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              57,
              467
            ]
          },
          "op2": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              57,
              1160
            ]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Push RuleFilter": {
      "documentation": {
        "left image": "",
        "long description": "",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": ["Push Filter"]
        },
        "short description": "Analogous to the Push Filter rule for SPARQL Filter operators, this transformation rule moves a RIF Filter operator in the operator graph, such that it is processed as early as possible in order to filter out intermediate solutions as early as possible and thus saving processing costs.",
        "show visual representation": true,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "",
        "additional import declarations": "",
        "check method": {
          "additional code": "if(this.op instanceof lupos.engine.operators.tripleoperator.TriplePattern || this.op instanceof lupos.engine.operators.index.BasicIndexScan || this.op instanceof lupos.engine.operators.index.Root) {\n    return false;\n}\n\nif(this.op instanceof lupos.engine.operators.multiinput.Union) {\n    for(BasicOperator o : this.op.getPrecedingOperators()) {\n        if(o.getSucceedingOperators().size() > 1 || (o instanceof lupos.rif.operator.RuleFilter && this.f.equalFilterExpression((lupos.rif.operator.RuleFilter) o))) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nif(this.op instanceof lupos.engine.operators.multiinput.optional.Optional || this.op instanceof lupos.engine.operators.multiinput.optional.parallel.ParallelOptional || this.op instanceof lupos.engine.operators.multiinput.optional.parallel.MergeParallelOptional) {\n    if(this.op.getPrecedingOperators().size() == 2) {\n       BasicOperator o = this.op.getPrecedingOperatorWithID(0);\n\n        if(o.getUnionVariables().containsAll(this.f.getVariablesInExpression()) && !(o instanceof lupos.rif.operator.RuleFilter && this.f.equalFilterExpression((lupos.rif.operator.RuleFilter) o))) {\n           return true;\n        }\n    }\n\n    return false;\n}\n\nif(this.op instanceof lupos.engine.operators.multiinput.join.Join) {\n    // check if the join has preceding this.ops in a loop\n    if(this.op.getCycleOperands() != null && this.op.getCycleOperands().size() > 0) {\n        return false;\n    }\n}\n\nfor(BasicOperator o : this.op.getPrecedingOperators()) {\n    if(o.getSucceedingOperators().size() == 1 && o.getUnionVariables().containsAll(this.f.getVariablesInExpression()) && !(o instanceof lupos.rif.operator.RuleFilter && this.f.equalFilterExpression((lupos.rif.operator.RuleFilter) o))) {\n        return true;\n    }\n}\n\nreturn false;",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "boolean deleteFilter = true;\n\nfor(int i = 0; i < this.o.length; i += 1) {\n    BasicOperator o2 = this.o[i];\n\n    if(!(o2 instanceof lupos.rif.operator.RuleFilter && this.f.equalFilterExpression((lupos.rif.operator.RuleFilter) o2))) {\n        if(o2.getUnionVariables().containsAll(this.f.getVariablesInExpression())) {\n            f_new[i].setIntersectionVariables(new HashSet<lupos.datastructures.items.Variable>(o2.getUnionVariables()));\n            f_new[i].setUnionVariables(new HashSet<lupos.datastructures.items.Variable>(o2.getUnionVariables()));\n            f_new[i].setExpression(this.f.getExpression());\n        } else {\n            if(deleteFilter) {\n                for(lupos.datastructures.items.Variable v : o2.getUnionVariables()) {\n                    if(this.f.getVariablesInExpression().contains(v)) {\n                        deleteFilter = false;\n\n                        break;\n                    }\n                }\n            }\n\n            this.deleteOperator(f_new[i], _startNodes);\n        }\n    }\n}\n\nif(deleteFilter || this.op instanceof lupos.engine.operators.multiinput.join.Join) {\n    this.deleteOperator(this.f, _startNodes);\n}",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {
          "connections": {
            "f": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "op2"
            }],
            "j": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "f"
            }],
            "o": [{
              "active": true,
              "id": -1,
              "id label": "a",
              "mode": "ALL_PRECEDING",
              "to": "op"
            }],
            "op": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "j"
            }]
          },
          "f": {
            "also subclasses": false,
            "class type": "RuleFilter",
            "op type": "RuleOperator",
            "position": [
              46,
              807
            ],
            "start node": true
          },
          "j": {
            "also subclasses": false,
            "cardinality": "*",
            "class type": "RuleFilter",
            "conditions": "",
            "op type": "JumpOverOperator",
            "position": [
              5,
              533
            ]
          },
          "o": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              46,
              5
            ]
          },
          "op": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              46,
              269
            ]
          },
          "op2": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              46,
              1071
            ]
          }
        },
        "right side": {
          "connections": {
            "f": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "op2"
            }],
            "f_new": [{
              "active": true,
              "id": -1,
              "id label": "a",
              "mode": "ALL_PRECEDING",
              "to": "op"
            }],
            "j": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "f"
            }],
            "o": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "f_new"
            }],
            "op": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "j"
            }]
          },
          "f": {
            "also subclasses": false,
            "class type": "RuleFilter",
            "op type": "RuleOperator",
            "position": [
              5,
              929
            ]
          },
          "f_new": {
            "also subclasses": false,
            "class type": "RuleFilter",
            "op type": "RuleOperator",
            "position": [
              5,
              236
            ]
          },
          "j": {
            "also subclasses": false,
            "cardinality": "*",
            "class type": "RuleFilter",
            "conditions": "",
            "op type": "JumpOverOperator",
            "position": [
              5,
              698
            ]
          },
          "o": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              5
            ]
          },
          "op": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              467
            ]
          },
          "op2": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              1160
            ]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Remove Distinct": {
      "documentation": {
        "left image": "",
        "long description": "",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "Removes all early duplicate eliminations...",
        "show visual representation": true,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "",
        "additional import declarations": "",
        "check method": {
          "additional code": "return !(this.d.getSucceedingOperators().get(0).getOperator() instanceof lupos.engine.operators.singleinput.Result);",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "this.deleteOperatorWithParentsAndChildren(this.o1, _startNodes);",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {
          "connections": {
            "d": [{
              "active": true,
              "id": -1,
              "id label": "a",
              "mode": "ALL_SUCCEEDING",
              "to": "o2"
            }],
            "o1": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING",
              "to": "d"
            }]
          },
          "d": {
            "also subclasses": false,
            "class type": "Distinct",
            "op type": "RuleOperator",
            "position": [
              9,
              269
            ]
          },
          "o1": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              5
            ]
          },
          "o2": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              15,
              533
            ]
          }
        },
        "right side": {
          "connections": {"o1": [{
            "active": true,
            "id": -1,
            "id label": "a",
            "mode": "ALL_SUCCEEDING",
            "to": "o2"
          }]},
          "o1": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              5
            ]
          },
          "o2": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              236
            ]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Remove Empty Index": {
      "documentation": {
        "left image": "",
        "long description": "",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "This transformation rule checks an index scan operator for empty result. In case of empty result, the index scan operator is removed, which can lead to an enormous simplification of the operator graph.",
        "show visual representation": true,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "",
        "additional import declarations": "",
        "check method": {
          "additional code": "if(this.i instanceof lupos.rif.operator.PredicateIndexScan\n    || this.i instanceof lupos.rif.operator.BooleanIndexScan\n    || this.i instanceof lupos.rif.operator.IteratorIndexScan\n    || (!this.i.getPrecedingOperators().isEmpty()\n        && !this.i.getPrecedingOperators().get(0).getSucceedingOperators().isEmpty()\n        && this.i.getPrecedingOperators().get(0).getSucceedingOperators().get(0).getOperator() instanceof lupos.rif.operator.InsertTripleIndexScan)) {\n\t\t\t\t\treturn false;\n}\n\nlupos.datastructures.queryresult.QueryResult qr = null;\n\t\t\t\tif (this.i instanceof lupos.engine.operators.index.memoryindex.MemoryIndexScan) {\n\t\t\t\t\tfinal lupos.engine.operators.index.memoryindex.MemoryIndexScan temp = new lupos.engine.operators.index.memoryindex.MemoryIndexScan(this.i.getRoot());\n\t\t\t\t\tboolean found = false;\n\t\t\t\t\tfor (lupos.engine.operators.tripleoperator.TriplePattern pat : ((lupos.engine.operators.index.memoryindex.MemoryIndexScan) this.i).getTriplePattern()) {\n\t\t\t\t\t\ttemp.setTriplePatterns(java.util.Arrays.asList(pat));\n\t\t\t\t\t\tlupos.datastructures.queryresult.QueryResult qrtemp = temp.join(this.i.getRoot().dataset);\n\t\t\t\t\t\tif (qrtemp != null && qrtemp.oneTimeIterator().hasNext()) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!found) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n                    return false;\n\t\t\t\t} else {\n\t\t\t\t\tqr = this.i.join(this.i.getRoot().dataset);\n                }\n\t\t\t\tif (qr != null) {\n\t\t\t\t\tfinal java.util.Iterator<lupos.datastructures.bindings.Bindings> pib = qr.oneTimeIterator();\n\t\t\t\t\tif (pib.hasNext()) {\n\t\t\t\t\t\tif (pib instanceof lupos.datastructures.queryresult.ParallelIterator) {\n\t\t\t\t\t\t\t((lupos.datastructures.queryresult.ParallelIterator) pib).close();\n                        }\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (pib instanceof lupos.datastructures.queryresult.ParallelIterator) {\n\t\t\t\t\t\t((lupos.datastructures.queryresult.ParallelIterator) pib).close();\n                    }\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\treturn true;\n\t\t\t\t}",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {
          "connections": {"o": [{
            "active": false,
            "id": -1,
            "id label": "",
            "mode": "ONLY_PRECEDING",
            "to": "i"
          }]},
          "i": {
            "also subclasses": true,
            "class type": "Index",
            "op type": "RuleOperator",
            "position": [
              35,
              278
            ],
            "start node": true
          },
          "o": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              26,
              18
            ]
          }
        },
        "right side": {"o": {
          "also subclasses": false,
          "class type": "Operator",
          "op type": "RuleOperator",
          "position": [
            18,
            20
          ]
        }},
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Remove Union": {
      "documentation": {
        "left image": "",
        "long description": "",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "All unions are removed by this transformation rule by directly connecting all preceding operators of the union operator with its succeeding operators. This saves a lot of processing costs.",
        "show visual representation": true,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "",
        "additional import declarations": "",
        "check method": {
          "additional code": "return !(this.u instanceof lupos.engine.operators.multiinput.MergeUnion);",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "",
          "code": "for(BasicOperator over : this.u.getPrecedingOperators()) {\n\tfor(OperatorIDTuple opID: this.u.getSucceedingOperators()){\n\t\tover.addSucceedingOperator(new OperatorIDTuple(opID));\n\t\topID.getOperator().addPrecedingOperator(over);\n\t}\n}\n\nthis.u.removeFromOperatorGraphWithoutConnectingPrecedingWithSucceedingOperators();\nthis.deleteNodeFromStartNodeMapNullCheck(this.u, _startNodes);",
          "use generated code": false
        }
      },
      "visual representation": {
        "left side": {
          "connections": {
            "o1": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ALL_PRECEDING",
              "to": "u"
            }],
            "u": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ALL_SUCCEEDING",
              "to": "o2"
            }]
          },
          "o1": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              5
            ]
          },
          "o2": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              533
            ]
          },
          "u": {
            "also subclasses": false,
            "class type": "Union",
            "op type": "RuleOperator",
            "position": [
              5,
              269
            ],
            "start node": true
          }
        },
        "right side": {
          "connections": {"o1": [{
            "active": false,
            "id": -1,
            "id label": "",
            "mode": "EXISTS",
            "to": "o2"
          }]},
          "o1": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              14,
              9
            ]
          },
          "o2": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              19,
              556
            ]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Remove Unnecessary Construct": {
      "documentation": {
        "left image": "",
        "long description": "",
        "right image": "",
        "see also": {
          "rule packages": ["RIF Rules"],
          "rules": []
        },
        "short description": "If a Construct has only a PredicatePattern as succeeding operator, the PredicatePattern operator will not have any result for the output of a Construct and can be therefore removed.",
        "show visual representation": true,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "",
        "additional import declarations": "",
        "check method": {
          "additional code": "",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {
          "c": {
            "also subclasses": false,
            "class type": "Construct",
            "op type": "RuleOperator",
            "position": [
              32,
              11
            ]
          },
          "connections": {"c": [{
            "active": false,
            "id": -1,
            "id label": "",
            "mode": "ONLY_SUCCEEDING",
            "to": "p"
          }]},
          "p": {
            "also subclasses": false,
            "class type": "PredicatePattern",
            "op type": "RuleOperator",
            "position": [
              28,
              272
            ]
          }
        },
        "right side": {"p": {
          "also subclasses": false,
          "class type": "PredicatePattern",
          "op type": "RuleOperator",
          "position": [
            29,
            15
          ]
        }},
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Remove Unnecessary ConstructPredicate": {
      "documentation": {
        "left image": "",
        "long description": "",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "If a ConstructPredicate has only a Triple Pattern as succeeding operator, the Triple Pattern Pattern operator will not have any result for the output of a ConstructPredicate and can be therefore removed.",
        "show visual representation": true,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "",
        "additional import declarations": "",
        "check method": {
          "additional code": "",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {
          "c": {
            "also subclasses": false,
            "class type": "ConstructPredicate",
            "op type": "RuleOperator",
            "position": [
              25,
              5
            ]
          },
          "connections": {"c": [{
            "active": false,
            "id": -1,
            "id label": "",
            "mode": "ONLY_SUCCEEDING",
            "to": "t"
          }]},
          "t": {
            "also subclasses": false,
            "class type": "TriplePattern",
            "op type": "RuleOperator",
            "position": [
              31,
              269
            ]
          }
        },
        "right side": {"t": {
          "also subclasses": false,
          "class type": "TriplePattern",
          "op type": "RuleOperator",
          "position": [
            18,
            18
          ]
        }},
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Replace Filter With RuleFilter": {
      "documentation": {
        "left image": "",
        "long description": "",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "SPARQL Filter operators are replaced by RIF Filter operators for dealing with equalities.",
        "show visual representation": true,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "",
        "additional import declarations": "",
        "check method": {
          "additional code": "return this.f.getNodePointer().jjtGetChild(0) instanceof lupos.sparql1_1.ASTEqualsNode;",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "lupos.optimizations.sparql2core_sparql.SPARQLParserVisitorImplementationDumper filterDumper = new lupos.optimizations.sparql2core_sparql.SPARQLParserVisitorImplementationDumper();\n\nString equalsString = (String) filterDumper.visit((lupos.sparql1_1.ASTEqualsNode) this.f.getNodePointer().jjtGetChild(0));\n\nlupos.rif.model.Equality equality = null;\n\ntry {\n    lupos.rif.generated.syntaxtree.RIFAtomic atomic = new lupos.rif.generated.parser.RIFParser(new java.io.StringReader(equalsString.substring(1, equalsString.length() - 1))).RIFAtomic();\n    lupos.rif.visitor.ParseSyntaxTreeVisitor rifParser = new lupos.rif.visitor.ParseSyntaxTreeVisitor();\n\tequality = (lupos.rif.model.Equality) atomic.accept(rifParser, null);\n} catch(lupos.rif.generated.parser.ParseException e) {\n    e.printStackTrace();\n    return;\n}\n\nrf.setExpression(equality);\nrf.setUnionVariables(this.f.getUnionVariables());\nrf.setIntersectionVariables(this.f.getIntersectionVariables());",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {
          "connections": {
            "f": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ALL_SUCCEEDING",
              "to": "o2"
            }],
            "o1": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ALL_PRECEDING",
              "to": "f"
            }]
          },
          "f": {
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator",
            "position": [
              5,
              269
            ],
            "start node": true
          },
          "o1": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              5
            ]
          },
          "o2": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              533
            ]
          }
        },
        "right side": {
          "connections": {
            "o1": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ALL_PRECEDING",
              "to": "rf"
            }],
            "rf": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ALL_SUCCEEDING",
              "to": "o2"
            }]
          },
          "o1": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              5
            ]
          },
          "o2": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              467
            ]
          },
          "rf": {
            "also subclasses": false,
            "class type": "RuleFilter",
            "op type": "RuleOperator",
            "position": [
              5,
              236
            ]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Replace Generate Pat": {
      "documentation": {
        "left image": "",
        "long description": "",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "A generated triple is immediately consumed from a Triple Pattern. This transformation rule reduces this to the direct assignment of variables.",
        "show visual representation": false,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "",
        "additional import declarations": "",
        "check method": {
          "additional code": "",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "",
          "code": "final lupos.datastructures.items.Item[] patItems = this.t.getItems();\n\t\tfinal lupos.datastructures.items.Item[] generateItems = this.g.getValueOrVariable();\n\n\t\tlupos.engine.operators.singleinput.Filter filter = null;\n\t\tfinal lupos.engine.operators.singleinput.ReplaceVar replaceVar = new lupos.engine.operators.singleinput.ReplaceVar();\n\t\treplaceVar.setIntersectionVariables(new java.util.HashSet<lupos.datastructures.items.Variable>());\n\t\treplaceVar.setUnionVariables(replaceVar.getIntersectionVariables());\n\n\t\tfinal java.util.LinkedList<lupos.datastructures.items.Variable> addBindingsVar = new java.util.LinkedList<lupos.datastructures.items.Variable>();\n\t\tfinal java.util.LinkedList<lupos.datastructures.items.literal.Literal> addBindingsLit = new java.util.LinkedList<lupos.datastructures.items.literal.Literal>();\n\n\t\tString filterConstraint = \"Filter( \";\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfinal lupos.datastructures.items.Item patItem = patItems[i];\n\t\t\tfinal lupos.datastructures.items.Item generateItem = generateItems[i];\n\t\t\tif ((!patItem.isVariable()) && generateItem.isVariable()) {\n\t\t\t\tfilterConstraint += generateItems[i].toString() + \" = \"\n\t\t\t\t\t\t+ patItems[i].toString() + \" && \";\n\t\t\t} else if (patItem.isVariable() && generateItem.isVariable()) {\n\t\t\t\treplaceVar.addSubstitution((lupos.datastructures.items.Variable) patItem,\n\t\t\t\t\t\t(lupos.datastructures.items.Variable) generateItem);\n\t\t\t\treplaceVar.getIntersectionVariables().add((lupos.datastructures.items.Variable) patItem);\n\t\t\t} else if (patItem.isVariable() && (!generateItem.isVariable())) {\n\t\t\t\taddBindingsVar.add((lupos.datastructures.items.Variable) patItem);\n\t\t\t\taddBindingsLit.add((lupos.datastructures.items.literal.Literal) generateItem);\n\t\t\t} else if (!patItem.isVariable() && !generateItem.isVariable()\n\t\t\t\t\t&& !generateItem.equals(patItem)) {\n\t\t\t\t// cannot match, remove generate.\n\t\t\t\tfor (final BasicOperator parent : this.g.getPrecedingOperators())\n\t\t\t\t\tparent.removeSucceedingOperator(this.g);\n\t\t\t\tthis.g.getPrecedingOperators().clear();\n\t\t\t\tthis.g.removeFromOperatorGraph();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// If (?x = ?a) and (?x = ?b) then (valueOf(?a) = value(?b)) must be\n\t\t// fulfilled\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tfor (int x = i + 1; x < 3; x++) {\n\t\t\t\tif (patItems[i].equals(patItems[x])) {\n\t\t\t\t\tfilterConstraint += generateItems[i].toString() + \" = \"\n\t\t\t\t\t\t\t+ generateItems[x].toString() + \" && \";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!filterConstraint.equals(\"Filter( \")) {\n\t\t\tfilterConstraint = filterConstraint.substring(0,\n\t\t\t\t\tfilterConstraint.length() - 3)\n\t\t\t\t\t+ \") \";\n\n\t\t\ttry {\n\t\t\t\tfinal lupos.sparql1_1.ASTFilterConstraint ASTfilter = (lupos.sparql1_1.ASTFilterConstraint) lupos.sparql1_1.SPARQL1_1Parser\n\t\t\t\t\t\t.parseFilter(filterConstraint);\n\t\t\t\tfilter = new lupos.engine.operators.singleinput.Filter(ASTfilter);\n\t\t\t} catch (final Exception e) {\n\t\t\t\tSystem.err\n\t\t\t\t\t\t.println(\"This should never happen in RuleReplaceGenPat!\");\n\t\t\t\tSystem.err.println(e);\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\t// Only Operators with a not empty definition are put into the\n\t\t// operatorgraph\n\t\tfinal java.util.LinkedList<BasicOperator> order = new java.util.LinkedList<BasicOperator>();\n\t\tif (filter != null) {\n\t\t\torder.add(filter);\n\t\t}\n\n\t\tfinal int substVar = replaceVar.getSubstitutionsVariableLeft().size();\n\n\t\tif (substVar > 0) {\n\t\t\torder.add(replaceVar);\n\t\t} else {\n\t\t\tfinal lupos.engine.operators.singleinput.Projection p = new lupos.engine.operators.singleinput.Projection();\n\t\t\tp.setIntersectionVariables(new java.util.HashSet<lupos.datastructures.items.Variable>());\n\t\t\tp.setUnionVariables(p.getUnionVariables());\n\t\t\torder.add(p);\n\t\t}\n\t\tif (addBindingsVar.size() > 0) {\n\t\t\tfinal java.util.Iterator<lupos.datastructures.items.literal.Literal> lit_it = addBindingsLit.iterator();\n\t\t\tfinal java.util.HashSet<lupos.datastructures.items.Variable> hsv = new java.util.HashSet<lupos.datastructures.items.Variable>();\n\t\t\thsv.addAll(replaceVar.getUnionVariables());\n\t\t\tfor (final lupos.datastructures.items.Variable v : addBindingsVar) {\n\t\t\t\tfinal lupos.engine.operators.singleinput.AddBinding ab = new lupos.engine.operators.singleinput.AddBinding(v, lit_it.next());\n\t\t\t\thsv.add(v);\n\t\t\t\tab.setIntersectionVariables((java.util.HashSet<lupos.datastructures.items.Variable>) hsv.clone());\n\t\t\t\tab.setUnionVariables(ab.getIntersectionVariables());\n\t\t\t\torder.add(ab);\n\t\t\t}\n\t\t}\n\n\t\t// In case that Generate or TriplePattern has minimum one variable, than\n\t\t// minimum one operator has to be inserted\n\t\tif (order.size() > 0) {\n\t\t\tfinal java.util.List<BasicOperator> pres = (java.util.List<BasicOperator>) this.g.getPrecedingOperators();\n\t\t\tBasicOperator pre;\n\t\t\tfor (int i = 0; i < pres.size(); i++) {\n\t\t\t\tpre = pres.get(i);\n\t\t\t\tpre.addSucceedingOperator(new OperatorIDTuple(order.getFirst(),\n\t\t\t\t\t\t0));\n\t\t\t\tif (filter != null) {\n\t\t\t\t\tjava.util.Collection<lupos.datastructures.items.Variable> vars = filter\n\t\t\t\t\t\t\t.getIntersectionVariables();\n\t\t\t\t\tif (vars == null)\n\t\t\t\t\t\tvars = new java.util.HashSet<lupos.datastructures.items.Variable>();\n\t\t\t\t\tvars.addAll(pre.getIntersectionVariables());\n\t\t\t\t\tfilter.setIntersectionVariables(vars);\n\t\t\t\t\tfilter.setUnionVariables(vars);\n\t\t\t\t}\n\t\t\t\tpre.removeSucceedingOperator(this.g);\n\t\t\t\torder.getFirst().addPrecedingOperator(pre);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < order.size() - 1; i++) {\n\t\t\t\torder.get(i + 1).setPrecedingOperator(order.get(i));\n\t\t\t\torder.get(i).setSucceedingOperator(\n\t\t\t\t\t\tnew OperatorIDTuple(order.get(i + 1), 0));\n\t\t\t}\n\n\t\t\tfinal java.util.LinkedList<OperatorIDTuple> succs = (java.util.LinkedList<OperatorIDTuple>) this.t.getSucceedingOperators();\n\t\t\tfor (int i = 0; i < succs.size(); i++) {\n\t\t\t\tsuccs.get(i).getOperator()\n\t\t\t\t\t\t.addPrecedingOperator(order.getLast());\n\t\t\t}\n\n\t\t\tfinal java.util.LinkedList<OperatorIDTuple> sops = new java.util.LinkedList<OperatorIDTuple>();\n\t\t\tsops.addAll(this.t.getSucceedingOperators());\n\t\t\torder.getLast().setSucceedingOperators(sops);\n\t\t} else {\n\t\t\tfinal java.util.LinkedList<BasicOperator> pres = (java.util.LinkedList<BasicOperator>) this.g.getPrecedingOperators();\n\t\t\tfinal java.util.LinkedList<OperatorIDTuple> succs = (java.util.LinkedList<OperatorIDTuple>) this.t.getSucceedingOperators();\n\t\t\tBasicOperator pre;\n\t\t\tBasicOperator succ;\n\t\t\tfor (int i = 0; i < pres.size(); i++) {\n\t\t\t\tpre = pres.get(i);\n\t\t\t\tpre.removeSucceedingOperator(this.g);\n\t\t\t\tfor (int x = 0; x < succs.size(); x++) {\n\t\t\t\t\tpre.addSucceedingOperator(succs.get(x));\n\t\t\t\t\tsucc = succs.get(x).getOperator();\n\t\t\t\t\tsucc.removePrecedingOperator(this.t);\n\t\t\t\t\tsucc.addPrecedingOperator(pre);\n\t\t\t\t}\n\t\t\t}\n\t\t}",
          "use generated code": false
        }
      },
      "visual representation": {
        "left side": {
          "connections": {"g": [{
            "active": false,
            "id": -1,
            "id label": "",
            "mode": "ONLY_SUCCEEDING",
            "to": "t"
          }]},
          "g": {
            "also subclasses": false,
            "class type": "Generate",
            "op type": "RuleOperator",
            "position": [
              5,
              5
            ]
          },
          "t": {
            "also subclasses": false,
            "class type": "TriplePattern",
            "op type": "RuleOperator",
            "position": [
              5,
              269
            ]
          }
        },
        "right side": {},
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Replace HashMapIndexJoin with HashMapIndexJoinOnLeftOperand": {
      "documentation": {
        "left image": "",
        "long description": "",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "",
        "show visual representation": true,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "public static boolean isInCycleOrSeveralOperandsWitSameID(BasicOperator bo){\r\n  if(bo.getCycleOperands()!=null && bo.getCycleOperands().size()>0){\r\n    return true;\r\n  }\r\n HashSet<Integer> operandsIDOccurs = new HashSet<Integer>();\r\n  for(BasicOperator prec: bo.getPrecedingOperators()){\r\n  int operandsID = prec.getOperatorIDTuple(bo).getId();\r\n  if(operandsIDOccurs.contains(operandsID)){\r\n   return true;\r\n  }\r\n  operandsIDOccurs.add(operandsID);\r\n    if(ReplaceHashMapIndexJoinwithHashMapIndexJoinOnLeftOperandRule.isInCycleOrSeveralOperandsWitSameID(prec)){\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}",
        "additional import declarations": "",
        "check method": {
          "additional code": "return !(ReplaceHashMapIndexJoinwithHashMapIndexJoinOnLeftOperandRule.isInCycleOrSeveralOperandsWitSameID(this.j));",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "new_j.setIntersectionVariables(this.j.getIntersectionVariables());\r\nnew_j.setUnionVariables(this.j.getUnionVariables());",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {
          "connections": {
            "j": [{
              "active": true,
              "id": -1,
              "id label": "b",
              "mode": "ALL_SUCCEEDING",
              "to": "o_under"
            }],
            "o": [{
              "active": true,
              "id": -1,
              "id label": "a",
              "mode": "ALL_PRECEDING",
              "to": "j"
            }]
          },
          "j": {
            "also subclasses": false,
            "class type": "HashMapIndexJoin",
            "op type": "RuleOperator",
            "position": [
              44,
              357
            ],
            "start node": true
          },
          "o": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              42,
              88
            ]
          },
          "o_under": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              49,
              662
            ]
          }
        },
        "right side": {
          "connections": {
            "new_j": [{
              "active": true,
              "id": -1,
              "id label": "b",
              "mode": "ALL_SUCCEEDING",
              "to": "o_under"
            }],
            "o": [{
              "active": true,
              "id": -1,
              "id label": "a",
              "mode": "ALL_PRECEDING",
              "to": "new_j"
            }]
          },
          "new_j": {
            "also subclasses": false,
            "class type": "HashMapIndexOnLeftOperandJoin",
            "op type": "RuleOperator",
            "position": [
              180,
              404
            ]
          },
          "o": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              174,
              110
            ]
          },
          "o_under": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              187,
              699
            ]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Replace UsingJoinOptional With BasicIndexOptional": {
      "documentation": {
        "left image": "",
        "long description": "",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "",
        "show visual representation": true,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "private int operandID;",
        "additional import declarations": "",
        "check method": {
          "additional code": "// for later repairing operandId\r\nthis.operandID = this.optional.getOperatorIDTuple(this.suc).getId();\r\n",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "optional_new.setBasicIndexScan(this.indexScan);\r\noptional_new.setUnionVariables(this.optional.getUnionVariables());\r\noptional_new.setIntersectionVariables(this.optional.getIntersectionVariables());\r\nif(this.operandID!=0){\r\n  // repairing the operand ID\r\n  optional_new.getOperatorIDTuple(this.suc).setId(this.operandID);\r\n}\r\nif(this.indexScan.getSucceedingOperators().size()==0){\r\n  this.deleteOperator(this.indexScan, _startNodes);\r\n}",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {
          "connections": {
            "indexScan": [{
              "active": true,
              "id": 1,
              "id label": "",
              "mode": "ONLY_SUCCEEDING",
              "to": "optional"
            }],
            "leftOperand": [{
              "active": true,
              "id": 0,
              "id label": "",
              "mode": "ONLY_SUCCEEDING",
              "to": "optional"
            }],
            "optional": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_SUCCEEDING",
              "to": "suc"
            }]
          },
          "indexScan": {
            "also subclasses": true,
            "class type": "Index",
            "op type": "RuleOperator",
            "position": [
              526,
              11
            ]
          },
          "leftOperand": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              11,
              11
            ]
          },
          "optional": {
            "also subclasses": true,
            "class type": "UsingJoinOptional",
            "op type": "RuleOperator",
            "position": [
              67,
              510
            ],
            "start node": true
          },
          "suc": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              73,
              853
            ]
          }
        },
        "right side": {
          "connections": {
            "leftOperand": [{
              "active": true,
              "id": 0,
              "id label": "",
              "mode": "ONLY_SUCCEEDING",
              "to": "optional_new"
            }],
            "optional_new": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_SUCCEEDING",
              "to": "suc"
            }]
          },
          "leftOperand": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              16,
              21
            ]
          },
          "optional_new": {
            "also subclasses": false,
            "class type": "BasicIndexOptional",
            "op type": "RuleOperator",
            "position": [
              32,
              535
            ]
          },
          "suc": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              61,
              879
            ]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "ReplaceVar Under Index": {
      "documentation": {
        "left image": "",
        "long description": "",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "ReplaceVar under Index Scan operators are eliminated by replacing the variable directly in the Index Scan operator.",
        "show visual representation": true,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "private int varCounter = 0;",
        "additional import declarations": "",
        "check method": {
          "additional code": "java.util.Set<lupos.datastructures.items.Variable> vars = new java.util.HashSet<lupos.datastructures.items.Variable>(this.r.getSubstitutionsVariableRight());\n\nif(vars.size() != this.r.getSubstitutionsVariableRight().size()) {\n    return false;\n}\n\nif(this.o instanceof lupos.engine.operators.singleinput.Result) {\n    return false;\n}\n\nfor(lupos.engine.operators.index.BasicIndexScan tmp_i : this.i) {\n    if(tmp_i.getSucceedingOperators().size() > 1) {\n        return false;\n    }\n}",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "for(lupos.engine.operators.index.BasicIndexScan index : this.i) {\n    java.util.Map<String, lupos.datastructures.items.Variable> varMap = new java.util.HashMap<String, lupos.datastructures.items.Variable>();\n    java.util.Map<lupos.datastructures.items.Variable, String> aliasMap = new java.util.HashMap<lupos.datastructures.items.Variable, String>();\n\n    for(lupos.datastructures.items.Variable var : index.getUnionVariables()) {\n        String aliasName = \"RepVar_\" + this.varCounter++ + \"_\" + var.getName();\n        varMap.put(aliasName, var);\n        aliasMap.put(var, aliasName);\n    }\n\n    for(lupos.engine.operators.tripleoperator.TriplePattern tp : index.getTriplePattern()) {\n        for(lupos.datastructures.items.Variable var : tp.getVariables()) {\n            tp.replace(var, new lupos.datastructures.items.Variable(aliasMap.get(var)));\n        }\n    }\n\n    for(lupos.engine.operators.tripleoperator.TriplePattern tp : index.getTriplePattern()) {\n        for(lupos.datastructures.items.Variable v : tp.getVariables()) {\n            lupos.datastructures.items.Variable rv = this.r.getReplacement(varMap.get(v.getName()));\n\n            if(rv != null) {\n                tp.replace(v, rv);\n            }\n        }\n    }\n}",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {
          "connections": {
            "i": [{
              "active": true,
              "id": -1,
              "id label": "a",
              "mode": "ALL_PRECEDING",
              "to": "r"
            }],
            "r": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "o"
            }]
          },
          "i": {
            "also subclasses": true,
            "class type": "Index",
            "op type": "RuleOperator",
            "position": [
              6,
              5
            ]
          },
          "o": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              9,
              533
            ]
          },
          "r": {
            "also subclasses": false,
            "class type": "ReplaceVar",
            "op type": "RuleOperator",
            "position": [
              5,
              269
            ],
            "start node": true
          }
        },
        "right side": {
          "connections": {"i": [{
            "active": true,
            "id": -1,
            "id label": "a",
            "mode": "ALL_PRECEDING",
            "to": "o"
          }]},
          "i": {
            "also subclasses": false,
            "class type": "Index",
            "op type": "RuleOperator",
            "position": [
              17,
              7
            ]
          },
          "o": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              9,
              531
            ]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "SortLimit over Sort": {
      "documentation": {
        "left image": "",
        "long description": "",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "The SortLimit operator computes the k smallest elements. This transformation rule introduces the SortLimit operator for not sorting all the elements in the case of a sort opertion in combination with a limit operation.",
        "show visual representation": true,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "private final static int MAXLIMIT = 1000;\r\nprivate int limitSortLimit = 0;",
        "additional import declarations": "import java.util.Collection;\r\nimport java.util.LinkedList;\r\n\r\nimport lupos.engine.operators.singleinput.modifiers.Offset;\r\nimport lupos.engine.operators.singleinput.modifiers.SortLimit;\r\nimport lupos.engine.operators.singleinput.sort.Comp;\r\nimport lupos.datastructures.items.Variable;",
        "check method": {
          "additional code": "for(BasicOperator bo:above){\r\n\tif(bo instanceof SortLimit){\r\n\t\treturn false;\r\n\t}\r\n}\r\nthis.limitSortLimit = this.limit.getLimit();\r\nif(this.offset_begin!=null && this.offset_begin instanceof Offset){\r\n\tthis.limitSortLimit += ((Offset)this.offset_begin).getOffset();\r\n}\r\nif(this.limitSortLimit > MAXLIMIT){\r\n\treturn false;\r\n}",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "sortLimit.setLimit(this.limitSortLimit);\r\nsortLimit.setComparator(this.sort.getComparator());\r\n\r\nfinal Collection<Variable> cv = new LinkedList<Variable>();\r\ncv.addAll(this.sort.getIntersectionVariables());\r\nsortLimit.setIntersectionVariables(cv);\r\nsortLimit.setUnionVariables(cv);",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {
          "above": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              51,
              5
            ]
          },
          "connections": {
            "above": [{
              "active": true,
              "id": -1,
              "id label": "a",
              "mode": "ALL_PRECEDING",
              "to": "sort"
            }],
            "offset": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "limit"
            }],
            "sort": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "offset"
            }]
          },
          "limit": {
            "also subclasses": true,
            "class type": "Limit",
            "op type": "RuleOperator",
            "position": [
              51,
              828
            ],
            "start node": true
          },
          "offset": {
            "also subclasses": true,
            "cardinality": "*",
            "class type": "Offset",
            "conditions": "",
            "op type": "JumpOverOperator",
            "position": [
              5,
              547
            ]
          },
          "sort": {
            "also subclasses": true,
            "class type": "Sort",
            "op type": "RuleOperator",
            "position": [
              51,
              276
            ]
          }
        },
        "right side": {
          "above": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              5
            ]
          },
          "connections": {
            "above": [{
              "active": true,
              "id": -1,
              "id label": "a",
              "mode": "ALL_PRECEDING",
              "to": "sortLimit"
            }],
            "offset": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "limit"
            }],
            "sort": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "offset"
            }],
            "sortLimit": [{
              "active": true,
              "id": 0,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "sort"
            }]
          },
          "limit": {
            "also subclasses": false,
            "class type": "Limit",
            "op type": "RuleOperator",
            "position": [
              5,
              925
            ]
          },
          "offset": {
            "also subclasses": false,
            "cardinality": "*",
            "class type": "Offset",
            "conditions": "",
            "op type": "JumpOverOperator",
            "position": [
              9,
              681
            ]
          },
          "sort": {
            "also subclasses": false,
            "class type": "Sort",
            "op type": "RuleOperator",
            "position": [
              5,
              465
            ]
          },
          "sortLimit": {
            "also subclasses": false,
            "class type": "SortLimit",
            "op type": "RuleOperator",
            "position": [
              5,
              235
            ]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Split ConstructPredicate": {
      "documentation": {
        "left image": "",
        "long description": "",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "Creation of one ConstructPredicate for each of its predecessors, which simplifies further optimizations.",
        "show visual representation": true,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "",
        "additional import declarations": "",
        "check method": {
          "additional code": "return this.c.getSucceedingOperators().size() > 1 && this.c.getPredicatePattern().size() == 1;",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "for(lupos.rif.operator.ConstructPredicate tmp_c : c_new) {\r\n    tmp_c.setPredicatePattern(this.c.getPredicatePattern());\r\n}",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {
          "c": {
            "also subclasses": false,
            "class type": "ConstructPredicate",
            "op type": "RuleOperator",
            "position": [
              5,
              269
            ]
          },
          "connections": {
            "c": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ALL_SUCCEEDING",
              "to": "o2"
            }],
            "o1": [{
              "active": true,
              "id": -1,
              "id label": "a",
              "mode": "ONLY_PRECEDING",
              "to": "c"
            }]
          },
          "o1": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              5
            ]
          },
          "o2": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              533
            ]
          }
        },
        "right side": {
          "c_new": {
            "also subclasses": false,
            "class type": "ConstructPredicate",
            "op type": "RuleOperator",
            "position": [
              5,
              236
            ]
          },
          "connections": {
            "c_new": [{
              "active": true,
              "id": -1,
              "id label": "a",
              "mode": "EXISTS",
              "to": "o2"
            }],
            "o1": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ALL_SUCCEEDING",
              "to": "c_new"
            }]
          },
          "o1": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              5
            ]
          },
          "o2": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              467
            ]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Split Generate": {
      "documentation": {
        "left image": "",
        "long description": "",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "Creation of one Generate for each of its predecessors, which simplifies further optimizations.",
        "show visual representation": true,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "",
        "additional import declarations": "",
        "check method": {
          "additional code": "return this.g.getSucceedingOperators().size() > 1;",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "for(lupos.engine.operators.singleinput.generate.Generate tmp_g : g_new) {\n    tmp_g.setValueOrVariable(this.g.getValueOrVariable());\n}",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {
          "connections": {
            "g": [{
              "active": true,
              "id": -1,
              "id label": "a",
              "mode": "ALL_SUCCEEDING",
              "to": "t"
            }],
            "o1": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING",
              "to": "g"
            }]
          },
          "g": {
            "also subclasses": false,
            "class type": "Generate",
            "op type": "RuleOperator",
            "position": [
              5,
              269
            ]
          },
          "o1": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              5
            ]
          },
          "t": {
            "also subclasses": true,
            "class type": "TriplePattern",
            "op type": "RuleOperator",
            "position": [
              5,
              533
            ]
          }
        },
        "right side": {
          "connections": {
            "g_new": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "t"
            }],
            "o1": [{
              "active": true,
              "id": -1,
              "id label": "a",
              "mode": "ALL_SUCCEEDING",
              "to": "g_new"
            }]
          },
          "g_new": {
            "also subclasses": false,
            "class type": "Generate",
            "op type": "RuleOperator",
            "position": [
              5,
              236
            ]
          },
          "o1": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              5
            ]
          },
          "t": {
            "also subclasses": false,
            "class type": "TriplePattern",
            "op type": "RuleOperator",
            "position": [
              5,
              467
            ]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Split PredicatePattern": {
      "documentation": {
        "left image": "",
        "long description": "",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "Creation of one PredicatePattern for each of its predecessors, which simplifies further optimizations.",
        "show visual representation": true,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "private int id;",
        "additional import declarations": "",
        "check method": {
          "additional code": "this.id = p.getSucceedingOperators().get(0).getId();\nreturn this.p.getPrecedingOperators().size() > 1;",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "for(lupos.rif.operator.PredicatePattern tmp_p : p_new) {\n tmp_p.getSucceedingOperators().get(0).setId(id);\n    tmp_p.setUnionVariables(new java.util.HashSet<lupos.datastructures.items.Variable>(this.p.getUnionVariables()));\n    tmp_p.setIntersectionVariables(new java.util.HashSet<lupos.datastructures.items.Variable>(this.p.getIntersectionVariables()));\n    tmp_p.setPredicateName(this.p.getPredicateName());\n    tmp_p.setPatternItems(this.p.getPatternItems());\n}",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {
          "connections": {
            "o1": [{
              "active": true,
              "id": -1,
              "id label": "a",
              "mode": "ALL_PRECEDING",
              "to": "p"
            }],
            "p": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_SUCCEEDING",
              "to": "o2"
            }]
          },
          "o1": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              5
            ]
          },
          "o2": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              533
            ]
          },
          "p": {
            "also subclasses": false,
            "class type": "PredicatePattern",
            "op type": "RuleOperator",
            "position": [
              5,
              269
            ],
            "start node": true
          }
        },
        "right side": {
          "connections": {
            "o1": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "p_new"
            }],
            "p_new": [{
              "active": true,
              "id": -1,
              "id label": "a",
              "mode": "ALL_PRECEDING",
              "to": "o2"
            }]
          },
          "o1": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              5
            ]
          },
          "o2": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              5,
              467
            ]
          },
          "p_new": {
            "also subclasses": false,
            "class type": "PredicatePattern",
            "op type": "RuleOperator",
            "position": [
              5,
              236
            ]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Unnecessary Optional Because of Projection": {
      "documentation": {
        "left image": "",
        "long description": "",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": []
        },
        "short description": "",
        "show visual representation": true,
        "transition text": "",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "",
        "additional import declarations": "",
        "check method": {
          "additional code": "if(this.opt.getPrecedingOperators().size()>2){\r\n\treturn false;\r\n}\r\nif(this.o0.getUnionVariables().containsAll(this.p.getProjectedVariables())){\r\n\treturn true;\r\n} else {\r\n\treturn false;\r\n}",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "this.deleteOperatorWithParentsAndChildren(this.o1, _startNodes);",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {
          "connections": {
            "o0": [{
              "active": true,
              "id": 0,
              "id label": "",
              "mode": "ONLY_SUCCEEDING",
              "to": "opt"
            }],
            "o1": [{
              "active": true,
              "id": 1,
              "id label": "",
              "mode": "ONLY_SUCCEEDING",
              "to": "opt"
            }],
            "opt": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "p"
            }]
          },
          "o0": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              0,
              35
            ]
          },
          "o1": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              571,
              32
            ]
          },
          "opt": {
            "also subclasses": true,
            "class type": "Optional",
            "op type": "RuleOperator",
            "position": [
              253,
              456
            ]
          },
          "p": {
            "also subclasses": false,
            "class type": "Projection",
            "op type": "RuleOperator",
            "position": [
              263,
              792
            ],
            "start node": true
          }
        },
        "right side": {
          "connections": {"o0": [{
            "active": false,
            "id": -1,
            "id label": "",
            "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
            "to": "p"
          }]},
          "o0": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              63,
              45
            ]
          },
          "p": {
            "also subclasses": false,
            "class type": "Projection",
            "op type": "RuleOperator",
            "position": [
              62,
              327
            ]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    },
    "Variable Propagation": {
      "documentation": {
        "left image": "",
        "long description": "If there are Filter expressions with a value-comparision of two variables, e.g. Filter(?X=?Y), then one of the variables can be propagated to preceding (RDF3X/Hexastore) Index operators in certain cases. However there are problems, if the variables can contain values with ambiguous representations. The values are not identical, but value-equal in this case. These situations might occur when both corresponding variables do not occur in the subject or the predicate of a triple pattern, but only in the objects, which can contain numerical values or language tagged literals. The transformation rule is not applied in these cases.\n\nThe following figure contains the graphical representation of the transformation rule.",
        "right image": "",
        "see also": {
          "rule packages": [],
          "rules": [
            "Factor out OR in Filter",
            "Constant Propagation of Filter in Index With Additional Operators Between"
          ]
        },
        "short description": "This rule implements variable propagation.",
        "show visual representation": true,
        "transition text": "?X or ?Y occurs in a subject or a predicate of a triple pattern of the index operator",
        "use generated visual representation": true
      },
      "implementation": {
        "additional global java code": "private lupos.datastructures.items.Variable var = null;\nprivate lupos.datastructures.items.Variable otherVar = null;\nprivate int operandIDOfFilter;",
        "additional import declarations": "",
        "check method": {
          "additional code": "lupos.sparql1_1.Node n = this.f.getNodePointer();\n\nif(n.jjtGetNumChildren() > 0) {\n    n = n.jjtGetChild(0);\n\n    if(n instanceof lupos.sparql1_1.ASTEqualsNode) {\n        lupos.sparql1_1.Node left = n.jjtGetChild(0);\n        lupos.sparql1_1.Node right = n.jjtGetChild(1);\n\n        if(left instanceof lupos.sparql1_1.ASTVar) {\n            this.var = new lupos.datastructures.items.Variable(((lupos.sparql1_1.ASTVar) left).getName());\n\n            if(right instanceof lupos.sparql1_1.ASTVar) {\n                this.otherVar = new lupos.datastructures.items.Variable(((lupos.sparql1_1.ASTVar) right).getName());\n\n                if(this.i.occurInSubjectOrPredicateOrObjectOriginalStringDoesNotDiffer(this.var) || this.i.occurInSubjectOrPredicateOrObjectOriginalStringDoesNotDiffer(this.otherVar)) {\n                    this.operandIDOfFilter = this.f.getOperatorIDTuple(o).getId();\n                    return true;\n                }\n                else {\n                    // in objects, there might occur typed literals e.g.\n                    // numbers, which are value equal, but do not have the\n                    // same identity, e.g. 01^^xsd:int and 1^^xsd:int.\n                    // => var or otherVar must occur in the subject or\n                    // predicate of a triple pattern, such that they are\n                    // URIs or blank nodes, which have an unique\n                    // representation!\n                    return false;\n                }\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    else {\n        return false;\n   }\n}\nelse {\n    return false;\n}",
          "code": "",
          "start node": "Operator",
          "use generated code": true
        },
        "replace method": {
          "additional code": "this.i.replace(this.var, this.otherVar);\n\nb.setVar(this.var);\nb.setOtherVar(this.otherVar);\n\nBasicOperator tmp = this.i;\n\nwhile(!tmp.equals(b)) {\n    tmp.getUnionVariables().remove(this.var);\n    tmp.getIntersectionVariables().remove(this.var);\n\n    tmp = tmp.getSucceedingOperators().get(0).getOperator();\n}\n\nb.setUnionVariables(this.f.getUnionVariables());\nb.setIntersectionVariables(this.f.getIntersectionVariables());\nb.getOperatorIDTuple(o).setId(this.operandIDOfFilter);",
          "code": "",
          "use generated code": true
        }
      },
      "visual representation": {
        "left side": {
          "connections": {
            "f": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "o"
            }],
            "i": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "j"
            }],
            "j": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "f"
            }]
          },
          "f": {
            "also subclasses": false,
            "class type": "Filter",
            "op type": "RuleOperator",
            "position": [
              52,
              543
            ]
          },
          "i": {
            "also subclasses": true,
            "class type": "Index",
            "op type": "RuleOperator",
            "position": [
              51,
              5
            ],
            "start node": true
          },
          "j": {
            "also subclasses": false,
            "cardinality": "*",
            "class type": "Filter",
            "conditions": "",
            "op type": "JumpOverOperator",
            "position": [
              19,
              269
            ]
          },
          "o": {
            "also subclasses": true,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              54,
              807
            ]
          }
        },
        "right side": {
          "b": {
            "also subclasses": false,
            "class type": "AddBindingFromOtherVar",
            "op type": "RuleOperator",
            "position": [
              40,
              467
            ]
          },
          "connections": {
            "b": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "EXISTS",
              "to": "o"
            }],
            "i": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "j"
            }],
            "j": [{
              "active": false,
              "id": -1,
              "id label": "",
              "mode": "ONLY_PRECEDING_AND_SUCCEEDING",
              "to": "b"
            }]
          },
          "i": {
            "also subclasses": false,
            "class type": "Index",
            "op type": "RuleOperator",
            "position": [
              42,
              5
            ]
          },
          "j": {
            "also subclasses": false,
            "cardinality": "*",
            "class type": "Filter",
            "conditions": "",
            "op type": "JumpOverOperator",
            "position": [
              67,
              236
            ]
          },
          "o": {
            "also subclasses": false,
            "class type": "Operator",
            "op type": "RuleOperator",
            "position": [
              63,
              698
            ]
          }
        },
        "top toolbar": {
          "use colored arrows": false,
          "zoom": 100
        }
      }
    }
  }
}