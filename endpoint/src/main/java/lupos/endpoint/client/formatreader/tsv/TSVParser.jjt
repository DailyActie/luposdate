 /* -------------  SPARQL - Parser -----------------*/options{  IGNORE_CASE = true;  MULTI = true; // many class names
  NODE_DEFAULT_VOID = true; // do not generates jjtree nodes by default
  JAVA_UNICODE_ESCAPE = true;  VISITOR = true;  STATIC = false;}PARSER_BEGIN(TSVParser)package lupos.endpoint.client.formatreader.tsv;import java.io.*;import java.net.URISyntaxException;import lupos.datastructures.items.literal.Literal;import lupos.datastructures.items.literal.LiteralFactory;import lupos.datastructures.items.literal.TypedLiteralOriginalContent;import lupos.datastructures.items.literal.URILiteral;import lupos.datastructures.items.literal.LanguageTaggedLiteralOriginalLanguage;public class TSVParser{  public static void main(String args [])  {    System.out.println("enter query...");    TSVParser parser = new TSVParser(System.in);    try    {            	parser.expr();      	System.out.println("Result:");			((SimpleNode) parser.jjtree.rootNode()).dump("|");	} catch(Exception e) { 		System.out.println(e); 		e.printStackTrace();	}  }  	public static Literal getLiteral(Node n) {  	  return getLiteral(n, false);  	}  	public static Literal getLiteral(Node n, final boolean allowLazyLiteral) {		Literal literal = null;		if (n instanceof ASTNIL) {			try {				literal = (allowLazyLiteral) ? LiteralFactory						.createURILiteral("<http://www.w3.org/1999/02/22-rdf-syntax-ns#nil>")						: LiteralFactory								.createURILiteralWithoutLazyLiteral("<http://www.w3.org/1999/02/22-rdf-syntax-ns#nil>");			} catch (final URISyntaxException e1) {				e1.printStackTrace();			}		} else if (n instanceof ASTBlankNode) {			final ASTBlankNode blankNode = (ASTBlankNode) n;			final String name = blankNode.getIdentifier();			literal = (allowLazyLiteral) ? LiteralFactory					.createAnonymousLiteral(name) : LiteralFactory					.createAnonymousLiteralWithoutLazyLiteral(name);		} else if (n instanceof ASTQuotedURIRef) {			final ASTQuotedURIRef uri = (ASTQuotedURIRef) n;			final String name = uri.getQRef();			if (URILiteral.isURI("<" + name + ">")) {				try {					literal = (allowLazyLiteral) ? LiteralFactory							.createURILiteral("<" + name + ">")							: LiteralFactory									.createURILiteralWithoutLazyLiteral("<"											+ name + ">");				} catch (final Exception e) {					literal = (allowLazyLiteral) ? LiteralFactory							.createLiteral("<" + name + ">") : LiteralFactory							.createLiteralWithoutLazyLiteral("<" + name + ">");				}			} else				literal = (allowLazyLiteral) ? LiteralFactory.createLiteral("<"						+ name + ">") : LiteralFactory						.createLiteralWithoutLazyLiteral("<" + name + ">");		} else if (n instanceof ASTRDFLiteral)			n = n.jjtGetChild(0);		if (literal != null)			return literal;		if (n instanceof ASTStringLiteral) {			final ASTStringLiteral lit = (ASTStringLiteral) n;			final String quotedContent = lit.getStringLiteral();			try {				literal = (allowLazyLiteral) ? LiteralFactory						.createTypedLiteral(quotedContent,								"<http://www.w3.org/2001/XMLSchema#string>")						: TypedLiteralOriginalContent.createTypedLiteral(								quotedContent,								"<http://www.w3.org/2001/XMLSchema#string>");			} catch (final URISyntaxException e) {				literal = (allowLazyLiteral) ? LiteralFactory						.createLiteral(quotedContent) : LiteralFactory						.createLiteralWithoutLazyLiteral(quotedContent);			}		} else if (n instanceof ASTInteger) {			final ASTInteger lit = (ASTInteger) n;			final String content = String.valueOf(lit.getValue());			try {				literal = (allowLazyLiteral) ? LiteralFactory						.createTypedLiteral("\"" + content + "\"",								"<http://www.w3.org/2001/XMLSchema#integer>")						: TypedLiteralOriginalContent.createTypedLiteral("\""								+ content + "\"",								"<http://www.w3.org/2001/XMLSchema#integer>");			} catch (final URISyntaxException e) {				literal = (allowLazyLiteral) ? LiteralFactory						.createLiteral(content) : LiteralFactory						.createLiteralWithoutLazyLiteral(content);			}		} else if (n instanceof ASTFloatingPoint) {			final ASTFloatingPoint lit = (ASTFloatingPoint) n;			final String content = lit.getValue();			try {				if (content.contains("e") || content.contains("E"))					literal = (allowLazyLiteral) ? LiteralFactory							.createTypedLiteral("\"" + content + "\"",									"<http://www.w3.org/2001/XMLSchema#double>")							: TypedLiteralOriginalContent									.createTypedLiteral("\"" + content + "\"",											"<http://www.w3.org/2001/XMLSchema#double>");				else					literal = (allowLazyLiteral) ? LiteralFactory							.createTypedLiteral("\"" + content + "\"",									"<http://www.w3.org/2001/XMLSchema#decimal>")							: TypedLiteralOriginalContent									.createTypedLiteral("\"" + content + "\"",											"<http://www.w3.org/2001/XMLSchema#decimal>");			} catch (final URISyntaxException e) {				literal = (allowLazyLiteral) ? LiteralFactory						.createLiteral(content) : LiteralFactory						.createLiteralWithoutLazyLiteral(content);			}		} else if (n instanceof ASTBooleanLiteral) {			final String content = ((ASTBooleanLiteral) n).getState() + "";			try {				literal = (allowLazyLiteral) ? LiteralFactory						.createTypedLiteral("\"" + content + "\"",								"<http://www.w3.org/2001/XMLSchema#boolean>")						: TypedLiteralOriginalContent.createTypedLiteral("\""								+ content + "\"",								"<http://www.w3.org/2001/XMLSchema#boolean>");			} catch (final URISyntaxException e) {				literal = (allowLazyLiteral) ? LiteralFactory						.createLiteral(content) : LiteralFactory						.createLiteralWithoutLazyLiteral(content);			}		} else if (n instanceof ASTDoubleCircumflex) {			if (n.jjtGetNumChildren() != 2)				System.err.println(n + " is expected to have 2 children!");			else {				final String content = getLiteral(n.jjtGetChild(0), allowLazyLiteral).toString();				final String type = getLiteral(n.jjtGetChild(1), allowLazyLiteral).toString();				try {					literal = (allowLazyLiteral) ? LiteralFactory							.createTypedLiteral(content, type)							: TypedLiteralOriginalContent.createTypedLiteral(									content, type);				} catch (final Exception e) {					literal = (allowLazyLiteral) ? LiteralFactory							.createLiteral(content + "^^" + type)							: LiteralFactory									.createLiteralWithoutLazyLiteral(content											+ "^^" + type);				}			}		} else if (n instanceof ASTLangTag) {			final String content = getLiteral(n.jjtGetChild(0), allowLazyLiteral).toString();			final String lang = ((ASTLangTag) n).getLangTag();			literal = (allowLazyLiteral) ? LiteralFactory					.createLanguageTaggedLiteral(content, lang)					: LanguageTaggedLiteralOriginalLanguage							.createLanguageTaggedLiteral(content, lang);		} else			System.err.println("Unexpected type! "					+ n.getClass().getSimpleName());		return literal;	}  public static SimpleNode parse(String query) throws ParseException  {    TSVParser parser = new TSVParser(new StringReader(query));    switch (parser.expr())    {      default :		try {	 		return ((SimpleNode) parser.jjtree.rootNode());		} catch(Exception e) {			return null;		}      case 0 : return null;      case - 1 : return null;    }  }  public static SimpleNode parse(final InputStream inputStream) throws ParseException  {    TSVParser parser = new TSVParser(inputStream);    switch (parser.expr())    {      default :		try {	 		return ((SimpleNode) parser.jjtree.rootNode());		} catch(Exception e) {			return null;		}      case 0 : return null;      case - 1 : return null;    }  }}PARSER_END(TSVParser)SKIP :{  " "| "\r"| < "#" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    )? > //NEW SKIP COMMENTS JK
}TOKEN :{  < IRI_REF :    (      "<" ("#")? (~[ "\n", "\r", "&", "|", ">", "<" ])* ("#")? ">"    )  |    (      "<"      (        (          "aaa"        | "aaas"        | "acap"        | "cap"        | "cid"        | "crid"        | "data"        | "dav"        | "dict"        | "dns"        | "fax"        | "file"        | "ftp"        | "go"        | "gopher"        | "h323"        | "http"        | "https"        | "iax"        | "icap"        | "im"        | "imap"        | "info"        | "ipp"        | "iris"        | "iris.beep"        | "iris.xpc"        | "iris.xpcs"        | "iris.lwz"        | "ldap"        | "mailto"        | "mid"        | "modem"        | "msrp"        | "msrps"        | "mtqp"        | "mupdate"        | "news"        | "nfs"        | "nntp"        | "opaquelocktoken"        | "pop"        | "pres"        | "rtsp"        | "service"        | "shttp"        | "sip"        | "sips"        | "snmp"        | "soap.beep"        | "soap.beeps"        | "tag"        | "tel"        | "telnet"        | "tftp"        | "thismessage"        | "tip"        | "tv"        | "urn"        | "vemmi"        | "xmlrpc.beep"        | "xmlrpc.beeps"        | "xmpp"        | "z39.50r"        | "z39.50s"        | "afs"        | "dtn"        | "mailserver"        | "pack"        | "tn3270"        | "prospero"        | "snews"        | "videotex"        | "wais"        )        ":" (~[ "\n", "\r", "&", "|", ">", "<" ])*      )?      ">"    ) >| < #VARNAME :    (      < PN_CHARS_U >    | [ "0"-"9" ]    )    (      < PN_CHARS_U >    | [ "0"-"9" ]    | "\u00B7"    | [ "\u0300"-"\u036F" ]    | [ "\u203F"-"\u2040" ]    )* >| < PNAME_NS : (< PN_PREFIX >)? ":" >| < PNAME_LN : < PNAME_NS > < PN_LOCAL > >| < BLANK_NODE_LABEL :    "_:"    (      < PN_CHARS_U >    | [ "0"-"9" ]    )    (      (        < PN_CHARS >      | "."      )*      < PN_CHARS >    )? >| < VAR :    < VAR1 >  | < VAR2 > >| < VAR1 : "?" < VARNAME > >| < VAR2 : "$" < VARNAME > >| < LANGTAG :    "@" ([ "a"-"z", "A"-"Z" ])+    (      "-" ([ "a"-"z", "A"-"Z", "0"-"9" ])+    )* >| < INTEGER : ([ "0"-"9" ])+ >| < DECIMAL : (([ "0"-"9" ])* "." ([ "0"-"9" ])+) |               // the next alternative is based on the testcases of SPARQL 1.0              (([ "0"-"9" ])+ "." ([ "0"-"9" ])*)>| < DOUBLE :    ([ "0"-"9" ])+ "." ([ "0"-"9" ])* < EXPONENT >  | "." ([ "0"-"9" ])+ < EXPONENT >  | ([ "0"-"9" ])+ < EXPONENT > >// | < INTEGER_POSITIVE : "+" < INTEGER > > // now integrated into the grammar...// | < DECIMAL_POSITIVE : "+" < DECIMAL > >// | < DOUBLE_POSITIVE : "+" < DOUBLE > >// | < INTEGER_NEGATIVE : "-" < INTEGER > >// | < DECIMAL_NEGATIVE : "-" < DECIMAL > >// | < DOUBLE_NEGATIVE : "-" < DOUBLE > >| < #EXPONENT : [ "e", "E" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >| < STRING_LITERAL1 :    "'"    (      (~[ "\\", "\n", "\r", "'" ])    | ("\\" ~[ "\n", "\r" ])    )*    "'" >| < STRING_LITERAL2 :    "\""    (      (~[ "\\", "\n", "\r", "\"" ])    | ("\\" ~[ "\n", "\r" ])    )*    "\"" >| < STRING_LITERAL_LONG1 :    "'''"    (      (~[ "\\", "'" ])    | ("\\" ~[ "\n", "\r" ])    )*    "'''" >| < STRING_LITERAL_LONG2 :    "\"\"\""    (      (~[ "\\", "\"" ])    | ("\\" ~[ "\n", "\r" ])    )*    "\"\"\"" >| < NIL : "(" (< WS >)* ")" >| < #WS :    "\u0020"  | "\u0009"  | "\r"  | "\n" >| < ANON : "[" (< WS >)* "]" >| < #PN_CHARS_BASE :    [ "A"-"Z" ]  | [ "a"-"z" ]  | [ "\u00C0"-"\u00D6" ]  | [ "\u00D8"-"\u00F6" ]  | [ "\u00F8"-"\u02FF" ]  | [ "\u0370"-"\u037D" ]  | [ "\u037F"-"\u1FFF" ]  | [ "\u200C"-"\u200D" ]  | [ "\u2070"-"\u218F" ]  | [ "\u2C00"-"\u2FEF" ]  | [ "\u3001"-"\uD7FF" ]  | [ "\uF900"-"\uFDCF" ]  | [ "\uFDF0"-"\uFFFD" ]  | [ "\u1000"-"\uEFFF" ] >| < #PN_CHARS_U :    < PN_CHARS_BASE >  | "_" >| < #PN_CHARS :    < PN_CHARS_U >  | "-"  | [ "0"-"9" ]  | "\u00B7"  | [ "\u0300"-"\u036F" ]  | [ "\u203F"-"\u2040" ] >| < #PN_PREFIX :    < PN_CHARS_BASE >    (      (        < PN_CHARS >      | "."      )*      < PN_CHARS >    )? >| < #PN_LOCAL :    (      < PN_CHARS_U >    | [ "0"-"9" ]    | < PLX >    )    (      (        < PN_CHARS >      | "."      | < PLX >      | "\\:" // added: escaped colon (according to SPARQL 1.1 testcases)!      )*      (        < PN_CHARS >      | < PLX >      )    )? >| < #PLX :    < PERCENT >  | < PN_LOCAL_ESC > >| < #PERCENT : "%" < HEX > < HEX > >| < #HEX :    [ "0"-"9" ]  | [ "A"-"F" ]  | [ "a"-"f" ] >| < #PN_LOCAL_ESC :    ("\005F")  | ("\007E")  | ("\002E")  | ("\002D")  | ("\0021")  | ("\0024")  | ("\0026")  | ("\0027")  | ("\0028")  | ("\0029")  | ("\002A")  | ("\002B")  | ("\002C")  | ("\003B")  | ("\003D")  | ("\003A")  | ("\002F")  | ("\003F")  | ("\0023")  | ("\0040")  | ("\0025") >}int expr() #Result :{}{  (    firstLine() "\n" (resultLine())* < EOF >    {      return 1;    }  )}void firstLine() #Vars :{}{  (Var() ("\t" Var())*)?}//1
void resultLine() #OneResult :{}{  GraphTerm() ("\t" GraphTerm())* "\n"}//98void Var() #Var :{  Token varName;}{  varName = < VAR >  {    jjtThis.setName(varName.image.substring(1));  }}//99
void GraphTerm() #Value :{}{  ( IRIref() | RDFLiteral() | NumericLiteral() | BooleanLiteral() | BlankNode() | (< NIL > #NIL) )?}void RDFLiteral() #RDFLiteral :												//NOW IS AST NODE{}{		LOOKAHEAD((<STRING_LITERAL1>|<STRING_LITERAL2>|<STRING_LITERAL_LONG1>|<STRING_LITERAL_LONG2>)"^^") TypedLiteral() |	LOOKAHEAD((<STRING_LITERAL1>|<STRING_LITERAL2>|<STRING_LITERAL_LONG1>|<STRING_LITERAL_LONG2>)<LANGTAG>) LiteralWithLangTag() | 	String()			//CHANGED JK}void TypedLiteral() #DoubleCircumflex:{}{	String() "^^" IRIref()}void LiteralWithLangTag() #LangTag:{}{	String() < LANGTAG > { jjtThis.setLangTag(token.image); }}//120
void NumericLiteral() :{}{  NumericLiteralUnsigned()| NumericLiteralPositive()| NumericLiteralNegative()}//121
void NumericLiteralUnsigned() :{}{  NumericLiteralUnsignedInteger()| NumericLiteralUnsignedFloatingPoint()}void NumericLiteralUnsignedInteger() #Integer :{}{	< INTEGER > { jjtThis.setStringInt((token.image)); }}void NumericLiteralUnsignedFloatingPoint() #FloatingPoint :{}{	< DECIMAL > { jjtThis.setValue((token.image)); }| 	< DOUBLE > { jjtThis.setValue((token.image)); }}//122
void NumericLiteralPositive() :{}{  "+"  ( NumericLiteralPositiveInteger() | NumericLiteralPositiveFloatingPoint())}void NumericLiteralPositiveInteger() #Integer :{}{	< INTEGER > { jjtThis.setStringInt((token.image)); }}void NumericLiteralPositiveFloatingPoint() #FloatingPoint :{}{	(< DECIMAL > { jjtThis.setValue((token.image)); })| 	(< DOUBLE > { jjtThis.setValue((token.image)); })}//123
void NumericLiteralNegative() :{}{  "-"  (NumericLiteralNegativeInteger() | NumericLiteralNegativeFloatingPoint())}void NumericLiteralNegativeInteger() #Integer :{}{	< INTEGER > { jjtThis.setStringInt("-"+(token.image)); }}void NumericLiteralNegativeFloatingPoint() #FloatingPoint :{}{	(< DECIMAL > { jjtThis.setValue("-"+(token.image)); })| 	(< DOUBLE > { jjtThis.setValue("-"+(token.image)); })}//124
void BooleanLiteral() #BooleanLiteral :{}{  ( "true" { jjtThis.setState(true); })| ( "false" { jjtThis.setState(false); })}//125
void String() #StringLiteral :{  Token t;}{  t = < STRING_LITERAL1 >  {    jjtThis.setStringLiteral(t.image);  }| t = < STRING_LITERAL2 >  {    jjtThis.setStringLiteral(t.image);  }| t = < STRING_LITERAL_LONG1 >  {    jjtThis.setStringLiteral(t.image);  }| t = < STRING_LITERAL_LONG2 >  {    jjtThis.setStringLiteral(t.image);  }}//126
void IRIref() :{}{  QuotedIriRef()}void QuotedIriRef() #QuotedURIRef :{  Token qRef;}{  qRef = < IRI_REF >  { jjtThis.setQRef(qRef.image.substring(1, qRef.image.length() - 1)); }}//128
void BlankNode() :{  Token t;}{  t = < BLANK_NODE_LABEL > { jjtThis.setIdentifier((t.image)); } #BlankNode| (< ANON > #EmptyNode)}