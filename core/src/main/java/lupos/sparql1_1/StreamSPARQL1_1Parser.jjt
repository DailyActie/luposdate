 /* -------------  SPARQL - Parser -----------------*/options{  IGNORE_CASE = true;  MULTI = true; // many class names
  NODE_DEFAULT_VOID = true; // do not generates jjtree nodes by default
  JAVA_UNICODE_ESCAPE = true;  VISITOR = true;  STATIC = false;}PARSER_BEGIN(StreamSPARQL1_1Parser)package lupos.sparql1_1;import java.io.*;import java.util.HashSet;public class StreamSPARQL1_1Parser{  public static void main(String args [])  {    System.out.println("enter query...");    StreamSPARQL1_1Parser parser = new StreamSPARQL1_1Parser(System.in);    try    {            	parser.expr();      	System.out.println("Result:");			((SimpleNode) parser.jjtree.rootNode()).dump("|");} catch(Exception e){ System.out.println(e); e.printStackTrace();}  }  public static SimpleNode parse(String query) throws ParseException  {    StreamSPARQL1_1Parser parser = new StreamSPARQL1_1Parser(new StringReader(query));    switch (parser.expr())    {      default :		try {	 		return ((SimpleNode) parser.jjtree.rootNode());		} catch(Exception e) {			return null;		}      case 0 : return null;      case - 1 : return null;    }  }  protected HashSet < String > declaredPrefixes = new HashSet < String > ();}PARSER_END(StreamSPARQL1_1Parser)void GroupGraphPatternsAndRDFTermsEOF() #GroupConstraint:{}{ 	(GroupGraphPattern())*(VarOrTerm())* < EOF >}void N3GroupGraphPatternsAndRDFTermsEOF() #GroupConstraint:{}{	(N3GroupConstraint())*(GraphTerm())* <EOF>}void N3GroupConstraint() #GroupConstraint :{}{ "{" (N3TriplesSet() (".")?)* "}"}void N3TriplesSet()#TripleSet:{}{  GraphTerm() (URI() | BlankNode()) GraphTerm()}void ConstraintEOF() :{}{  (    Constraint() < EOF >  )}void VarOrTermEOF() :{}{  (    VarOrTerm() < EOF >  )}void GraphTermEOF() :{}{  (    GraphTerm() < EOF >  )}void VerbEOF() :{}{  (    Verb() < EOF >  )}void VerbWithoutVarEOF() :{}{  (    URI()  | ("a" #AVerbType)  )  < EOF >}void GroupGraphPatternEOF() :{}{  GroupGraphPattern() < EOF >}void VarEOF() :{}{  (    Var() < EOF >  )}void SourceSelectorEOF() :{}{  (    SourceSelector() < EOF >  )}void OrderConditionEOF() :{}{  (    OrderCondition() < EOF >  )}void VarOrBlankNodeOrIRIrefEOF() :{}{  (    VarOrBlankNodeOrIRIref() < EOF >  )}void VarOrURIEOF() :{}{  (    VarOrURI() < EOF >  )}SKIP :{  " "| "\t"| "\n"| "\r"| < "#" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    )? > //NEW SKIP COMMENTS JK
}TOKEN :{  < IRI_REF :    (      "<" ("#")? (~[ "\n", "\r", ">", "<", " " ])* ("#")? ">"    )  |    (      "<"      (        (          "aaa"        | "aaas"        | "acap"        | "cap"        | "cid"        | "crid"        | "data"        | "dav"        | "dict"        | "dns"        | "fax"        | "file"        | "ftp"        | "go"        | "gopher"        | "h323"        | "http"        | "https"        | "iax"        | "icap"        | "im"        | "imap"        | "info"        | "ipp"        | "iris"        | "iris.beep"        | "iris.xpc"        | "iris.xpcs"        | "iris.lwz"        | "ldap"        | "mailto"        | "mid"        | "modem"        | "msrp"        | "msrps"        | "mtqp"        | "mupdate"        | "news"        | "nfs"        | "nntp"        | "opaquelocktoken"        | "pop"        | "pres"        | "rtsp"        | "service"        | "shttp"        | "sip"        | "sips"        | "snmp"        | "soap.beep"        | "soap.beeps"        | "tag"        | "tel"        | "telnet"        | "tftp"        | "thismessage"        | "tip"        | "tv"        | "urn"        | "vemmi"        | "xmlrpc.beep"        | "xmlrpc.beeps"        | "xmpp"        | "z39.50r"        | "z39.50s"        | "afs"        | "dtn"        | "mailserver"        | "pack"        | "tn3270"        | "prospero"        | "snews"        | "videotex"        | "wais"        )        ":" (~[ "\n", "\r", ">", "<", " " ])*      )?      ">"    ) >| < #VARNAME :    (      < PN_CHARS_U >    | [ "0"-"9" ]    )    (      < PN_CHARS_U >    | [ "0"-"9" ]    | "\u00B7"    | [ "\u0300"-"\u036F" ]    | [ "\u203F"-"\u2040" ]    )* >| < PNAME_NS : (< PN_PREFIX >)? ":" >| < PNAME_LN : < PNAME_NS > < PN_LOCAL > >| < BLANK_NODE_LABEL :    "_:"    (      < PN_CHARS_U >    | [ "0"-"9" ]    )    (      (        < PN_CHARS >      | "."      )*      < PN_CHARS >    )? >| < VAR :    < VAR1 >  | < VAR2 > >| < VAR1 : "?" < VARNAME > >| < VAR2 : "$" < VARNAME > >| < LANGTAG :    "@" ([ "a"-"z", "A"-"Z" ])+    (      "-" ([ "a"-"z", "A"-"Z", "0"-"9" ])+    )* >| < INTEGER : ([ "0"-"9" ])+ >| < DECIMAL : (([ "0"-"9" ])* "." ([ "0"-"9" ])+) |               // the next alternative is based on the testcases of SPARQL 1.0              (([ "0"-"9" ])+ "." ([ "0"-"9" ])*)>| < DOUBLE :    ([ "0"-"9" ])+ "." ([ "0"-"9" ])* < EXPONENT >  | "." ([ "0"-"9" ])+ < EXPONENT >  | ([ "0"-"9" ])+ < EXPONENT > >// | < INTEGER_POSITIVE : "+" < INTEGER > > // now integrated into the grammar...// | < DECIMAL_POSITIVE : "+" < DECIMAL > >// | < DOUBLE_POSITIVE : "+" < DOUBLE > >// | < INTEGER_NEGATIVE : "-" < INTEGER > >// | < DECIMAL_NEGATIVE : "-" < DECIMAL > >// | < DOUBLE_NEGATIVE : "-" < DOUBLE > >| < #EXPONENT : [ "e", "E" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >| < STRING_LITERAL1 :    "'"    (      (~[ "\\", "\n", "\r", "'" ])    | ("\\" ~[ "\n", "\r" ])    )*    "'" >| < STRING_LITERAL2 :    "\""    (      (~[ "\\", "\n", "\r", "\"" ])    | ("\\" ~[ "\n", "\r" ])    )*    "\"" >| < STRING_LITERAL_LONG1 :    "'''"    (      (~[ "\\", "'" ])    | ("\\" ~[ "\n", "\r" ])    )*    "'''" >| < STRING_LITERAL_LONG2 :    "\"\"\""    (      (~[ "\\", "\"" ])    | ("\\" ~[ "\n", "\r" ])    )*    "\"\"\"" >| < NIL : "(" (< WS >)* ")" >| < #WS :    "\u0020"  | "\u0009"  | "\r"  | "\n" >| < ANON : "[" (< WS >)* "]" >| < #PN_CHARS_BASE :    [ "A"-"Z" ]  | [ "a"-"z" ]  | [ "\u00C0"-"\u00D6" ]  | [ "\u00D8"-"\u00F6" ]  | [ "\u00F8"-"\u02FF" ]  | [ "\u0370"-"\u037D" ]  | [ "\u037F"-"\u1FFF" ]  | [ "\u200C"-"\u200D" ]  | [ "\u2070"-"\u218F" ]  | [ "\u2C00"-"\u2FEF" ]  | [ "\u3001"-"\uD7FF" ]  | [ "\uF900"-"\uFDCF" ]  | [ "\uFDF0"-"\uFFFD" ]  | [ "\u1000"-"\uEFFF" ] >| < #PN_CHARS_U :    < PN_CHARS_BASE >  | "_" >| < #PN_CHARS :    < PN_CHARS_U >  | "-"  | [ "0"-"9" ]  | "\u00B7"  | [ "\u0300"-"\u036F" ]  | [ "\u203F"-"\u2040" ] >| < #PN_PREFIX :    < PN_CHARS_BASE >    (      (        < PN_CHARS >      | "."      )*      < PN_CHARS >    )? >| < #PN_LOCAL :    (      < PN_CHARS_U >    | [ "0"-"9" ]    | < PLX >    )    (      (        < PN_CHARS >      | "."      | < PLX >      | "\\:" // added: escaped colon (according to SPARQL 1.1 testcases)!      )*      (        < PN_CHARS >      | < PLX >      )    )? >| < #PLX :    < PERCENT >  | < PN_LOCAL_ESC > >| < #PERCENT : "%" < HEX > < HEX > >| < #HEX :    [ "0"-"9" ]  | [ "A"-"F" ]  | [ "a"-"f" ] >| < #PN_LOCAL_ESC :    ("\005F")  | ("\007E")  | ("\002E")  | ("\002D")  | ("\0021")  | ("\0024")  | ("\0026")  | ("\0027")  | ("\0028")  | ("\0029")  | ("\002A")  | ("\002B")  | ("\002C")  | ("\003B")  | ("\003D")  | ("\003A")  | ("\002F")  | ("\003F")  | ("\0023")  | ("\0040")  | ("\0025") >}int expr() :{}{  (    QueryOrUpdate() < EOF >    {      return 1;    }  )}void QueryOrUpdate() #Query :{}{  Prologue()  (    (    	(	    	SelectQuery()  			| ConstructQuery()  			| DescribeQuery()  			| AskQuery()  		)  		ValuesClause()  	)//  	|//  	(//  		Update1() (";" (Update1())?)*//  	)  )? }//1
void QueryUnit() :{}{  Query()}//2
void Query() #Query :{}{  Prologue()  (    SelectQuery()  | ConstructQuery()  | DescribeQuery()  | AskQuery()  )  ValuesClause()}//3
void UpdateUnit() :{}{  Update()}//4
void Prologue() :{}{  (    BaseDecl()  | PrefixDecl()  )*}//5
void BaseDecl() #BaseDecl :{}{  "BASE" QuotedURIref()}//6
void PrefixDecl() #PrefixDecl :{  Token qName;}{  "PREFIX" qName = < PNAME_NS > QuotedURIref()  {    String prefix = qName.image.substring(0, qName.image.indexOf(":"));    jjtThis.setPrefix(prefix);    declaredPrefixes.add(prefix);  }}//7
void SelectQuery() #SelectQuery :{}{  SelectClause(jjtThis)  // Added STREAM  (STREAM())?  // and removed DatasetClause!  // (DatasetClause())*   WhereClause() SolutionModifier()}//8
void SubSelect() #SelectQuery :{}{  SelectClause(jjtThis) WhereClause() SolutionModifier()}//9
void SelectClause(ASTSelectQuery select) :{}{  "SELECT"  (    (      "DISTINCT"      {        select.setDistinct(true);      }    )  |    (      "REDUCED"      {        select.setReduced(true);      }    )  )?  (    (      (        LOOKAHEAD(2)        Var()      |        As()      )    )+  |    (      (        "*"        {          select.setSelectAll(true);        }      )    )  )}void As() #As :{}{  "(" Expression() "AS" Var() ")"}//10
void ConstructQuery() #ConstructQuery :{}{  "CONSTRUCT"  (    ConstructTemplate()    // Added STREAM    (STREAM())?    // and removed DatasetClause!    // (DatasetClause())*     WhereClause() SolutionModifier()  |    // Added STREAM    (STREAM())?    // and removed DatasetClause!    // (DatasetClause())*     ConstructQueryWherePart()    SolutionModifier()  )}void ConstructQueryWherePart() #GroupConstraint :{}{     "WHERE" "{"    (      TriplesTemplate()    )?    "}"}//11
void DescribeQuery() #DescribeQuery :{}{  "DESCRIBE"  (    (      VarOrIRIref()    )+  |    (      "*"      {        jjtThis.setDescribeAll(true);      }    )  )  // Added STREAM  (STREAM())?  // and removed DatasetClause!  // (DatasetClause())*   (    WhereClause()  )?  SolutionModifier()}//12
void AskQuery() #AskQuery :{}{  "ASK"  // Added STREAM  (STREAM())?  // and removed DatasetClause!  // (DatasetClause())*   WhereClause() SolutionModifier()}// added:// Determines how often an intermediate result is computed:// DURATION 5000 means every 5000 milliseconds, i.e., every 5 seconds// TRIPLES 10 means every time after 10 triples have been read// Default is STREAM INTERMEDIATERESULT TRIPLES 1, i.e., the intermediate result is// computed every time after reading the next triple from the streamvoid STREAM()#Stream:{Token t;}{	"STREAM" ("INTERMEDIATERESULT" 	("DURATION" {jjtThis.setDuration();} | "TRIPLES" {jjtThis.setTriples();}) 	t=<INTEGER> {jjtThis.setValue(Integer.parseInt(t.image));})?}// START and END contain conditions when the window is started or ended// Default is WINDOW SLIDINGTRIPLES INFINITY START true() END false()void WINDOW()#Window:{}{	"WINDOW" (TYPE())? ("START" #Start Constraint())? ("END" #End Constraint())? GroupGraphPattern()}// to do: add support for tumbling window, landmark window, ...void TYPE()#Type:{Token t;}{	"TYPE"	(	  ("INSTANCE" IRIref()	  (	    "SLIDINGDURATION" {jjtThis.setInstancesDuration();}	  |	  	"SLIDINGINSTANCES" {jjtThis.setInstancesNumber();}	  )	  )	|	(	 ("SLIDINGDURATION" {jjtThis.setDuration();} | 	 "SLIDINGTRIPLES" {jjtThis.setTriples();})))	 t=<INTEGER> {jjtThis.setValue(Integer.parseInt(t.image));}}//13
void DatasetClause() :{}{  "FROM"  (    DefaultGraphClause()  | NamedGraphClause()  )}//14
void DefaultGraphClause() #DefaultGraph :{}{  SourceSelector()}//15
void NamedGraphClause() #NamedGraph :{}{  "NAMED" SourceSelector()}//16
void SourceSelector() :{}{  IRIref()}//17
void WhereClause() :{}{  ("WHERE")? GroupGraphPattern()}//18
void SolutionModifier() :{}{  (    GroupClause()  )?  (    HavingClause()  )?  (    OrderClause()  )?  (    LimitOffsetClauses()  )?}//19
void GroupClause() #Group :{}{  "GROUP" "BY"  (    GroupCondition()  )+}//20
void GroupCondition() :{}{  BuiltInCall()| FunctionCall()|  (    "(" Expression()    (      "AS" Var() #As(2)    )?    ")"  )| Var()}//21
void HavingClause() #Having :{}{  "HAVING"  (    HavingCondition()  )+}//22
void HavingCondition() :{}{  Constraint()}//23
void OrderClause() #OrderConditions :{}{  "ORDER" "BY"  (    OrderCondition()  )+}//24
void OrderCondition() :{}{  (    (      (        "ASC" #AscOrder()    )  |    (      "DESC" #DescOrder()  ))BrackettedExpression())|(  Constraint()| Var())}//25
void LimitOffsetClauses() :{}{  (    LimitClause()    (      OffsetClause()    )?  )|  (    OffsetClause()    (      LimitClause()    )?  )}//26
void LimitClause() #Limit :{  Token limit;}{  "LIMIT" limit = < INTEGER >  {    jjtThis.setLimit(limit.image);  }}//27
void OffsetClause() #Offset :{  Token offset;}{  "OFFSET" offset = < INTEGER >  {    jjtThis.setOffset(offset.image);  }}// 28void ValuesClause() :{}{  (InlineData())?}void InlineData() #Bindings :{}{    "VALUES" DataBlock()}void DataBlock():{}{  	InlineDataOneVar() | InlineDataFull()}void InlineDataOneVar():{}{ Var() "{" (DataBlockValueOneVar())* "}"}void DataBlockValueOneVar() #PlusNode :{}{	DataBlockValue()}void InlineDataFull():{}{  ( < NIL > | "(" (Var())* ")" ) "{" ( sequenceOfDataBlockValues() | < NIL > )* "}"}void sequenceOfDataBlockValues() #PlusNode :{}{	"(" (DataBlockValue())* ")"}//29void DataBlockValue() :{}{  IRIref()| RDFLiteral()| NumericLiteral()| BooleanLiteral()| "UNDEF" #Undef}//30
void Update() :{}{  Prologue()  (    Update1()    (      ";" Update()    )?  )?}//31
void Update1() :{}{  Load()| Clear()| Drop()| Add()| Move()| Copy()| Create()  | LOOKAHEAD("INSERT" "DATA") InsertData()| LOOKAHEAD("DELETE" "DATA") DeleteData()| LOOKAHEAD("DELETE" "WHERE") DeleteWhere()| Modify()}//32
void Load() #Load :{}{  "LOAD" ("SILENT" {jjtThis.setSilent();} )? IRIref()  (    "INTO" GraphRef()  )?}//33
void Clear() #Clear :{}{  "CLEAR" ("SILENT" {jjtThis.setSilent();} )? GraphRefAll()}//34
void Drop() #Drop :{}{  "DROP" ("SILENT" {jjtThis.setSilent();} )? GraphRefAll()}//35
void Create() #Create :{}{  "CREATE" ("SILENT" {jjtThis.setSilent();} )? GraphRef()}//36
void Add() #Add :{}{  "ADD" ("SILENT" {jjtThis.setSilent();} )? GraphOrDefault() "TO" GraphOrDefault()}//37
void Move() #Move :{}{  "MOVE" ("SILENT" {jjtThis.setSilent();} )? GraphOrDefault() "TO" GraphOrDefault()}//38
void Copy() #Copy :{}{  "COPY" ("SILENT" {jjtThis.setSilent();} )? GraphOrDefault() "TO" GraphOrDefault()}//39
void InsertData() #Insert :{}{  "INSERT" "DATA" QuadData()}//40
void DeleteData() #Delete :{}{  "DELETE" "DATA"  {jjtThis.setDeleteData();}  QuadData()}//41
void DeleteWhere() #Modify :{}{  "DELETE" "WHERE" InterDeleteWhere()}void InterDeleteWhere() #Delete :{}{  QuadPattern()}//42
void Modify() #Modify :{}{  (    "WITH" IRIref()  )?  (    (      DeleteClause()      (        InsertClause()      )?    )  | InsertClause()  )  (    UsingClause()  )*  "WHERE" GroupGraphPattern()}//43
void DeleteClause() #Delete :{}{  "DELETE" QuadPattern()}//44
void InsertClause() #Insert :{}{  "INSERT" QuadPattern()}//45
void UsingClause() :{}{  "USING"  (UsingDefault() | UsingNamed())}void UsingDefault() #DefaultGraph :{}{	IRIref()}void UsingNamed() #NamedGraph :{}{	"NAMED" IRIref()}//46
void GraphOrDefault() :{}{  "DEFAULT" #Default|  (    ("GRAPH")? IRIref()  )}//47
void GraphRef() :{}{  "GRAPH" IRIref()}//48
void GraphRefAll() :{}{  GraphRef()| "DEFAULT" #Default| "NAMED" #Named| "ALL" #All}//49
void QuadPattern() #ConstructTemplate :{}{  "{" Quads() "}"}//50
void QuadData() #ConstructTemplate :{}{  "{" Quads() "}"}//51
void Quads() :{}{  (    TriplesTemplate()  )?  (    QuadsNotTriples() (".")?    (      TriplesTemplate()    )?  )*}//52
void QuadsNotTriples() #GraphConstraint :{}{  "GRAPH" VarOrIRIref() "{"  (    TriplesTemplate()  )?  "}"}//53
void TriplesTemplate() :{}{  TriplesSameSubject()  (    "."    (      TriplesTemplate()    )?  )?}//54
void GroupGraphPattern() #GroupConstraint :{}{  "{"  (    SubSelect()  // | GroupGraphPatternSub()  // added WindowInGroup():     | WindowInGroup()  | GroupGraphPatternSub()  )  "}"}// added for stream-based evaluation...void WindowInGroup():{}{  WINDOW()  GroupGraphPatternSub()  (    WindowInGroup()  )?}  //55
void GroupGraphPatternSub() :{}{  (    TriplesBlock()  )?  (    (      GraphPatternNotTriples()    )    (".")?    (      TriplesBlock()    )?  )*}//56
void TriplesBlock() :{}{  TriplesSameSubjectPath()  (    "."    (      TriplesBlock()    )?  )?}//57
void GraphPatternNotTriples() :{}{  GroupOrUnionGraphPattern()| OptionalGraphPattern()| MinusGraphPattern()| GraphGraphPattern()| ServiceGraphPattern()| Filter()| Bind()| InlineData()}//58
void OptionalGraphPattern() #OptionalConstraint :{}{  "OPTIONAL" GroupGraphPattern()}//59
void GraphGraphPattern() #GraphConstraint :{}{  "GRAPH" VarOrIRIref() GroupGraphPattern()}//60
void ServiceGraphPattern() #Service :{}{  "SERVICE" ("SILENT" {jjtThis.setSilent();} )? VarOrIRIref() GroupGraphPattern()}//61
void Bind() #Bind :{}{  "BIND" "(" Expression() "AS" Var() ")"}//62
void MinusGraphPattern() #Minus :{}{  "MINUS" GroupGraphPattern()}//63
void GroupOrUnionGraphPattern() :{}{  GroupGraphPattern()  (    "UNION" GroupGraphPattern() #UnionConstraint(2))*}//64
void Filter() :{}{  "FILTER" Constraint()}//65
void Constraint() #FilterConstraint :{}{  BrackettedExpression()| BuiltInCall()| FunctionCall()}//66
void FunctionCall() #FunctionCall :{}{  IRIref() ArgList()}//67
void ArgList() #Arguments :{}{  < NIL >|  (    "(" ("DISTINCT")? Expression()    (      "," Expression()    )*    ")"  )}//68
void ExpressionList() #ExpressionList :{}{  < NIL >|  (    "(" Expression()    (      "," Expression()    )*    ")"  )}//69
void ConstructTemplate() #ConstructTemplate :{}{  "{"  (    ConstructTriples()  )?  "}"}//70
void ConstructTriples() :{}{  TriplesSameSubject()  (    "."    (      ConstructTriples()    )?  )?}//71
void TriplesSameSubject() :{}{  LOOKAHEAD("("|"[") (TriplesNode() PropertyList()) #NodeSet  | (VarOrTerm() PropertyListNotEmpty()) #TripleSet}//72
void PropertyListNotEmpty():{}{  Verb()  ObjectList()  (    ";"    (      Verb() ObjectList()    )?  )*}//73
void PropertyList() :{}{  (    PropertyListNotEmpty()  )?}//74
void ObjectList() #ObjectList:{}{  Object()  (    "," Object()  )*}//75
void Object() :{}{  GraphNode()}//76
void Verb() :{}{ VarOrIRIref()| ("a" #AVerbType)}//77
void TriplesSameSubjectPath() :{}{  LOOKAHEAD("("|"[")  (TriplesNode() PropertyListPath()) #NodeSet|   (    VarOrTerm() PropertyListNotEmptyPath()  ) #TripleSet}//78
void PropertyListNotEmptyPath():{}{  (    VerbPath()  | VerbSimple()  )  ObjectList()  (    ";"    (      (        VerbPath()      | VerbSimple()      )      ObjectList()    )?  )*}//79
void PropertyListPath() :{}{  (    PropertyListNotEmpty()  )?}//80
void VerbPath() :{}{  Path()}//81
void VerbSimple() :{}{  Var()}//82
void Path() :{}{  PathAlternative()}//83
void PathAlternative() :{}{  PathSequence()  (    "|"   // PathSequence() )*  	PathAlternative() #PathAlternative(2)  )?}//84
void PathSequence() :{}{  PathEltOrInverse()  (    "/"     // PathEltOrInverse()    // )*    PathSequence() #PathSequence(2)  )?}//85
void PathElt() :{}{  PathPrimary()    (    LOOKAHEAD(2)    PathMod()  )?}//86
void PathEltOrInverse() :{}{  PathElt()|  (    "^" PathElt() #Invers(1)  )}//87
void PathMod() :{}{  "*" #ArbitraryOccurences(1)| "?" #OptionalOccurence(1)| "+" #ArbitraryOccurencesNotZero(1)}//88
void PathPrimary() :{ Token t;}{  IRIref()| ("a" #AVerbType)| ("!" PathNegatedPropertySet())| ("(" Path() ")")| DistinctPath()}void DistinctPath() #DistinctPath :{}{  "DISTINCT"  "(" Path() ")"}//89
void PathNegatedPropertySet() #NegatedPath :{}{  PathOneInPropertySet()|  (    "("    (      PathOneInPropertySet()      (        "|" PathOneInPropertySet()      )*    )?    ")"  )}//90
void PathOneInPropertySet() :{}{  IRIref()| ("a" #AVerbType)| ("^" (IRIref() | ("a" #AVerbType)) #Invers(1) )}//91
void Integer() #Integer :{}{  < INTEGER >  {    jjtThis.setValue(token.image);  }}//92
void TriplesNode() :{}{  Collection()| BlankNodePropertyList()}//93
void BlankNodePropertyList() #BlankNodePropertyList :{}{  "[" PropertyListNotEmpty() "]"}//94
void Collection() #Collection :{}{  "("  (    GraphNode()  )+  ")"}//95
void GraphNode() :{}{  LOOKAHEAD(2)  VarOrTerm()| TriplesNode()}//96
void VarOrTerm() :{}{  Var()| GraphTerm()}//97
void VarOrIRIref() :{}{  Var()| IRIref()}//98
void Var() #Var :{  Token varName;}{  varName = < VAR >  {    jjtThis.setName(varName.image.substring(1));  }}//99
void GraphTerm() :{}{  IRIref()| RDFLiteral()| NumericLiteral()| BooleanLiteral()| BlankNode()| (< NIL > #NIL)}//100
void Expression() :{}{  ConditionalOrExpression()}//101
void ConditionalOrExpression() :{}{  ConditionalAndExpression()  (    "||" ConditionalAndExpression() #OrNode(2))*}//102
void ConditionalAndExpression() :{}{  ValueLogical()  (    "&&" ValueLogical() #AndNode(2))*}//103
void ValueLogical() :{}{  RelationalExpression()}//104
void RelationalExpression() :{}{  NumericExpression()  (    (      "=" NumericExpression() #EqualsNode(2)  )|  (    "!=" NumericExpression() #NotEqualsNode(2))|(  "<" NumericExpression() #LessThanNode(2))|(  ">" NumericExpression() #GreaterThanNode(2))|(  "<=" NumericExpression() #LessThanEqualsNode(2) )|(  ">=" NumericExpression() #GreaterThanEqualsNode(2))|(  "IN" ExpressionList() #InNode(2))|(  "NOT" "IN" ExpressionList() #NotInNode(2)))?}//105
void NumericExpression() :{}{  AdditiveExpression()}//106
void AdditiveExpression() :{}{  MultiplicativeExpression()  (    ("+" MultiplicativeExpression() #AdditionNode(2)) | ("-" MultiplicativeExpression() #SubtractionNode(2))//   | // NumericLiteralPositive now does not go over the Lexer, but the parser!//    ( NumericLiteralPositive() | NumericLiteralNegative() )//    ( ("*" UnaryExpression() #MultiplicationNode(2)) | ("/" UnaryExpression() #DivisionNode(2)) )?  )*}//107
void MultiplicativeExpression() :{}{  UnaryExpression()  (    (      "*" UnaryExpression() #MultiplicationNode(2)  )|  (    "/" UnaryExpression() #DivisionNode(2)))*}//108
void UnaryExpression() :{}{("!" PrimaryExpression()) #NotNode(1)| LOOKAHEAD(2) ("+" PrimaryExpressionWithoutNumericLiteral()) #PlusNode(1)| LOOKAHEAD(2) ("-" PrimaryExpressionWithoutNumericLiteral()) #MinusNode(1)| PrimaryExpression()}void PrimaryExpressionWithoutNumericLiteral() :{}{  BrackettedExpression()| BuiltInCall()| IRIrefOrFunction()| RDFLiteral()| BooleanLiteral()| Var()| Aggregate()}//109
void PrimaryExpression() :{}{  BrackettedExpression()| BuiltInCall()| IRIrefOrFunction()| RDFLiteral()| NumericLiteral()| BooleanLiteral()| Var()| Aggregate()}//110
void BrackettedExpression() :{}{  "(" Expression() ")"}//111
void BuiltInCall() :{}{  STR()| LANG()| LANGMATCHES()| DATATYPE() | BOUND()| IRIFunc()| URIFunc()| BNODE()| RAND()| ABS()| CEIL()| FLOOR()| ROUND()| CONCAT()| SubstringExpression()| STRLEN()| StrReplaceExpression()| UCASE()| LCASE()| ENCODE_FOR_URI()| CONTAINS()| STRSTARTS()| STRENDS()| STRBEFORE()| STRAFTER()| YEAR()| MONTH()| DAY()| HOURS()| MINUTES()| SECONDS()| TIMEZONE()| TZ()| NOW()| UUID()| STRUUID()| MD5()| SHA1()| SHA256()| SHA384()| SHA512()| COALESCE()| IF()| STRLANG()| STRDT()| sameTerm()| isIRI()| isURI()| isBLANK()| isLITERAL()| isNUMERIC()| RegexExpression()| ExistsFunc()| NotExistsFunc()}void STR() #StrFuncNode :{}{	"STR" "(" Expression() ")"}void LANG() #LangFuncNode :{}{  "LANG" "(" Expression() ")"}void LANGMATCHES() #LangMatchesFuncNode :{}{  "LANGMATCHES" "(" Expression() "," Expression() ")"}void DATATYPE() #DataTypeFuncNode :{}{    "DATATYPE" "(" Expression() ")"} void BOUND() #BoundFuncNode :{}{    "BOUND" "(" Var() ")"}void IRIFunc() #IriFuncNode :{}{    "IRI" "(" Expression() ")"}void URIFunc() #UriFuncNode :{}{    "URI" "(" Expression() ")"}void BNODE() #BnodeFuncNode :{}{    "BNODE"  (    "(" Expression() ")"  | < NIL >  ) }void RAND() #RandFuncNode :{}{    "RAND" < NIL >}void ABS() #ABSFuncNode :{}{    "ABS" "(" Expression() ")"}void CEIL() #CeilFuncNode :{}{    "CEIL" "(" Expression() ")"}void FLOOR() #FloorFuncNode :{}{    "FLOOR" "(" Expression() ")" }void ROUND() #RoundFuncNode :{}{    "ROUND" "(" Expression() ")"}void CONCAT() #ConcatFuncNode :{}{    "CONCAT" ExpressionList()}void STRLEN() #StrlenFuncNode :{}{    "STRLEN" "(" Expression() ")"}void UCASE() #UcaseFuncNode :{}{    "UCASE" "(" Expression() ")"}void LCASE() #LcaseFuncNode :{}{    "LCASE" "(" Expression() ")" }void ENCODE_FOR_URI() #EncodeForUriFuncNode :{}{    "ENCODE_FOR_URI" "(" Expression() ")"}void CONTAINS() #ContainsFuncNode :{}{    "CONTAINS" "(" Expression() "," Expression() ")"}void STRSTARTS()  #StrstartsFuncNode :{}{    "STRSTARTS" "(" Expression() "," Expression() ")"}void STRENDS() #StrEndsFuncNode :{}{    "STRENDS" "(" Expression() "," Expression() ")"}void STRBEFORE() #StrBeforeFuncNode :{}{    "STRBEFORE" "(" Expression() "," Expression() ")"}void STRAFTER() #StrAfterFuncNode :{}{    "STRAFTER" "(" Expression() "," Expression() ")"}void YEAR() #YearFuncNode :{}{    "YEAR" "(" Expression() ")"}void MONTH() #MonthFuncNode :{}{    "MONTH" "(" Expression() ")"}void DAY() #DayFuncNode :{}{    "DAY" "(" Expression() ")"}void HOURS() #HoursFuncNode :{}{    "HOURS" "(" Expression() ")"}void MINUTES() #MinutesFuncNode :{}{    "MINUTES" "(" Expression() ")"}void SECONDS() #SecondsFuncNode :{}{    "SECONDS" "(" Expression() ")"}void TIMEZONE() #TimeZoneFuncNode :{}{    "TIMEZONE" "(" Expression() ")"}void TZ() #TzFuncNode :{}{    "TZ" "(" Expression() ")"}void NOW() #NowFuncNode :{}{    "NOW" < NIL >}void UUID() #UUIDFuncNode :{}{  "UUID" < NIL >}void STRUUID() #STRUUIDFuncNode :{}{  "STRUUID" < NIL >}void MD5() #MD5FuncNode :{}{    "MD5" "(" Expression() ")"}void SHA1() #SHA1FuncNode :{}{    "SHA1" "(" Expression() ")"}void SHA256() #SHA256FuncNode :{}{    "SHA256" "(" Expression() ")"}void SHA384() #SHA384FuncNode :{}{    "SHA384" "(" Expression() ")"}void SHA512() #SHA512FuncNode :{}{    "SHA512" "(" Expression() ")"}void COALESCE() #CoalesceFuncNode :{}{    "COALESCE" ExpressionList()}void IF() #IfFuncNode :{}{    "IF" "(" Expression() "," Expression() "," Expression() ")"}void STRLANG() #StrLangFuncNode :{}{    "STRLANG" "(" Expression() "," Expression() ")"}void STRDT() #StrdtFuncNode :{}{    "STRDT" "(" Expression() "," Expression() ")"}void sameTerm() #SameTermFuncNode :{}{    "sameTerm" "(" Expression() "," Expression() ")"}void isIRI() #isIRIFuncNode :{}{    "isIRI" "(" Expression() ")"}void isURI() #isURIFuncNode :{}{    "isURI" "(" Expression() ")"}void isBLANK() #isBlankFuncNode :{}{    "isBLANK" "(" Expression() ")"}void isLITERAL() #isLiteralFuncNode :{}{    "isLITERAL" "(" Expression() ")"}void isNUMERIC() #isNumericFuncNode :{}{    "isNUMERIC" "(" Expression() ")"}//112
void RegexExpression() #RegexFuncNode :{}{  "REGEX" "(" Expression() "," Expression()  (    "," Expression()  )?  ")"}//113
void SubstringExpression() #SubstringFuncNode :{}{  "SUBSTR" "(" Expression() "," Expression()  (    "," Expression()  )?  ")"}//114
void StrReplaceExpression() #StrReplaceFuncNode :{}{  "REPLACE" "(" Expression() "," Expression() "," Expression()  (    "," Expression()  )?  ")"}//115
void ExistsFunc() #Exists :{}{  "EXISTS" GroupGraphPattern()}//116
void NotExistsFunc() #NotExists :{}{  "NOT" "EXISTS" GroupGraphPattern()}//117
void Aggregate() #Aggregation :{}{  (    "COUNT" {      jjtThis.setTYPE(ASTAggregation.TYPE.COUNT);    }    "(" ("DISTINCT"    {      jjtThis.setDistinct();    }    )?    (      "*"    | Expression()    )    ")"  )|  (    "SUM" {      jjtThis.setTYPE(ASTAggregation.TYPE.SUM);    }    "(" ("DISTINCT"{      jjtThis.setDistinct();    })? Expression() ")"  )|  (    "MIN" {      jjtThis.setTYPE(ASTAggregation.TYPE.MIN);    }    "(" ("DISTINCT"{      jjtThis.setDistinct();    })? Expression() ")"  )|  (    "MAX" {      jjtThis.setTYPE(ASTAggregation.TYPE.MAX);    }    "(" ("DISTINCT"{      jjtThis.setDistinct();    })? Expression() ")"  )|  (    "AVG" {      jjtThis.setTYPE(ASTAggregation.TYPE.AVG);    }    "(" ("DISTINCT"{      jjtThis.setDistinct();    })? Expression() ")"  )|  (    "SAMPLE" {      jjtThis.setTYPE(ASTAggregation.TYPE.SAMPLE);    }    "(" ("DISTINCT"{      jjtThis.setDistinct();    })? Expression() ")"  )|  (    "GROUP_CONCAT" {      jjtThis.setTYPE(ASTAggregation.TYPE.GROUP_CONCAT);    }    "(" ("DISTINCT"{      jjtThis.setDistinct();    })? Expression()    (      ";" "SEPARATOR" "=" String()    )?    ")"  )}//118
void IRIrefOrFunction() :{}{  LOOKAHEAD((<IRI_REF>|<PNAME_LN>|<PNAME_NS>)"(")  FunctionCall()  | IRIref()  }//119
//void RDFLiteral() #RDFLiteral ://{}//{//  String()//  (//    < LANGTAG >//  |//    (//      "^^" IRIref()//    )//  )?//}void RDFLiteral() #RDFLiteral :												//NOW IS AST NODE{}{		LOOKAHEAD((<STRING_LITERAL1>|<STRING_LITERAL2>|<STRING_LITERAL_LONG1>|<STRING_LITERAL_LONG2>)"^^") TypedLiteral() |	LOOKAHEAD((<STRING_LITERAL1>|<STRING_LITERAL2>|<STRING_LITERAL_LONG1>|<STRING_LITERAL_LONG2>)<LANGTAG>) LiteralWithLangTag() | 	String()			//CHANGED JK}void TypedLiteral() #DoubleCircumflex:{}{	String() "^^" IRIref()}void LiteralWithLangTag() #LangTag:{}{	String() < LANGTAG > { jjtThis.setLangTag(token.image); }}//120
void NumericLiteral() :{}{  NumericLiteralUnsigned()| NumericLiteralPositive()| NumericLiteralNegative()}//121
void NumericLiteralUnsigned() :{}{  NumericLiteralUnsignedInteger()| NumericLiteralUnsignedFloatingPoint()}void NumericLiteralUnsignedInteger() #Integer :{}{	< INTEGER > { jjtThis.setValue((token.image)); }}void NumericLiteralUnsignedFloatingPoint() #FloatingPoint :{}{	< DECIMAL > { jjtThis.setValue((token.image)); }| 	< DOUBLE > { jjtThis.setValue((token.image)); }}//122
void NumericLiteralPositive() :{}{  "+"  ( NumericLiteralPositiveInteger() | NumericLiteralPositiveFloatingPoint())}void NumericLiteralPositiveInteger() #Integer :{}{	< INTEGER > { jjtThis.setValue("+"+(token.image)); }}void NumericLiteralPositiveFloatingPoint() #FloatingPoint :{}{	(< DECIMAL > { jjtThis.setValue("+"+(token.image)); })| 	(< DOUBLE > { jjtThis.setValue("+"+(token.image)); })}//123
void NumericLiteralNegative() :{}{  "-"  (NumericLiteralNegativeInteger() | NumericLiteralNegativeFloatingPoint())}void NumericLiteralNegativeInteger() #Integer :{}{	< INTEGER > { jjtThis.setValue("-"+(token.image)); }}void NumericLiteralNegativeFloatingPoint() #FloatingPoint :{}{	(< DECIMAL > { jjtThis.setValue("-"+(token.image)); })| 	(< DOUBLE > { jjtThis.setValue("-"+(token.image)); })}//124
void BooleanLiteral() #BooleanLiteral :{}{  ( "true" { jjtThis.setState(true); })| ( "false" { jjtThis.setState(false); })}//125
void String() #StringLiteral :{  Token t;}{  t = < STRING_LITERAL1 >  {    jjtThis.setStringLiteral(t.image);  }| t = < STRING_LITERAL2 >  {    jjtThis.setStringLiteral(t.image);  }| t = < STRING_LITERAL_LONG1 >  {    jjtThis.setStringLiteral(t.image);  }| t = < STRING_LITERAL_LONG2 >  {    jjtThis.setStringLiteral(t.image);  }}//126
void IRIref() :{}{  QuotedIriRef()| PrefixedName()}void QuotedIriRef() #QuotedURIRef :{  Token qRef;}{  qRef = < IRI_REF >  { jjtThis.setQRef(qRef.image.substring(1, qRef.image.length() - 1)); }}//127
void PrefixedName() #QName :{  Token qName;}{  (    qName = < PNAME_LN >	| qName = < PNAME_NS >  )  {   String prefix = qName.image.substring(0, qName.image.indexOf(':'));	    if(!declaredPrefixes.contains(prefix)){	        ParseException pe = new ParseException("Undefined prefix "+prefix+" used in line " + qName.beginLine + " , column " + qName.beginColumn);	        pe.currentToken = qName;	    	throw pe;	    }	    jjtThis.setNameSpace(prefix);		jjtThis.setLocalName(qName.image.substring(qName.image.indexOf(':') + 1)); }}//128
void BlankNode() :{  Token t;}{  t = < BLANK_NODE_LABEL > { jjtThis.setIdentifier((t.image)); } #BlankNode| (< ANON > #EmptyNode)}void URI() :{}{  IRIref()}void VarOrURI() :{}{  Var()| URI()}void VarOrBlankNodeOrIRIref() :{}{  Var()| BlankNode()| URI()}void QuotedURIref() #QuotedURIRef :{  Token qRef;}{  qRef = < IRI_REF >  {    jjtThis.setQRef(qRef.image.substring(1, qRef.image.length() - 1));  }}