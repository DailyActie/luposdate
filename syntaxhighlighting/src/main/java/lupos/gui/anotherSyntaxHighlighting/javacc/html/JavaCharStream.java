/**
 * Copyright (c) 2007-2015, Institute of Information Systems (Sven Groppe and contributors of LUPOSDATE), University of Luebeck
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
 * following conditions are met:
 *
 * 	- Redistributions of source code must retain the above copyright notice, this list of conditions and the following
 * 	  disclaimer.
 * 	- Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 * 	  following disclaimer in the documentation and/or other materials provided with the distribution.
 * 	- Neither the name of the University of Luebeck nor the names of its contributors may be used to endorse or promote
 * 	  products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/* Generated By:JavaCC: Do not edit this line. JavaCharStream.java Version 5.0 */
/* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package lupos.gui.anotherSyntaxHighlighting.javacc.html;

/**
 * An implementation of interface CharStream, where the stream is assumed to
 * contain only ASCII characters (with java-like unicode escape processing).
 *
 * @author groppe
 * @version $Id: $Id
 */
public
class JavaCharStream
{
  /** Whether parser is static. */
  public static final boolean staticFlag = false;

  static final int hexval(final char c) throws java.io.IOException {
    switch(c)
    {
       case '0' :
          return 0;
       case '1' :
          return 1;
       case '2' :
          return 2;
       case '3' :
          return 3;
       case '4' :
          return 4;
       case '5' :
          return 5;
       case '6' :
          return 6;
       case '7' :
          return 7;
       case '8' :
          return 8;
       case '9' :
          return 9;

       case 'a' :
       case 'A' :
          return 10;
       case 'b' :
       case 'B' :
          return 11;
       case 'c' :
       case 'C' :
          return 12;
       case 'd' :
       case 'D' :
          return 13;
       case 'e' :
       case 'E' :
          return 14;
       case 'f' :
       case 'F' :
          return 15;
    }

    throw new java.io.IOException(); // Should never come here
  }

/** Position in buffer. */
  public int bufpos = -1;
  int bufsize;
  int available;
  int tokenBegin;
  protected int bufline[];
  protected int bufcolumn[];

  protected int column = 0;
  protected int line = 1;

  protected boolean prevCharIsCR = false;
  protected boolean prevCharIsLF = false;

  protected java.io.Reader inputStream;

  protected char[] nextCharBuf;
  protected char[] buffer;
  protected int maxNextCharInd = 0;
  protected int nextCharInd = -1;
  protected int inBuf = 0;
  protected int tabSize = 8;

  /**
   * <p>Setter for the field <code>tabSize</code>.</p>
   *
   * @param i a int.
   */
  protected void setTabSize(final int i) { this.tabSize = i; }
  /**
   * <p>Getter for the field <code>tabSize</code>.</p>
   *
   * @param i a int.
   * @return a int.
   */
  protected int getTabSize(final int i) { return this.tabSize; }

  /**
   * <p>ExpandBuff.</p>
   *
   * @param wrapAround a boolean.
   */
  protected void ExpandBuff(final boolean wrapAround)
  {
    final char[] newbuffer = new char[this.bufsize + 2048];
    final int newbufline[] = new int[this.bufsize + 2048];
    final int newbufcolumn[] = new int[this.bufsize + 2048];

    try
    {
      if (wrapAround)
      {
        System.arraycopy(this.buffer, this.tokenBegin, newbuffer, 0, this.bufsize - this.tokenBegin);
        System.arraycopy(this.buffer, 0, newbuffer, this.bufsize - this.tokenBegin, this.bufpos);
        this.buffer = newbuffer;

        System.arraycopy(this.bufline, this.tokenBegin, newbufline, 0, this.bufsize - this.tokenBegin);
        System.arraycopy(this.bufline, 0, newbufline, this.bufsize - this.tokenBegin, this.bufpos);
        this.bufline = newbufline;

        System.arraycopy(this.bufcolumn, this.tokenBegin, newbufcolumn, 0, this.bufsize - this.tokenBegin);
        System.arraycopy(this.bufcolumn, 0, newbufcolumn, this.bufsize - this.tokenBegin, this.bufpos);
        this.bufcolumn = newbufcolumn;

        this.bufpos += (this.bufsize - this.tokenBegin);
    }
    else
    {
        System.arraycopy(this.buffer, this.tokenBegin, newbuffer, 0, this.bufsize - this.tokenBegin);
        this.buffer = newbuffer;

        System.arraycopy(this.bufline, this.tokenBegin, newbufline, 0, this.bufsize - this.tokenBegin);
        this.bufline = newbufline;

        System.arraycopy(this.bufcolumn, this.tokenBegin, newbufcolumn, 0, this.bufsize - this.tokenBegin);
        this.bufcolumn = newbufcolumn;

        this.bufpos -= this.tokenBegin;
      }
    }
    catch (final Throwable t)
    {
      throw new Error(t.getMessage());
    }

    this.available = (this.bufsize += 2048);
    this.tokenBegin = 0;
  }

  /**
   * <p>FillBuff.</p>
   *
   * @throws java.io.IOException if any.
   */
  protected void FillBuff() throws java.io.IOException
  {
    int i;
    if (this.maxNextCharInd == 4096) {
		this.maxNextCharInd = this.nextCharInd = 0;
	}

    try {
      if ((i = this.inputStream.read(this.nextCharBuf, this.maxNextCharInd,
                                          4096 - this.maxNextCharInd)) == -1)
      {
        this.inputStream.close();
        throw new java.io.IOException();
      } else {
		this.maxNextCharInd += i;
	}
      return;
    }
    catch(final java.io.IOException e) {
      if (this.bufpos != 0)
      {
        --this.bufpos;
        this.backup(0);
      }
      else
      {
        this.bufline[this.bufpos] = this.line;
        this.bufcolumn[this.bufpos] = this.column;
      }
      throw e;
    }
  }

  /**
   * <p>ReadByte.</p>
   *
   * @return a char.
   * @throws java.io.IOException if any.
   */
  protected char ReadByte() throws java.io.IOException
  {
    if (++this.nextCharInd >= this.maxNextCharInd) {
		this.FillBuff();
	}

    return this.nextCharBuf[this.nextCharInd];
  }

  /**
   * <p>BeginToken.</p>
   *
   * @return a char.
   * @throws java.io.IOException if any.
   */
  public char BeginToken() throws java.io.IOException
  {
    if (this.inBuf > 0)
    {
      --this.inBuf;

      if (++this.bufpos == this.bufsize) {
		this.bufpos = 0;
	}

      this.tokenBegin = this.bufpos;
      return this.buffer[this.bufpos];
    }

    this.tokenBegin = 0;
    this.bufpos = -1;

    return this.readChar();
  }

  /**
   * <p>AdjustBuffSize.</p>
   */
  protected void AdjustBuffSize()
  {
    if (this.available == this.bufsize)
    {
      if (this.tokenBegin > 2048)
      {
        this.bufpos = 0;
        this.available = this.tokenBegin;
      } else {
		this.ExpandBuff(false);
	}
    }
    else if (this.available > this.tokenBegin) {
		this.available = this.bufsize;
	} else if ((this.tokenBegin - this.available) < 2048) {
		this.ExpandBuff(true);
	} else {
		this.available = this.tokenBegin;
	}
  }

  /**
   * <p>UpdateLineColumn.</p>
   *
   * @param c a char.
   */
  protected void UpdateLineColumn(final char c)
  {
    this.column++;

    if (this.prevCharIsLF)
    {
      this.prevCharIsLF = false;
      this.line += (this.column = 1);
    }
    else if (this.prevCharIsCR)
    {
      this.prevCharIsCR = false;
      if (c == '\n')
      {
        this.prevCharIsLF = true;
      } else {
		this.line += (this.column = 1);
	}
    }

    switch (c)
    {
      case '\r' :
        this.prevCharIsCR = true;
        break;
      case '\n' :
        this.prevCharIsLF = true;
        break;
      case '\t' :
        this.column--;
        this.column += (this.tabSize - (this.column % this.tabSize));
        break;
      default :
        break;
    }

    this.bufline[this.bufpos] = this.line;
    this.bufcolumn[this.bufpos] = this.column;
  }

  /**
   * Read a character.
   *
   * @return a char.
   * @throws java.io.IOException if any.
   */
  public char readChar() throws java.io.IOException
  {
    if (this.inBuf > 0)
    {
      --this.inBuf;

      if (++this.bufpos == this.bufsize) {
		this.bufpos = 0;
	}

      return this.buffer[this.bufpos];
    }

    char c;

    if (++this.bufpos == this.available) {
		this.AdjustBuffSize();
	}

    if ((this.buffer[this.bufpos] = c = this.ReadByte()) == '\\')
    {
      this.UpdateLineColumn(c);

      int backSlashCnt = 1;

      for (;;) // Read all the backslashes
      {
        if (++this.bufpos == this.available) {
			this.AdjustBuffSize();
		}

        try
        {
          if ((this.buffer[this.bufpos] = c = this.ReadByte()) != '\\')
          {
            this.UpdateLineColumn(c);
            // found a non-backslash char.
            if ((c == 'u') && ((backSlashCnt & 1) == 1))
            {
              if (--this.bufpos < 0) {
				this.bufpos = this.bufsize - 1;
			}

              break;
            }

            this.backup(backSlashCnt);
            return '\\';
          }
        }
        catch(final java.io.IOException e)
        {
	  // We are returning one backslash so we should only backup (count-1)
          if (backSlashCnt > 1) {
			this.backup(backSlashCnt-1);
		}

          return '\\';
        }

        this.UpdateLineColumn(c);
        backSlashCnt++;
      }

      // Here, we have seen an odd number of backslash's followed by a 'u'
      try
      {
        while ((c = this.ReadByte()) == 'u') {
			++this.column;
		}

        this.buffer[this.bufpos] = c = (char)(hexval(c) << 12 |
                                    hexval(this.ReadByte()) << 8 |
                                    hexval(this.ReadByte()) << 4 |
                                    hexval(this.ReadByte()));

        this.column += 4;
      }
      catch(final java.io.IOException e)
      {
        throw new Error("Invalid escape character at line " + this.line +
                                         " column " + this.column + ".");
      }

      if (backSlashCnt == 1) {
		return c;
	} else
      {
        this.backup(backSlashCnt - 1);
        return '\\';
      }
    }
    else
    {
      this.UpdateLineColumn(c);
      return c;
    }
  }

  @Deprecated
   /**
    * <p>Getter for the field <code>column</code>.</p>
    *
    * @return a int.
    */
  public int getColumn() {
    return this.bufcolumn[this.bufpos];
  }

  @Deprecated
   /**
    * <p>Getter for the field <code>line</code>.</p>
    *
    * @return a int.
    */
  public int getLine() {
    return this.bufline[this.bufpos];
  }

  /**
   * Get end column.
   *
   * @return a int.
   */
  public int getEndColumn() {
    return this.bufcolumn[this.bufpos];
  }

  /**
   * Get end line.
   *
   * @return a int.
   */
  public int getEndLine() {
    return this.bufline[this.bufpos];
  }

  /**
   * <p>getBeginColumn.</p>
   *
   * @return a int.
   */
  public int getBeginColumn() {
    return this.bufcolumn[this.tokenBegin];
  }

  /**
   * <p>getBeginLine.</p>
   *
   * @return a int.
   */
  public int getBeginLine() {
    return this.bufline[this.tokenBegin];
  }

  /**
   * Retreat.
   *
   * @param amount a int.
   */
  public void backup(final int amount) {

    this.inBuf += amount;
    if ((this.bufpos -= amount) < 0) {
		this.bufpos += this.bufsize;
	}
  }

  /**
   * Constructor.
   *
   * @param dstream a {@link java.io.Reader} object.
   * @param startline a int.
   * @param startcolumn a int.
   * @param buffersize a int.
   */
  public JavaCharStream(final java.io.Reader dstream,
                 final int startline, final int startcolumn, final int buffersize)
  {
    this.inputStream = dstream;
    this.line = startline;
    this.column = startcolumn - 1;

    this.available = this.bufsize = buffersize;
    this.buffer = new char[buffersize];
    this.bufline = new int[buffersize];
    this.bufcolumn = new int[buffersize];
    this.nextCharBuf = new char[4096];
  }

  /**
   * Constructor.
   *
   * @param dstream a {@link java.io.Reader} object.
   * @param startline a int.
   * @param startcolumn a int.
   */
  public JavaCharStream(final java.io.Reader dstream,
                                        final int startline, final int startcolumn)
  {
    this(dstream, startline, startcolumn, 4096);
  }

  /**
   * Constructor.
   *
   * @param dstream a {@link java.io.Reader} object.
   */
  public JavaCharStream(final java.io.Reader dstream)
  {
    this(dstream, 1, 1, 4096);
  }
  /**
   * Reinitialise.
   *
   * @param dstream a {@link java.io.Reader} object.
   * @param startline a int.
   * @param startcolumn a int.
   * @param buffersize a int.
   */
  public void ReInit(final java.io.Reader dstream,
                 final int startline, final int startcolumn, final int buffersize)
  {
    this.inputStream = dstream;
    this.line = startline;
    this.column = startcolumn - 1;

    if (this.buffer == null || buffersize != this.buffer.length)
    {
      this.available = this.bufsize = buffersize;
      this.buffer = new char[buffersize];
      this.bufline = new int[buffersize];
      this.bufcolumn = new int[buffersize];
      this.nextCharBuf = new char[4096];
    }
    this.prevCharIsLF = this.prevCharIsCR = false;
    this.tokenBegin = this.inBuf = this.maxNextCharInd = 0;
    this.nextCharInd = this.bufpos = -1;
  }

  /**
   * Reinitialise.
   *
   * @param dstream a {@link java.io.Reader} object.
   * @param startline a int.
   * @param startcolumn a int.
   */
  public void ReInit(final java.io.Reader dstream,
                                        final int startline, final int startcolumn)
  {
    this.ReInit(dstream, startline, startcolumn, 4096);
  }

  /**
   * Reinitialise.
   *
   * @param dstream a {@link java.io.Reader} object.
   */
  public void ReInit(final java.io.Reader dstream)
  {
    this.ReInit(dstream, 1, 1, 4096);
  }
  /**
   * Constructor.
   *
   * @param dstream a {@link java.io.InputStream} object.
   * @param encoding a {@link java.lang.String} object.
   * @param startline a int.
   * @param startcolumn a int.
   * @param buffersize a int.
   * @throws java.io.UnsupportedEncodingException if any.
   */
  public JavaCharStream(final java.io.InputStream dstream, final String encoding, final int startline,
  final int startcolumn, final int buffersize) throws java.io.UnsupportedEncodingException
  {
    this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
  }

  /**
   * Constructor.
   *
   * @param dstream a {@link java.io.InputStream} object.
   * @param startline a int.
   * @param startcolumn a int.
   * @param buffersize a int.
   */
  public JavaCharStream(final java.io.InputStream dstream, final int startline,
  final int startcolumn, final int buffersize)
  {
    this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
  }

  /**
   * Constructor.
   *
   * @param dstream a {@link java.io.InputStream} object.
   * @param encoding a {@link java.lang.String} object.
   * @param startline a int.
   * @param startcolumn a int.
   * @throws java.io.UnsupportedEncodingException if any.
   */
  public JavaCharStream(final java.io.InputStream dstream, final String encoding, final int startline,
                        final int startcolumn) throws java.io.UnsupportedEncodingException
  {
    this(dstream, encoding, startline, startcolumn, 4096);
  }

  /**
   * Constructor.
   *
   * @param dstream a {@link java.io.InputStream} object.
   * @param startline a int.
   * @param startcolumn a int.
   */
  public JavaCharStream(final java.io.InputStream dstream, final int startline,
                        final int startcolumn)
  {
    this(dstream, startline, startcolumn, 4096);
  }

  /**
   * Constructor.
   *
   * @param dstream a {@link java.io.InputStream} object.
   * @param encoding a {@link java.lang.String} object.
   * @throws java.io.UnsupportedEncodingException if any.
   */
  public JavaCharStream(final java.io.InputStream dstream, final String encoding) throws java.io.UnsupportedEncodingException
  {
    this(dstream, encoding, 1, 1, 4096);
  }

  /**
   * Constructor.
   *
   * @param dstream a {@link java.io.InputStream} object.
   */
  public JavaCharStream(final java.io.InputStream dstream)
  {
    this(dstream, 1, 1, 4096);
  }

  /**
   * Reinitialise.
   *
   * @param dstream a {@link java.io.InputStream} object.
   * @param encoding a {@link java.lang.String} object.
   * @param startline a int.
   * @param startcolumn a int.
   * @param buffersize a int.
   * @throws java.io.UnsupportedEncodingException if any.
   */
  public void ReInit(final java.io.InputStream dstream, final String encoding, final int startline,
  final int startcolumn, final int buffersize) throws java.io.UnsupportedEncodingException
  {
    this.ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
  }

  /**
   * Reinitialise.
   *
   * @param dstream a {@link java.io.InputStream} object.
   * @param startline a int.
   * @param startcolumn a int.
   * @param buffersize a int.
   */
  public void ReInit(final java.io.InputStream dstream, final int startline,
  final int startcolumn, final int buffersize)
  {
    this.ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
  }
  /**
   * Reinitialise.
   *
   * @param dstream a {@link java.io.InputStream} object.
   * @param encoding a {@link java.lang.String} object.
   * @param startline a int.
   * @param startcolumn a int.
   * @throws java.io.UnsupportedEncodingException if any.
   */
  public void ReInit(final java.io.InputStream dstream, final String encoding, final int startline,
                     final int startcolumn) throws java.io.UnsupportedEncodingException
  {
    this.ReInit(dstream, encoding, startline, startcolumn, 4096);
  }
  /**
   * Reinitialise.
   *
   * @param dstream a {@link java.io.InputStream} object.
   * @param startline a int.
   * @param startcolumn a int.
   */
  public void ReInit(final java.io.InputStream dstream, final int startline,
                     final int startcolumn)
  {
    this.ReInit(dstream, startline, startcolumn, 4096);
  }
  /**
   * Reinitialise.
   *
   * @param dstream a {@link java.io.InputStream} object.
   * @param encoding a {@link java.lang.String} object.
   * @throws java.io.UnsupportedEncodingException if any.
   */
  public void ReInit(final java.io.InputStream dstream, final String encoding) throws java.io.UnsupportedEncodingException
  {
    this.ReInit(dstream, encoding, 1, 1, 4096);
  }

  /**
   * Reinitialise.
   *
   * @param dstream a {@link java.io.InputStream} object.
   */
  public void ReInit(final java.io.InputStream dstream)
  {
    this.ReInit(dstream, 1, 1, 4096);
  }

  /**
   * <p>GetImage.</p>
   *
   * @return a {@link java.lang.String} object.
   */
  public String GetImage()
  {
    if (this.bufpos >= this.tokenBegin) {
		return new String(this.buffer, this.tokenBegin, this.bufpos - this.tokenBegin + 1);
	} else {
		return new String(this.buffer, this.tokenBegin, this.bufsize - this.tokenBegin) +
		                          new String(this.buffer, 0, this.bufpos + 1);
	}
  }

  /**
   * <p>GetSuffix.</p>
   *
   * @param len a int.
   * @return an array of char.
   */
  public char[] GetSuffix(final int len)
  {
    final char[] ret = new char[len];

    if ((this.bufpos + 1) >= len) {
		System.arraycopy(this.buffer, this.bufpos - len + 1, ret, 0, len);
	} else
    {
      System.arraycopy(this.buffer, this.bufsize - (len - this.bufpos - 1), ret, 0,
                                                        len - this.bufpos - 1);
      System.arraycopy(this.buffer, 0, ret, len - this.bufpos - 1, this.bufpos + 1);
    }

    return ret;
  }

  /**
   * Set buffers back to null when finished.
   */
  public void Done()
  {
    this.nextCharBuf = null;
    this.buffer = null;
    this.bufline = null;
    this.bufcolumn = null;
  }

  /**
   * Method to adjust line and column numbers for the start of a token.
   *
   * @param newLine a int.
   * @param newCol a int.
   */
  public void adjustBeginLineColumn(int newLine, final int newCol)
  {
    int start = this.tokenBegin;
    int len;

    if (this.bufpos >= this.tokenBegin)
    {
      len = this.bufpos - this.tokenBegin + this.inBuf + 1;
    }
    else
    {
      len = this.bufsize - this.tokenBegin + this.bufpos + 1 + this.inBuf;
    }

    int i = 0, j = 0, k = 0;
    int nextColDiff = 0, columnDiff = 0;

    while (i < len && this.bufline[j = start % this.bufsize] == this.bufline[k = ++start % this.bufsize])
    {
      this.bufline[j] = newLine;
      nextColDiff = columnDiff + this.bufcolumn[k] - this.bufcolumn[j];
      this.bufcolumn[j] = newCol + columnDiff;
      columnDiff = nextColDiff;
      i++;
    }

    if (i < len)
    {
      this.bufline[j] = newLine++;
      this.bufcolumn[j] = newCol + columnDiff;

      while (i++ < len)
      {
        if (this.bufline[j = start % this.bufsize] != this.bufline[++start % this.bufsize]) {
			this.bufline[j] = newLine++;
		} else {
			this.bufline[j] = newLine;
		}
      }
    }

    this.line = this.bufline[j];
    this.column = this.bufcolumn[j];
  }

}
/* JavaCC - OriginalChecksum=47b6fea931f87953ea6124a1bb8db264 (do not edit this line) */
