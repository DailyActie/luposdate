<?xml version="1.0" encoding="UTF-8"?>
<!--

    Copyright (c) 2013, Institute of Information Systems (Sven Groppe and contributors of LUPOSDATE), University of Luebeck

    All rights reserved.

    Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
    following conditions are met:

    	- Redistributions of source code must retain the above copyright notice, this list of conditions and the following
    	  disclaimer.
    	- Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
    	  following disclaimer in the documentation and/or other materials provided with the distribution.
    	- Neither the name of the University of Luebeck nor the names of its contributors may be used to endorse or promote
    	  products derived from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
    INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
    OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

-->
<templaterule-document>


<base> http://www.example.de# </base>
<prefix name="rdf">http://www.w3.org/1999/02/22-rdf-syntax-ns#</prefix>
<prefix name="rdfs">http://www.w3.org/2000/01/rdf-schema#</prefix>
<prefix name="owl">http://www.w3.org/2002/07/owl#</prefix>
<prefix name="xsd">http://www.w3.org/2001/XMLSchema#</prefix>
<prefix name="rif">http://www.w3.org/2007/rif#</prefix>
<prefix name="func">http://www.w3.org/2007/rif-builtin-function#</prefix>
<prefix name="pred">http://www.w3.org/2007/rif-builtin-predicate#</prefix>
<prefix name="dc">http://purl.org/dc/terms/</prefix>
<prefix name="eg">http://www.example.me/</prefix>
<prefix name="xs">http://xs/</prefix>
<prefix name="rulenames">local.rulenames#</prefix>


<templaterule>
<name>#prp-ifp</name>
<pattern>(?p rdf:type owl:InverseFunctionalProperty)
</pattern>	
<rifquery type="rdftype"><![CDATA[owl:InverseFunctionalProperty
 ]]></rifquery>
<template>
<![CDATA[ Forall ?x1 ?x2 ?y (?x1[owl:sameAs->?x2]:-And(?x1[?p->?y]?x2[?p->?y]))
]]></template>	
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?p</variable>
</templaterule>






<templaterule>
<name>#prp-fp</name>
<pattern>(?p rdf:type owl:FunctionalProperty)
</pattern>	
<rifquery type="rdftype"><![CDATA[owl:FunctionalProperty
 ]]></rifquery>
<template>
<![CDATA[ Forall ?y2 ?x ?y1 (?y1[owl:sameAs->?y2]:-And(?x[?p->?y1]?x[?p->?y2]))
]]></template>	
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?p</variable>
</templaterule>

<templaterule>
<name>#prp-irp</name>
<pattern>(?p rdf:type owl:IrreflexiveProperty)
</pattern>	
<rifquery type="rdftype"><![CDATA[owl:IrreflexiveProperty
 ]]></rifquery>
<template>
<![CDATA[ Forall ?x(rif:error() :- And(?x[?p->?x] ))
]]></template>	
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?p</variable>
</templaterule>




<templaterule>
<name>#prp-symp</name>
<pattern>(?p rdf:type owl:SymmetricProperty)
</pattern>	
<rifquery type="rdftype"><![CDATA[owl:SymmetricProperty
 ]]></rifquery> 
<template><![CDATA[
 Forall ?x ?y (?y[?p->?x] :- And(?x[?p->?y]))
 ]]></template>	
 <methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?p</variable>
</templaterule>

<templaterule> 
<name>#prp-asyp</name>
<pattern>(?p rdf:type owl:AsymmetricProperty)
</pattern>	
<rifquery type="rdftype"><![CDATA[owl:AsymmetricProperty
 ]]></rifquery>
<template><![CDATA[
 Forall ?x ?y (rif:error("Reason: ?Arg.2[?p->?Arg.3]?Arg.2[?p->?Arg.3] " ?x ?y) :- And(?x[?p->?y]?y[?p->?x]))
 ]]></template>	
 <methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?p</variable>
</templaterule>



<templaterule> 
<name>#prp-trp</name>
<pattern>(?p rdf:type owl:TransitiveProperty)
</pattern>	
<rifquery type="rdftype"><![CDATA[owl:TransitiveProperty 
 ]]></rifquery><template><![CDATA[
 Forall ?x ?z ?y(?x[?p->?z]:-And(?x[?p->?y]?y[?p->?z]))
 ]]></template>	
 <methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?p</variable>
</templaterule>

<templaterule> 
<name>#prp-spo1</name>
<pattern>(?p1 rdfs:subPropertyOf ?p2)
</pattern>	
<rifquery type="p1-prp-p2"><![CDATA[rdfs:subPropertyOf 
 ]]></rifquery>
<template><![CDATA[
 Forall ?x ?y(?x[?p2->?y]:-And(?x[?p1->?y]))
 ]]></template>	
 <methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?p1</variable>
<variable>?p2</variable>
</templaterule>

<templaterule> 
<name>#prp-eqp1</name>
<pattern>(?p1 owl:equivalentProperty ?p2)
</pattern>	
<rifquery type="p1-prp-p2"><![CDATA[owl:equivalentProperty  
 ]]></rifquery>
<template><![CDATA[
 Forall ?x ?y(?x[?p2->?y]:-And(?x[?p1->?y]))
 ]]></template>	
 <methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?p1</variable>
<variable>?p2</variable>
</templaterule>

<templaterule> 
<name>#prp-eqp2</name>
<pattern>(?p1 owl:equivalentProperty ?p2)
</pattern>	
<rifquery type="p1-prp-p2"><![CDATA[owl:equivalentProperty 
 ]]></rifquery>
<template><![CDATA[
 Forall ?x ?y(?x[?p1->?y]:-And(?x[?p2->?y]))
 ]]></template>	
 <methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?p1</variable>
<variable>?p2</variable>
</templaterule>




<templaterule> 
<name>#prp-pdw</name>
<pattern>(?p1 owl:propertyDisjointWith ?p2)
</pattern>	
<rifquery type="p1-prp-p2"><![CDATA[owl:propertyDisjointWith 
 ]]></rifquery>
<template><![CDATA[
 Forall ?x ?y(rif:error("Reason: Arg.2[?p1->Arg.3]?Arg.2[?p2->Arg.3] " ?x ?y):-And(?x[?p1->?y]?x[?p2->?y]))
 ]]></template>	
 <methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?p1</variable>
<variable>?p2</variable>
</templaterule>


<templaterule> 
<name>#prp-inv1</name>
<pattern>(?p1 owl:inverseOf ?p2)
</pattern>	
<rifquery type="p1-prp-p2"><![CDATA[owl:inverseOf 
 ]]></rifquery>
<template><![CDATA[
 Forall ?x ?y(?y[?p2->?x]:-And(?x[?p1->?y]))
 ]]></template>	
 <methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?p1</variable>
<variable>?p2</variable>
</templaterule>

<templaterule> 
<name>#prp-inv2</name>
<pattern>(?p1 owl:inverseOf ?p2)
</pattern>	
<rifquery type="p1-prp-p2"><![CDATA[owl:inverseOf
 ]]></rifquery>
<template><![CDATA[
 Forall ?x ?y(?y[?p1->?x]:-And(?x[?p2->?y]))
 ]]></template>	
 <methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?p1</variable>
<variable>?p2</variable>
</templaterule>

<templaterule> 
<name>#cls-svf1</name>
<pattern>(?x owl:someValuesFrom ?y) (?x owl:onProperty ?p)
</pattern>	
<rifquery type="xml"><![CDATA[:property[:prop->?x]:-And(?x[owl:someValuesFrom->?y]?x[owl:onProperty->?p])]]></rifquery>
<template><![CDATA[
Forall ?v ?u ( ?u[rdf:type->?x] :- And(?u[?p->?v]?v[rdf:type->?y] ))
]]></template>	
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?x</variable>
<variable>?y</variable>
<variable>?p</variable>
</templaterule>

<templaterule> 
<name>#cls-svf2</name>
<pattern>(?x owl:someValuesFrom :owl:Thing) (?x owl:onProperty ?p)
</pattern>	
<rifquery type="xml"><![CDATA[:property[:prop->?x]:-And(?x[owl:someValuesFrom->owl:Thing]?x[owl:onProperty->?p])]]></rifquery>
<template><![CDATA[
Forall ?v ?u ( ?u[rdf:type->?x] :- And(?u[?p->?v]))
]]></template>	
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?x</variable>
<variable>?p</variable>
</templaterule>

<templaterule> 
<name>#cls-avf</name>
<pattern>(?x owl:allValuesFrom ?y) (?x owl:onProperty ?p)
</pattern>	
<rifquery type="xml"><![CDATA[:property[:prop->?x]:-And(?x[owl:allValuesFrom->?y]?x[owl:onProperty->?p])]]></rifquery>
<template><![CDATA[
Forall ?v ?u ( ?v[rdf:type->?y] :- And(?u[rdf:type->?x] ?u[?p->?v]  ))
]]></template>	
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?x</variable>
<variable>?p</variable>
<variable>?y</variable>
</templaterule>

<templaterule> 
<name>#cls-hv1</name>
<pattern>(?x owl:hasValue ?y) (?x owl:onProperty ?p)
</pattern>	
<rifquery type="xml"><![CDATA[:property[:prop->?x]:-And(?x[owl:hasValue->?y]?x[owl:onProperty->?p])]]></rifquery>
<template><![CDATA[
Forall ?u ( ?u[?p->?y] :- And( ?u[rdf:type->?x]  ))
]]></template>	
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?x</variable>
<variable>?y</variable>
<variable>?p</variable>
</templaterule>

<templaterule> 
<name>#cls-hv2</name>
<pattern>(?x owl:hasValue ?y) (?x owl:onProperty ?p)
</pattern>	
<rifquery type="xml"><![CDATA[:property[:prop->?x]:-And(?x[owl:hasValue->?y]?x[owl:onProperty->?p])]]></rifquery>
<template><![CDATA[
Forall ?u ( ?u[rdf:type->?x] :- And(?u[?p->?y]  ))
]]></template>	
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?x</variable>
<variable>?y</variable>
<variable>?p</variable>
</templaterule>

<templaterule> 
<name>#cls-maxc1</name>
<pattern>(?x owl:maxCardinality 0) (?x owl:onProperty ?p)
</pattern>	
<rifquery type="xml"><![CDATA[:property[:prop->?x]:-And(?x[owl:maxCardinality->0]?x[owl:onProperty->?p])]]></rifquery>
<template><![CDATA[
Forall ?u ?y ( rif:error("Reason: Arg.2[?p->Arg.3]?Arg.2[rdf:type->?x] " ?u ?y) :- And(?u[?p->?y] ?u[rdf:type->?x]  ))
]]></template>	
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?x</variable>
<variable>?p</variable>
</templaterule>

<templaterule> 
<name>#cls-maxc2</name>
<pattern>(?x owl:maxCardinality 1) (?x owl:onProperty ?p)
</pattern>	
<rifquery type="xml"><![CDATA[:property[:prop->?x]:-And(?x[owl:maxCardinality->1]?x[owl:onProperty->?p])]]></rifquery>
<template><![CDATA[
Forall ?y2 ?u ?y1 (?y1[owl:sameAs->?y2] :- And( ?u[?p->?y1]?u[?p->?y2]?u[rdf:type->?x]  ))
]]></template>	
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?x</variable>
<variable>?p</variable>
</templaterule>


<templaterule> 
<name>#cls-maxqc1</name>
<pattern>(?x owl:maxQualifiedCardinality 0) (?x owl:onProperty ?p) (?x owl:onClass ?c)
</pattern>	
<rifquery type="xml"><![CDATA[:property[:prop->?x]:-And(?x[owl:maxQualifiedCardinality->0]?x[owl:onProperty->?p]?x[owl:onClass->?c])]]></rifquery>
<template><![CDATA[
Forall ?u ?y (rif:error("Reason: Arg.2[rdf:type->?x]Arg.2[?p->Arg.3]Arg.3[rdf:type->?c] " ?u ?y) :- And(?u[rdf:type->?x]?u[?p->?y]?y[rdf:type->?c]  ))
]]></template>	
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?x</variable>
<variable>?p</variable>
<variable>?c</variable>
</templaterule>

<templaterule> 
<name>#cls-maxqc2</name>
<pattern>(?x owl:maxQualifiedCardinality 0) (?x owl:onProperty ?p) (?x owl:onClass owl:Thing)
</pattern>	
<rifquery type="xml"><![CDATA[:property[:prop->?x]:-And(?x[owl:maxQualifiedCardinality->0]?x[owl:onProperty->?p]?x[owl:onClass->owl:Thing])]]></rifquery>
<template><![CDATA[
Forall ?y ?u(rif:error("Reason: Arg.2[rdf:type->?x]Arg.2[?p->Arg.3] " ?u ?y) :- And(?u[rdf:type->?x]?u[?p->?y]  ))
       ]]></template>	
       <methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?x</variable>
<variable>?p</variable>
</templaterule>

<templaterule> 
<name>#cls-maxqc3</name>
<pattern>(?x owl:maxQualifiedCardinality 1) (?x owl:onProperty ?p) (?x owl:onClass ?c)
</pattern>	
<rifquery type="xml"><![CDATA[:property[:prop->?x]:-And(?x[owl:maxQualifiedCardinality->1]?x[owl:onProperty->?p]?x[owl:onClass->?c])]]></rifquery>
<template><![CDATA[
Forall ?y2 ?u ?y1 (?y1[owl:sameAs->?y2] :- And(?u[rdf:type->?x]?u[?p->?y1] ?y1[rdf:type->?c] ?u[?p->?y2] ?y2[rdf:type->?c]  ))
]]></template>	
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?x</variable>
<variable>?p</variable>
<variable>?c</variable>
</templaterule>


<templaterule> 
<name>#cls-maxqc4</name>
<pattern>(?x owl:maxQualifiedCardinality 1) (?x owl:onProperty ?p) (?x owl:onClass owl:Thing)
</pattern>	
<rifquery type="xml"><![CDATA[:property[:prop->?x]:-And(?x[owl:maxQualifiedCardinality->1]?x[owl:onProperty->?p]?x[owl:onClass->owl:Thing])]]></rifquery>
<template><![CDATA[
Forall ?y2 ?u ?y1 (?y1[owl:sameAs->?y2] :- And(?u[rdf:type->?x]?u[?p->?y1]?u[?p->?y2]  ))
]]></template>	
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?x</variable>
<variable>?p</variable>
</templaterule>

<templaterule> 
<name>#scm-hv</name>
<pattern>(?c1 owl:hasValue ?i) (?c1 owl:onProperty ?p1) (?c2 owl:hasValue ?i) (?c2 owl:onProperty ?p2)
</pattern>	
<rifquery type="xml"><![CDATA[:property[:prop->?c1]:-And(?c1[owl:hasValue->?i]?c1[owl:onProperty->?p1]?c2[owl:hasValue->?i]?c2[owl:onProperty->?p2])]]></rifquery>
<template><![CDATA[
 ?c1[rdfs:subClassOf->?c2] :- And( ?p1[rdfs:subPropertyOf->?p2]  ) 
]]></template>	
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?c1</variable>
<variable>?i</variable>
<variable>?p1</variable>
<variable>?c2</variable>
<variable>?p2</variable>
</templaterule>

<templaterule> 
<name>#scm-svf1</name>
<pattern>(?c1 owl:someValuesFrom ?y1)(?c1 owl:onProperty ?p)(?c2 owl:someValuesFrom ?y2)(?c2 owl:onProperty ?p)</pattern>	
<rifquery type="xml"><![CDATA[:property[:prop->?c1]:-And(?c1[owl:someValuesFrom->?y1]?c1[owl:onProperty->?p]?c2[owl:someValuesFrom->?y2]?c2[owl:onProperty->?p])]]></rifquery>
<template><![CDATA[
?c1[rdfs:subClassOf->?c2] :- And(?y1[rdfs:subClassOf->?y2]  )
]]></template>	
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?c1</variable>
<variable>?y1</variable>
<variable>?p</variable>
<variable>?y2</variable>
<variable>?c2</variable>
</templaterule>

<templaterule> 
<name>#scm-svf2</name>
<pattern>(?c1 owl:someValuesFrom ?y)(?c1 owl:onProperty ?p1)(?c2 owl:someValuesFrom ?y)(?c2 owl:onProperty ?p2)</pattern>	
<rifquery type="xml"><![CDATA[:property[:prop->?c1]:-And(?c1[owl:someValuesFrom->?y]?c1[owl:onProperty->?p1]?c2[owl:someValuesFrom->?y]?c2[owl:onProperty->?p2])]]></rifquery>
<template><![CDATA[
?c1[rdfs:subClassOf->?c2] :- And( ?p1[rdfs:subPropertyOf->?p2]  )
]]></template>	
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?c1</variable>
<variable>?p1</variable>
<variable>?y</variable>
<variable>?p2</variable>
<variable>?c2</variable>
</templaterule>

<templaterule> 
<name>#scm-avf1</name>
<pattern>(?c1 owl:allValuesFrom ?y1)(?c1 owl:onProperty ?p)(?c2 owl:allValuesFrom ?y2)(?c2 owl:onProperty ?p)</pattern>	
<rifquery type="xml"><![CDATA[rulenames:property[:prop->?c1]:-And(?c1[owl:allValuesFrom->?y1]?c1[owl:onProperty->?p]?c2[owl:allValuesFrom->?y2]?c2[owl:onProperty->?p])]]></rifquery>
<template><![CDATA[
 ?c1[rdfs:subClassOf->?c2] :- And(?y1[rdfs:subClassOf->?y2]  )
]]></template>	
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?c1</variable>
<variable>?y1</variable>
<variable>?p</variable>
<variable>?y2</variable>
<variable>?c2</variable>
</templaterule>

<templaterule> 
<name>#scm-avf2</name>
<pattern>(?c1 owl:allValuesFrom ?y)(?c1 owl:onProperty ?p1)(?c2 owl:allValuesFrom ?y)(?c2 owl:onProperty ?p2)</pattern>	
<rifquery type="xml"><![CDATA[:property[:prop->?c1]:-And(?c1[owl:allValuesFrom->?y]?c1[owl:onProperty->?p1]?c2[owl:allValuesFrom->?y]?c2[owl:onProperty->?p2])]]></rifquery>
<template><![CDATA[
  ?c2[rdfs:subClassOf->?c1] :- And(?p1[rdfs:subPropertyOf->?p2]  )
]]></template>	
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?c1</variable>
<variable>?p1</variable>
<variable>?y</variable>
<variable>?p2</variable>
<variable>?c2</variable>
</templaterule>






<templaterule> 
<name>#prp-adp</name>
<pattern><![CDATA[(?l rdf:type owl:AllDisjointProperties)]]></pattern>
<rifquery type="withforall"><![CDATA[
	
	 Forall ?x ?listname ?headOfList ?y(
                       rulenames:prp-adp(?listname ?x) :-
And(?listname[rdf:type->owl:AllDisjointProperties] ?listname[owl:members->?headOfList]
eg:membersOfList-spo(?headOfList ?x ?y))
               )
	  
               Forall ?x ?headOfList ?rest ?y ?y1(
                       eg:membersOfList-spo(?headOfList ?x ?y) :-
Or(And(?headOfList[rdf:first->?x] eg:count-spo(?headOfList ?y))
And(?headOfList[rdf:rest->?rest] eg:membersOfList-spo(?rest ?x ?y) ))
               )

               Forall ?headOfList ?y ?y1 ?rest (
                       eg:count-spo(?headOfList ?y) :-
Or(And(?headOfList[rdf:rest->rdf:nil] ?y=0) And(?headOfList[rdf:rest->?rest]
eg:count-spo(?rest ?y1) ?y=External(func:numeric-add(?y1 1))))
               )



]]></rifquery>
<methodname>emitForEachRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<template><![CDATA[
  Forall ?o ?v ( rif:error("Reason: Arg.2[?x->Arg.3]Arg.2[?y->Arg.3]) " ?v ?o ) :- And (?o[?x->?v]?o[?y->?v]) )
]]></template>	
<variable>?member</variable>
<variable>?headOfList</variable>
<variable>?rest</variable>
<variable>?list</variable>
<variable>?x</variable>
</templaterule>


<templaterule> 
<name>#cax-adc</name>
<pattern><![CDATA[(?l rdf:type owl:AllDisjointClasses)]]></pattern>
<rifquery type="withforall"><![CDATA[
	

 	 Forall ?x ?listname ?headOfList ?y(
                       rulenames:cax-adc(?listname ?x) :-
And(?listname[rdf:type->owl:AllDisjointClasses] ?listname[owl:members->?headOfList]
eg:membersOfList-spo(?headOfList ?x ?y))
               )
	  
               Forall ?x ?headOfList ?rest ?y ?y1(
                       eg:membersOfList-spo(?headOfList ?x ?y) :-
Or(And(?headOfList[rdf:first->?x] eg:count-spo(?headOfList ?y))
And(?headOfList[rdf:rest->?rest] eg:membersOfList-spo(?rest ?x ?y) ))
               )

               Forall ?headOfList ?y ?y1 ?rest (
                       eg:count-spo(?headOfList ?y) :-
Or(And(?headOfList[rdf:rest->rdf:nil] ?y=0) And(?headOfList[rdf:rest->?rest]
eg:count-spo(?rest ?y1) ?y=External(func:numeric-add(?y1 1))))
               )






]]></rifquery>
<methodname>emitForEachRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<template><![CDATA[
 Forall ?something (  rif:error("Reason: Arg.2[rdf:type->?x] Arg.2[rdf:type->?y] " ?something) :- And ( ?something[rdf:type->?x] ?something[rdf:type->?y]) )
]]></template>	
<variable>?member</variable>
<variable>?headOfList</variable>
<variable>?rest</variable>
<variable>?list</variable>
<variable>?x</variable>
</templaterule>

<templaterule> 
<name>#prp-spo2</name>
<pattern><![CDATA[(?p owl:propertyChainAxiom ?pc)]]></pattern>
<rifquery type="withforall"><![CDATA[
	
	
	
	 Forall ?x ?listname ?headOfList ?y(
                       rulenames:prp-spo2(?listname ?x ?y) :-
And(?listname[owl:propertyChainAxiom->?headOfList]
eg:membersOfList-spo(?headOfList ?x ?y))
               )
	  
               Forall ?x ?headOfList ?rest ?y ?y1(
                       eg:membersOfList-spo(?headOfList ?x ?y) :-
Or(And(?headOfList[rdf:first->?x] eg:count-spo(?headOfList ?y))
And(?headOfList[rdf:rest->?rest] eg:membersOfList-spo(?rest ?x ?y) ))
               )

               Forall ?headOfList ?y ?y1 ?rest (
                       eg:count-spo(?headOfList ?y) :-
Or(And(?headOfList[rdf:rest->rdf:nil] ?y=0) And(?headOfList[rdf:rest->?rest]
eg:count-spo(?rest ?y1) ?y=External(func:numeric-add(?y1 1))))
               )

	
]]></rifquery>
<methodname>emitPropertyChainRule</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<template><![CDATA[
 NOT IMPLEMENTED
]]></template>	
</templaterule>








<templaterule> 
<name>#prp-key</name>
<pattern><![CDATA[(?c owl:hasKey ?u)]]></pattern>
<rifquery type="withforall"><![CDATA[
	
	
	
	 Forall ?x ?listname ?headOfList ?y(
                       rulenames:prp-adp(?listname ?x) :-
And(?listname[owl:hasKey->?headOfList]
eg:membersOfList-spo(?headOfList ?x ?y))
               )
	  
               Forall ?x ?headOfList ?rest ?y ?y1(
                       eg:membersOfList-spo(?headOfList ?x ?y) :-
Or(And(?headOfList[rdf:first->?x] eg:count-spo(?headOfList ?y))
And(?headOfList[rdf:rest->?rest] eg:membersOfList-spo(?rest ?x ?y) ))
               )

               Forall ?headOfList ?y ?y1 ?rest (
                       eg:count-spo(?headOfList ?y) :-
Or(And(?headOfList[rdf:rest->rdf:nil] ?y=0) And(?headOfList[rdf:rest->?rest]
eg:count-spo(?rest ?y1) ?y=External(func:numeric-add(?y1 1))))
               )


	
]]></rifquery>
<methodname>emitHasKeyRule</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<template><![CDATA[
 TEMPLATE IN PROGRAMMCODE
]]></template>	
</templaterule>






<templaterule> 
<name>#cls-int1</name>
<pattern><![CDATA[(?c owl:intersectionOf ?l)]]></pattern>
<rifquery type="withforall"><![CDATA[
	
	
	

	 Forall ?x ?listname ?headOfList ?y(
                       rulenames:cls-int1(?listname ?x) :-
And(?listname[owl:intersectionOf->?headOfList]
eg:membersOfList-spo(?headOfList ?x ?y))
               )
	  
               Forall ?x ?headOfList ?rest ?y ?y1(
                       eg:membersOfList-spo(?headOfList ?x ?y) :-
Or(And(?headOfList[rdf:first->?x] eg:count-spo(?headOfList ?y))
And(?headOfList[rdf:rest->?rest] eg:membersOfList-spo(?rest ?x ?y) ))
               )

               Forall ?headOfList ?y ?y1 ?rest (
                       eg:count-spo(?headOfList ?y) :-
Or(And(?headOfList[rdf:rest->rdf:nil] ?y=0) And(?headOfList[rdf:rest->?rest]
eg:count-spo(?rest ?y1) ?y=External(func:numeric-add(?y1 1))))
               )

	
]]></rifquery>
<methodname>emitIntersectionOfRule1</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<template><![CDATA[
 TEMPLATE IN PROGRAMMCODE
]]></template>	
</templaterule>

<templaterule> 
<name>#scm-int</name>
<pattern><![CDATA[(?c owl:intersectionOf ?l)]]></pattern>
<rifquery type="withforall"><![CDATA[
	
	
	

 

 	 Forall ?x ?listname ?headOfList ?y(
                       rulenames:scm-int(?listname ?x) :-
And(?listname[owl:intersectionOf->?headOfList]
eg:membersOfList-spo(?headOfList ?x ?y))
               )
	  
               Forall ?x ?headOfList ?rest ?y ?y1(
                       eg:membersOfList-spo(?headOfList ?x ?y) :-
Or(And(?headOfList[rdf:first->?x] eg:count-spo(?headOfList ?y))
And(?headOfList[rdf:rest->?rest] eg:membersOfList-spo(?rest ?x ?y) ))
               )

               Forall ?headOfList ?y ?y1 ?rest (
                       eg:count-spo(?headOfList ?y) :-
Or(And(?headOfList[rdf:rest->rdf:nil] ?y=0) And(?headOfList[rdf:rest->?rest]
eg:count-spo(?rest ?y1) ?y=External(func:numeric-add(?y1 1))))
               )
	
]]></rifquery>
<methodname>emitIntersectionOfRule2</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<template><![CDATA[
 TEMPLATE IN PROGRAMMCODE
]]></template>	
</templaterule>

<templaterule> 
<name>#cls-uni</name>
<pattern><![CDATA[(?c owl:unionOf ?l)]]></pattern>
<rifquery type="withforall"><![CDATA[
	
	
	

	 Forall ?x ?listname ?headOfList ?y(
                       rulenames:cls-uni(?listname ?x) :-
And(?listname[owl:unionOf->?headOfList]
eg:membersOfList-spo(?headOfList ?x ?y))
               )
	  
               Forall ?x ?headOfList ?rest ?y ?y1(
                       eg:membersOfList-spo(?headOfList ?x ?y) :-
Or(And(?headOfList[rdf:first->?x] eg:count-spo(?headOfList ?y))
And(?headOfList[rdf:rest->?rest] eg:membersOfList-spo(?rest ?x ?y) ))
               )

               Forall ?headOfList ?y ?y1 ?rest (
                       eg:count-spo(?headOfList ?y) :-
Or(And(?headOfList[rdf:rest->rdf:nil] ?y=0) And(?headOfList[rdf:rest->?rest]
eg:count-spo(?rest ?y1) ?y=External(func:numeric-add(?y1 1))))
               )

	
]]></rifquery>
<methodname>emitUnionOfRule1</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<template><![CDATA[
 TEMPLATE IN PROGRAMMCODE
]]></template>	
</templaterule>


<templaterule> 
<name>#scm-uni</name>
<pattern><![CDATA[(?c owl:unionOf ?l)]]></pattern>
<rifquery type="withforall"><![CDATA[
	
	
	

 	 Forall ?x ?listname ?headOfList ?y(
                       rulenames:scm-uni(?listname ?x) :-
And(?listname[owl:unionOf->?headOfList]
eg:membersOfList-spo(?headOfList ?x ?y))
               )
	  
               Forall ?x ?headOfList ?rest ?y ?y1(
                       eg:membersOfList-spo(?headOfList ?x ?y) :-
Or(And(?headOfList[rdf:first->?x] eg:count-spo(?headOfList ?y))
And(?headOfList[rdf:rest->?rest] eg:membersOfList-spo(?rest ?x ?y) ))
               )

               Forall ?headOfList ?y ?y1 ?rest (
                       eg:count-spo(?headOfList ?y) :-
Or(And(?headOfList[rdf:rest->rdf:nil] ?y=0) And(?headOfList[rdf:rest->?rest]
eg:count-spo(?rest ?y1) ?y=External(func:numeric-add(?y1 1))))
               )

]]></rifquery>
<methodname>emitUnionOfRule2</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<template><![CDATA[
 TEMPLATE IN PROGRAMMCODE
]]></template>	
</templaterule>

<templaterule> 
<name>#cls-oo</name>
<pattern><![CDATA[(?c owl:oneOf ?l)]]></pattern>
<rifquery type="withforall"><![CDATA[
	
	
	

 	 Forall ?x ?listname ?headOfList ?y(
                       rulenames:cls-oo(?listname ?x) :-
And(?listname[owl:oneOf->?headOfList]
eg:membersOfList-spo(?headOfList ?x ?y))
               )
	  
               Forall ?x ?headOfList ?rest ?y ?y1(
                       eg:membersOfList-spo(?headOfList ?x ?y) :-
Or(And(?headOfList[rdf:first->?x] eg:count-spo(?headOfList ?y))
And(?headOfList[rdf:rest->?rest] eg:membersOfList-spo(?rest ?x ?y) ))
               )

               Forall ?headOfList ?y ?y1 ?rest (
                       eg:count-spo(?headOfList ?y) :-
Or(And(?headOfList[rdf:rest->rdf:nil] ?y=0) And(?headOfList[rdf:rest->?rest]
eg:count-spo(?rest ?y1) ?y=External(func:numeric-add(?y1 1))))
               )

]]></rifquery>
<methodname>emitOneOfRule</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<template><![CDATA[
TEMPLATE IN PROGRAMMCODE
]]></template>	
</templaterule>



<templaterule> 
<name>#prp-npa1</name>
<pattern>(?x owl:sourceIndividual ?i1)
(?x owl:assertionProperty ?p)
(?x owl:targetIndividual ?i2) 
</pattern>	
<rifquery type="xml"><![CDATA[:property[:prop->?x]:-And(
?x[owl:sourceIndividual->?i1]
?x[owl:assertionProperty->?p]
?x[owl:targetIndividual->?i2]
)]]>
</rifquery>
<template><![CDATA[
 rif:error("Reason: ?i1[?p->?i2]") :- And(?i1[?p->?i2]  )
 ]]></template>	
 <methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?p</variable>
<variable>?x</variable>
<variable>?i1</variable>
<variable>?i2</variable>
</templaterule>

<templaterule> 
<name>#prp-npa2</name>
<pattern>(?x owl:sourceIndividual ?i1)
(?x owl:assertionProperty ?p)
(?x owl:targetValue ?i2) 
</pattern>	
<rifquery type="xml"><![CDATA[:property[:prop->?x]:-And(
?x[owl:sourceIndividual->?i1]
?x[owl:assertionProperty->?p]
?x[owl:targetValue->?i2]
)]]>
</rifquery>
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<template><![CDATA[
 rif:error("Reason: ?i1[?p->?i2]") :- And(?i1[?p->?i2]  )
 ]]></template>	
<variable>?p</variable>
<variable>?x</variable>
<variable>?i1</variable>
<variable>?i2</variable>
</templaterule>

<templaterule> 
<name>#cax-dw</name>
<pattern>(?c1 owl:disjointWith ?c2) 
</pattern>	
<rifquery type="p1-prp-p2"><![CDATA[owl:disjointWith
 ]]></rifquery>
<template><![CDATA[
 Forall ?x (rif:error("Reason: Arg.2[rdf:type->?p1] Arg.2[rdf:type->?p2]" ?x) :- And(?x[rdf:type->?p1] ?x[rdf:type->?p2] ))
 ]]></template>	
 <methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?p1</variable>
<variable>?p2</variable>
</templaterule>

<templaterule> 
<name>#cls-com</name>
<pattern>(?c1 owl:complementOf ?c2) 
</pattern>	
<rifquery type="p1-prp-p2"><![CDATA[owl:complementOf
 ]]></rifquery>
<template><![CDATA[
 Forall ?x (rif:error("Reason: Arg.2[rdf:type->?p1] Arg.2[rdf:type->?p2]" ?x) :- And(?x[rdf:type->?p1] ?x[rdf:type->?p2] ))
 ]]></template>	
 <methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?p1</variable>
<variable>?p2</variable>
</templaterule>



<templaterule> 
<name>#eq-diff2</name>
<pattern><![CDATA[(?a rdf:type owl:AllDifferent)(?a owl:members ?l)]]></pattern>
<rifquery type="withforall"><![CDATA[
	



	 Forall ?x ?listname ?headOfList ?y(
                       rulenames:eq-diff2(?listname ?x) :-
And(?listname[rdf:type->owl:AllDifferent]
?listname[owl:members->?headOfList] 
eg:membersOfList-spo(?headOfList ?x ?y))
               )
	  
               Forall ?x ?headOfList ?rest ?y ?y1(
                       eg:membersOfList-spo(?headOfList ?x ?y) :-
Or(And(?headOfList[rdf:first->?x] eg:count-spo(?headOfList ?y))
And(?headOfList[rdf:rest->?rest] eg:membersOfList-spo(?rest ?x ?y) ))
               )

               Forall ?headOfList ?y ?y1 ?rest (
                       eg:count-spo(?headOfList ?y) :-
Or(And(?headOfList[rdf:rest->rdf:nil] ?y=0) And(?headOfList[rdf:rest->?rest]
eg:count-spo(?rest ?y1) ?y=External(func:numeric-add(?y1 1))))
               )

]]></rifquery>
<methodname>emitForEachRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<template><![CDATA[ rif:error("Reason: ?x[owl:sameAs->?y]" ?x) :- And ( ?x[owl:sameAs->?y] )
]]></template>	
</templaterule>

<templaterule> 
<name>#eq-diff3</name>
<pattern><![CDATA[(?a rdf:type owl:AllDifferent)(?a owl:distinctMembers ?l)]]></pattern>
<rifquery type="withforall"><![CDATA[
	
 Forall ?x ?listname ?headOfList ?y(
                       rulenames:eq-diff3(?listname ?x) :-
And(?listname[rdf:type->owl:AllDifferent]
?listname[owl:distinctMembers->?headOfList] 
eg:membersOfList-spo(?headOfList ?x ?y))
               )
	  
               Forall ?x ?headOfList ?rest ?y ?y1(
                       eg:membersOfList-spo(?headOfList ?x ?y) :-
Or(And(?headOfList[rdf:first->?x] eg:count-spo(?headOfList ?y))
And(?headOfList[rdf:rest->?rest] eg:membersOfList-spo(?rest ?x ?y) ))
               )

               Forall ?headOfList ?y ?y1 ?rest (
                       eg:count-spo(?headOfList ?y) :-
Or(And(?headOfList[rdf:rest->rdf:nil] ?y=0) And(?headOfList[rdf:rest->?rest]
eg:count-spo(?rest ?y1) ?y=External(func:numeric-add(?y1 1))))
               )
]]></rifquery>
<methodname>emitForEachRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<template><![CDATA[
  rif:error("Reason: ?x[owl:sameAs->?y]" ?x) :- And ( ?x[owl:sameAs->?y] )
]]></template>	
</templaterule>






<!-- from Fixed Ruleset -->





<templaterule> 
<name>#prp-dom</name>  
<rifquery type="withforall"><![CDATA[
	
Forall ?p ?c (
    rulenames:prp-dom[?p->?c]:- And(
       ?p[rdfs:domain->?c] ))

   
       
]]></rifquery>
<template><![CDATA[
  Forall ?x ?y(?x[rdf:type->?c]:-?x[?p->?y])
]]></template>	
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?p</variable>
<variable>?c</variable>
</templaterule>




<templaterule> 
<name>#cax-sco/#scm-sco</name> 
<rifquery type="withforall"><![CDATA[
	


Forall ?c3 ?c2 ?c1(

			rulenames:subclass(?c1 ?c3):-	Or ( ?c1[rdfs:subClassOf->?c3]
										And (
											?c1[rdfs:subClassOf->?c2]
											rulenames:subclass(?c2 ?c3)				
											)
					)
)
   
   
       
]]></rifquery>
<methodname>emitSubClassOfRule</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<template><![CDATA[
Forall ?x (?x[rdf:type->?c3]:-?x[rdf:type->?c1])
?c1[rdfs:subClassOf->?c3]
]]></template>	
<variable>?c3</variable>
<variable>?c1</variable>
</templaterule>




<templaterule> 
<name>#scm-spo</name>
<rifquery type="withforall"><![CDATA[
       
Forall ?p3 ?p2 ?p1(

			rulenames:subProperty(?p1 ?p3):-	Or ( ?p1[rdfs:subPropertyOf->?p3]
										And (
											?p1[rdfs:subPropertyOf->?p2]
											rulenames:subProperty(?p2 ?p3)				
											)
					)
)

]]></rifquery>
<template><![CDATA[
  ?p1[rdfs:subPropertyOf->?p3]
]]></template>	
<methodname>emitSubPropertyOfRule</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?p1</variable>
<variable>?p3</variable>
</templaterule>




<templaterule> 
<name>#scm-dom1</name>
  
<rifquery type="withforall"><![CDATA[

Forall ?p ?c1 ?c2 (
   ?p[rdfs:domain->?c2] :- And(
       ?p[rdfs:domain->?c1]
       ?c1[rdfs:subClassOf->?c2]  ))


]]></rifquery>
<template><![CDATA[
?p[rdfs:domain->?c2]
]]></template>	
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?p</variable>
<variable>?c2</variable>
</templaterule>


<templaterule> 
<name>#scm-dom2</name>
  
<rifquery type="withforall"><![CDATA[

Forall ?c ?p2 ?p1 (
   ?p1[rdfs:domain->?c] :- And(
       ?p2[rdfs:domain->?c]
       ?p1[rdfs:subPropertyOf->?p2]  ))

]]></rifquery>
<template><![CDATA[
?p1[rdfs:domain->?c]
]]></template>	
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?p1</variable>
<variable>?c</variable>
</templaterule>



<templaterule> 
<name>#scm-rng1</name>
  
<rifquery type="withforall"><![CDATA[

Forall ?p ?c1 ?c2 (
   ?p[rdfs:range->?c2] :- And(
       ?p[rdfs:range->?c1]
       ?c1[rdfs:subClassOf->?c2]  ))

]]></rifquery>
<template><![CDATA[
?p[rdfs:range->?c2]
]]></template>	
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?p</variable>
<variable>?c2</variable>
</templaterule>




<templaterule> 
<name>#scm-rng2</name>
  
<rifquery type="withforall"><![CDATA[
Forall ?c ?p2 ?p1 (
   ?p1[rdfs:range->?c] :- And(
       ?p2[rdfs:range->?c]
       ?p1[rdfs:subPropertyOf->?p2]  ))

]]></rifquery>
<template><![CDATA[
?p1[rdfs:range->?c]
]]></template>	
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?p1</variable>
<variable>?c</variable>
</templaterule>





<templaterule> 
<name>#cax-eqc1/2</name>
  
<rifquery type="withforall"><![CDATA[


Forall ?c1 ?c2 (
   rulenames:caxeqc1[?c1->?c2] :- 
       ?c1[owl:equivalentClass->?c2]
        )
        
        
        
]]></rifquery>
<template><![CDATA[
Forall ?x(?x[rdf:type->?c2]:-?x[rdf:type->?c1])
Forall ?x(?x[rdf:type->?c1]:-?x[rdf:type->?c2])
]]></template>	
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?c1</variable>
<variable>?c2</variable>
</templaterule>



<templaterule> 
<name>#cax-dw</name>
  
<rifquery type="withforall"><![CDATA[

Forall ?c1 ?c2 (
   rulenames:dw[?c1->?c2] :- And(
       ?c1[owl:disjointWith->?c2]
       ))
]]></rifquery>
<template><![CDATA[
Forall ?x(rif:error("Reason: Arg.2[rdf:type->?c1] Arg.2[rdf:type->?c2]" ?x):-And(?x[rdf:type->?c1] ?x[rdf:type->?c2]))
]]></template>	
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?c1</variable>
<variable>?c2</variable>
</templaterule>




<templaterule> 
<name>#scm-cls 0/1/2/3</name>
  
<rifquery type="withforall"><![CDATA[

Forall ?c (
   rulenames:cls[:prop->?c] :- ?c[rdf:type->owl:Class])
   
]]></rifquery>
<template><![CDATA[
?c[rdfs:subClassOf->?c]
?c[owl:equivalentClass->?c]
?c[rdfs:subClassOf->owl:Thing]
owl:Nothing[rdfs:subClassOf->?c]
]]></template>	
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?c</variable>
</templaterule>


<templaterule> 
<name>#scm-eqc1/11</name>
  
<rifquery type="withforall"><![CDATA[


Forall ?c1 ?c2 (
   rulenames:eqc[?c1->?c2] :- ?c1[owl:equivalentClass->?c2])

   
]]></rifquery>
<template><![CDATA[
?c1[rdfs:subClassOf->?c2]
?c2[rdfs:subClassOf->?c1]
]]></template>	
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<variable>?c</variable>
</templaterule>



<templaterule> 
<name>#scm-op/#scm-op1/#scm-dp/#scm-dp1</name> 
<rifquery type="withforall"><![CDATA[
	


Forall ?p (
   rulenames:op[:prop->?p] :- Or(?p[rdf:type->owl:ObjectProperty]?p[rdf:type->owl:DatatypeProperty]))



]]></rifquery>
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<template><![CDATA[
?p[rdfs:subPropertyOf->?p]
?p[owl:equivalentProperty->?p]
]]></template>	
</templaterule>




<templaterule> 
<name>#scm-eqp2</name> 
<rifquery type="withforall"><![CDATA[
	

Forall ?p2 ?p1 (
   ?p1[owl:equivalentProperty->?p2] :- And(
       ?p1[rdfs:subPropertyOf->?p2]
       ?p2[rdfs:subPropertyOf->?p1]  ))
       
]]></rifquery>
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<template><![CDATA[
?p1[owl:equivalentProperty->?p2]
]]></template>	
<variable>?p1</variable>
<variable>?p2</variable>
</templaterule>

<templaterule> 
<name>#scm-eqc2</name> 
<rifquery type="withforall"><![CDATA[
	

Forall ?c1 ?c2 (
   ?c1[owl:equivalentClass->?c2] :- And(
       ?c1[rdfs:subClassOf->?c2]
       ?c2[rdfs:subClassOf->?c1]  ))
       
]]></rifquery>
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<template><![CDATA[
c1[owl:equivalentClass->?c2]
]]></template>	
<variable>?c1</variable>
<variable>?c2</variable>
</templaterule>




<templaterule> 
<name>#scm-eqp1/#scm-eqp11</name> 
<rifquery type="withforall"><![CDATA[
	

Forall ?p2 ?p1 (
   rulenames:eqp[?p1->?p2] :- ?p1[owl:equivalentProperty->?p2])


       
]]></rifquery>
<methodname>emitPropertyRules</methodname><classname>lupos.owl2rl.emitter.RuleEmitter</classname>
<template><![CDATA[
?p1[rdfs:subPropertyOf->?p2]
?p2[rdfs:subPropertyOf->?p1]
]]></template>	
<variable>?p1</variable>
<variable>?p2</variable>
</templaterule>

<fixedrules><![CDATA[


(*ALTERNATIVE*)


(* <#eq-ref> *)
Forall ?p ?o ?s (
   ?s[owl:sameAs->?s] :- 
   And(
    Or(
        External(pred:is-uri(?s))
        External(pred:is-blanknode(?s))
        ) 
   ?s[?p->?o]))

(* <#eq-ref1> *)
Forall ?p ?o ?s (
   ?p[owl:sameAs->?p] :-  And(
    Or(
        External(pred:is-uri(?p))
        External(pred:is-blanknode(?p))
        ) 
    ?s[?p->?o]))

(* <#eq-ref2> *)
Forall ?p ?o ?s (
   ?o[owl:sameAs->?o] :-  And(
    Or(
        External(pred:is-uri(?o))
        External(pred:is-blanknode(?o))
        ) 
        ?s[?p->?o]))

(* <#eq-sym> *)
Forall ?x ?y (
   ?y[owl:sameAs->?x] :-  And(
    Or(
        External(pred:is-uri(?y))
        External(pred:is-blanknode(?y))
        ) ?x[owl:sameAs->?y]))

(* <#eq-trans> *)
Forall ?x ?z ?y (
   ?x[owl:sameAs->?z] :- And(
   
       ?x[owl:sameAs->?y]
       ?y[owl:sameAs->?z]  
        Or(
        External(pred:is-uri(?x))
        External(pred:is-blanknode(?x))
        )))

(* <#eq-rep-s> *)
Forall ?p ?o ?s ?s2 (
   ?s2[?p->?o] :- And(
       ?s[owl:sameAs->?s2]
       ?s[?p->?o]  ))

(* <#eq-rep-p> *)
Forall ?p ?o ?s ?p2 (
   ?s[?p2->?o] :- And(
       ?p[owl:sameAs->?p2]
       ?s[?p->?o]  ))

(* <#eq-rep-o> *)
Forall ?p ?o ?s ?o2 (
   ?s[?p->?o2] :- And(
       ?o[owl:sameAs->?o2]
       ?s[?p->?o]  ))

(* <#eq-diff1> *)
Forall ?x ?y (
   rif:error("Reason: And(Arg.2 [owl:sameAs->Arg.3]Arg.2[owl:differentFrom->Arg.3] " ?x ?y) :- And(
       ?x[owl:sameAs->?y]
       ?x[owl:differentFrom->?y]  ))

(* <#prp-ap-label> *)
   rdfs:label[rdf:type->owl:AnnotationProperty]

(* <#prp-ap-comment> *)
   rdfs:comment[rdf:type->owl:AnnotationProperty]

(* <#prp-ap-seeAlso> *)
   rdfs:seeAlso[rdf:type->owl:AnnotationProperty]

(* <#prp-ap-isDefinedBy> *)
   rdfs:isDefinedBy[rdf:type->owl:AnnotationProperty]

(* <#prp-ap-deprecated> *)
   owl:deprecated[rdf:type->owl:AnnotationProperty]

(* <#prp-ap-priorVersion> *)
   owl:priorVersion[rdf:type->owl:AnnotationProperty]

(* <#prp-ap-backwardCompatibleWith> *)
   owl:backwardCompatibleWith[rdf:type->owl:AnnotationProperty]

(* <#prp-ap-incompatibleWith> *)
   owl:incompatibleWith[rdf:type->owl:AnnotationProperty]



(* <#cls-thing> *)
   owl:Thing[rdf:type->owl:Class]

(* <#cls-nothing1> *)
   owl:Nothing[rdf:type->owl:Class]

(* <#cls-nothing2> *)
Forall ?x (
   rif:error("Reason: Arg.2[rdf:type->owl:Nothing]" ?x) :- ?x[rdf:type->owl:Nothing])






 (* <#dt-type2> *)
 Group (
    Forall ?s ?p ?lt ( ?lt[rdf:type->rdf:PlainLiteral rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-PlainLiteral( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->rdf:XMLLiteral rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-XMLLiteral( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:decimal rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-decimal( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:integer rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-integer( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:nonNegativeInteger rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-nonNegativeInteger( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:nonPositiveInteger rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-nonPositiveInteger( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:positiveInteger rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-positiveInteger( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:negativeInteger rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-negativeInteger( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:long rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-long( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:int rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-int( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:short rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-short( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:byte rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-byte( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:unsignedLong rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-unsignedLong( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:unsignedInt rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-unsignedInt( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:unsignedShort rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-unsignedShort( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:unsignedByte rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-unsignedByte( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:float rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-float( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:double rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-double( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:string rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-string( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:normalizedString rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-normalizedString( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:token rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-token( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:language rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-language( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:Name rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-Name( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:NCName rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-NCName( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:NMTOKEN rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-NMTOKEN( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:boolean rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-boolean( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:hexBinary rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-hexBinary( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:base64Binary rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-base64Binary( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:anyURI rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-anyURI( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:dateTime rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-dateTime( ?lt )) ))
    Forall ?s ?p ?lt ( ?lt[rdf:type->xsd:dateTimeStamp  rdf:type->rdfs:Literal]
                     :- And( ?s[?p->?lt] External( pred:is-literal-dateTimeStamp ( ?lt )) ))
 )

(* <#dt-not-type> *)
Group (

  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->rdf:PlainLiteral] External(pred:is-literal-not-PlainLiteral( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->rdf:XMLLiteral] External(pred:is-literal-not-XMLLiteral( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:decimal] External(pred:is-literal-not-decimal( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:integer] External(pred:is-literal-not-integer( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:nonNegativeInteger] External(pred:is-literal-not-nonNegativeInteger( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:nonPositiveInteger] External(pred:is-literal-not-nonPositiveInteger( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:positiveInteger] External(pred:is-literal-not-positiveInteger( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:negativeInteger] External(pred:is-literal-not-negativeInteger( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:long] External(pred:is-literal-not-long( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:int] External(pred:is-literal-not-int( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:short] External(pred:is-literal-not-short( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:byte] External(pred:is-literal-not-byte( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:unsignedLong] External(pred:is-literal-not-unsignedLong( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:unsignedInt] External(pred:is-literal-not-unsignedInt( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:unsignedShort] External(pred:is-literal-not-unsignedShort( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:unsignedByte] External(pred:is-literal-not-unsignedByte( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:float] External(pred:is-literal-not-float( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:double] External(pred:is-literal-not-double( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:string] External(pred:is-literal-not-string( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:normalizedString] External(pred:is-literal-not-normalizedString( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:token] External(pred:is-literal-not-token( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:language] External(pred:is-literal-not-language( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:Name] External(pred:is-literal-not-Name( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:NCName] External(pred:is-literal-not-NCName( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:NMTOKEN] External(pred:is-literal-not-NMTOKEN( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:boolean] External(pred:is-literal-not-boolean( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:hexBinary] External(pred:is-literal-not-hexBinary( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:base64Binary] External(pred:is-literal-not-base64Binary( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:anyURI] External(pred:is-literal-not-anyURI( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:dateTime] External(pred:is-literal-not-dateTime( ?lt )) ))
  Forall ?lt (
   rif:error() :- And (
     ?lt[rdf:type->xsd:dateTimeStamp ] External(pred:is-literal-not-dateTimeStamp ( ?lt )) ))
)

(* <#eq-diff1-literal1> *)
Forall ?x ?y ?s1 ?s2 ?p1 ?p2 (
   rif:error("Reason: And( Arg.2[Arg.3->Arg.4]  Arg.5[Arg.6->Arg.7] Arg.4[owl:sameAs->Arg.7]External(pred:literalNotIdentical(Arg.4 Arg.7))  )" ?s1 ?p1 ?x ?s2 ?p2 ?y ) :- And(
       ?s1[?p1->?x]  ?s2[?p2->?y]
       ?x[owl:sameAs->?y]
       External(pred:literalNotIdentical(?x ?y))  ))

(* <#eq-diff1-literal2> *)
Forall ?x ?y ?s1 ?s2 ?p1 ?p2 (
   rif:error("Reason: And(Arg.4[Arg.6->Arg.2]  Arg.5[Arg.7->Arg.3] Arg.2 = Arg.3 Arg.2[owl:differentFrom->Arg.3]  ) " ?x ?y ?s1 ?s2 ?p1 ?p2) :- And(
       ?s1[?p1->?x]  ?s2[?p2->?y]
       ?x = ?y
       ?x[owl:differentFrom->?y]  ))
                  
(* <#dt-type1-PlainLiteral> *) rdf:PlainLiteral[rdf:type -> rdfs:Datatype]
(* <#dt-type1-decimal> *) xsd:decimal[rdf:type -> rdfs:Datatype]
(* <#dt-type1-integer> *) xsd:integer[rdf:type -> rdfs:Datatype]
(* <#dt-type1-double> *) xsd:double[rdf:type -> rdfs:Datatype]
(* <#dt-type1-string> *) xsd:string[rdf:type -> rdfs:Datatype]
(* <#dt-type1-dateTime> *) xsd:dateTime[rdf:type -> rdfs:Datatype]
(* <#dt-type1-XMLLiteral> *) rdf:XMLLiteral[rdf:type -> rdfs:Datatype]
(* <#dt-type1-Literal> *) rdfs:Literal[rdf:type -> rdfs:Datatype]

(* <#dt-type1-nonNegativeInteger> *) xsd:nonNegativeInteger[rdf:type -> rdfs:Datatype]
(* <#dt-type1-nonPositiveInteger> *) xsd:nonPositiveInteger[rdf:type -> rdfs:Datatype]
(* <#dt-type1-positiveInteger> *) xsd:positiveInteger[rdf:type -> rdfs:Datatype]
(* <#dt-type1-negativeInteger> *) xsd:negativeInteger[rdf:type -> rdfs:Datatype]
(* <#dt-type1-long> *) xsd:long[rdf:type -> rdfs:Datatype]
(* <#dt-type1-int> *) xsd:int[rdf:type -> rdfs:Datatype]
(* <#dt-type1-short> *) xsd:short[rdf:type -> rdfs:Datatype]
(* <#dt-type1-byte> *) xsd:byte[rdf:type -> rdfs:Datatype]
(* <#dt-type1-unsignedLong> *) xsd:unsignedLong[rdf:type -> rdfs:Datatype]
(* <#dt-type1-unsignedInt> *) xsd:unsignedInt[rdf:type -> rdfs:Datatype]
(* <#dt-type1-unsignedShort> *) xsd:unsignedShort[rdf:type -> rdfs:Datatype]
(* <#dt-type1-unsignedByte> *) xsd:unsignedByte[rdf:type -> rdfs:Datatype]
(* <#dt-type1-normalizedString> *) xsd:normalizedString[rdf:type -> rdfs:Datatype]
(* <#dt-type1-token> *) xsd:token[rdf:type -> rdfs:Datatype]
(* <#dt-type1-language> *) xsd:language[rdf:type -> rdfs:Datatype]
(* <#dt-type1-Name> *) xsd:Name[rdf:type -> rdfs:Datatype]
(* <#dt-type1-NCName> *) xsd:NCName[rdf:type -> rdfs:Datatype]
(* <#dt-type1-NMTOKEN> *) xsd:NMTOKEN[rdf:type -> rdfs:Datatype]

(* <#dt-type1-float> *) xsd:float[rdf:type -> rdfs:Datatype]
(* <#dt-type1-boolean> *) xsd:boolean[rdf:type -> rdfs:Datatype]
(* <#dt-type1-hexBinary> *) xsd:hexBinary[rdf:type -> rdfs:Datatype]
(* <#dt-type1-base64Binary> *) xsd:base64Binary[rdf:type -> rdfs:Datatype]
(* <#dt-type1-anyURI> *) xsd:anyURI[rdf:type -> rdfs:Datatype]
(* <#dt-type1-dateTimeStamp> *) xsd:dateTimeStamp [rdf:type -> rdfs:Datatype]



]]></fixedrules>


</templaterule-document>
